apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-agent-code
  namespace: mcp-mesh
data:
  # Example agent implementation
  hello_world.py: |
    #!/usr/bin/env python3
    """Example MCP Mesh agent with multiple capabilities."""

    import os
    import logging
    from datetime import datetime
    from typing import Optional

    from fastmcp import FastMCP
    from mcp_mesh import mesh_agent, depends, mesh_tool

    # Set up logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    # Create MCP server
    mcp = FastMCP("hello-world-agent")


    @mcp.tool()
    @mesh_agent(
        capabilities=["greeting", "time_telling"],
        version="1.0.0",
        description="A friendly greeting agent",
        enable_http=True,
        health_interval=30,
    )
    def greet(name: str, language: str = "en") -> str:
        """Greet someone in their preferred language."""
        greetings = {
            "en": f"Hello, {name}!",
            "es": f"¡Hola, {name}!",
            "fr": f"Bonjour, {name}!",
            "de": f"Hallo, {name}!",
            "it": f"Ciao, {name}!",
            "pt": f"Olá, {name}!",
            "ja": f"こんにちは、{name}さん!",
            "zh": f"你好，{name}!",
        }

        greeting = greetings.get(language, greetings["en"])
        logger.info(f"Greeting {name} in {language}: {greeting}")
        return greeting


    @mcp.tool()
    @mesh_agent(
        capabilities=["time_telling"],
        version="1.0.0",
        enable_http=True,
    )
    def get_current_time(timezone: Optional[str] = None) -> str:
        """Get the current time, optionally in a specific timezone."""
        from zoneinfo import ZoneInfo

        if timezone:
            try:
                tz = ZoneInfo(timezone)
                now = datetime.now(tz)
                return f"Current time in {timezone}: {now.strftime('%Y-%m-%d %H:%M:%S %Z')}"
            except Exception as e:
                return f"Error getting time for timezone {timezone}: {str(e)}"
        else:
            now = datetime.now()
            return f"Current time (local): {now.strftime('%Y-%m-%d %H:%M:%S')}"


    @mcp.tool()
    @mesh_agent(
        capabilities=["translation"],
        dependencies=["translation-service"],
        version="1.0.0",
        enable_http=True,
        fallback_mode=True,
    )
    def translate(
        text: str,
        source_lang: str,
        target_lang: str,
        translation_service: Optional[Any] = depends("translation-service")
    ) -> str:
        """Translate text from one language to another."""
        if translation_service:
            # Use the injected translation service
            try:
                result = translation_service.translate(text, source_lang, target_lang)
                return result
            except Exception as e:
                logger.error(f"Translation service error: {e}")

        # Fallback mode - return a mock translation
        return f"[Mock translation from {source_lang} to {target_lang}]: {text}"


    @mcp.tool()
    @mesh_tool(
        capability="calculation",
        version="1.0.0",
        timeout=10,
        cache_enabled=True,
        cache_ttl=300,
    )
    def calculate(expression: str) -> float:
        """Safely evaluate a mathematical expression."""
        # Only allow safe operations
        allowed_names = {
            'abs': abs, 'round': round, 'min': min, 'max': max,
            'sum': sum, 'pow': pow, 'len': len,
        }

        # Basic safety check
        forbidden = ['import', 'exec', 'eval', '__', 'open', 'file']
        if any(f in expression for f in forbidden):
            raise ValueError("Unsafe expression")

        try:
            # Use eval with restricted globals
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return float(result)
        except Exception as e:
            raise ValueError(f"Invalid expression: {str(e)}")


    # Health check endpoint (automatically created by mesh_agent)
    @mcp.tool()
    def health_check() -> dict:
        """Custom health check implementation."""
        return {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "version": "1.0.0",
            "capabilities": ["greeting", "time_telling", "translation", "calculation"],
            "metrics": {
                "requests_processed": 0,  # Would track this in production
                "average_response_time": 0.0,
                "error_rate": 0.0,
            }
        }


    if __name__ == "__main__":
        # Run the MCP server
        logger.info("Starting Hello World MCP Mesh Agent...")
        mcp.run()

  # Utility functions that can be imported by agents
  utils.py: |
    """Utility functions for MCP Mesh agents."""

    import asyncio
    import functools
    import time
    from typing import Any, Callable, Optional, TypeVar, Union


    T = TypeVar('T')


    def retry(
        max_attempts: int = 3,
        delay: float = 1.0,
        backoff: float = 2.0,
        exceptions: tuple = (Exception,)
    ) -> Callable:
        """Decorator to retry a function on failure."""
        def decorator(func: Callable[..., T]) -> Callable[..., T]:
            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs) -> T:
                last_exception = None
                current_delay = delay

                for attempt in range(max_attempts):
                    try:
                        return await func(*args, **kwargs)
                    except exceptions as e:
                        last_exception = e
                        if attempt < max_attempts - 1:
                            await asyncio.sleep(current_delay)
                            current_delay *= backoff

                raise last_exception

            @functools.wraps(func)
            def sync_wrapper(*args, **kwargs) -> T:
                last_exception = None
                current_delay = delay

                for attempt in range(max_attempts):
                    try:
                        return func(*args, **kwargs)
                    except exceptions as e:
                        last_exception = e
                        if attempt < max_attempts - 1:
                            time.sleep(current_delay)
                            current_delay *= backoff

                raise last_exception

            if asyncio.iscoroutinefunction(func):
                return async_wrapper
            else:
                return sync_wrapper

        return decorator


    def timeout(seconds: float) -> Callable:
        """Decorator to add timeout to a function."""
        def decorator(func: Callable[..., T]) -> Callable[..., T]:
            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs) -> T:
                return await asyncio.wait_for(
                    func(*args, **kwargs),
                    timeout=seconds
                )

            @functools.wraps(func)
            def sync_wrapper(*args, **kwargs) -> T:
                # For sync functions, we'd need threading
                # This is a simplified version
                return func(*args, **kwargs)

            if asyncio.iscoroutinefunction(func):
                return async_wrapper
            else:
                return sync_wrapper

        return decorator


    class CircuitBreaker:
        """Simple circuit breaker implementation."""

        def __init__(
            self,
            failure_threshold: int = 5,
            recovery_timeout: float = 30.0,
            expected_exception: type = Exception
        ):
            self.failure_threshold = failure_threshold
            self.recovery_timeout = recovery_timeout
            self.expected_exception = expected_exception
            self.failure_count = 0
            self.last_failure_time = None
            self.state = "closed"  # closed, open, half-open

        def __call__(self, func: Callable[..., T]) -> Callable[..., T]:
            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs) -> T:
                if self.state == "open":
                    if (
                        self.last_failure_time and
                        time.time() - self.last_failure_time > self.recovery_timeout
                    ):
                        self.state = "half-open"
                    else:
                        raise Exception("Circuit breaker is open")

                try:
                    result = await func(*args, **kwargs)
                    if self.state == "half-open":
                        self.state = "closed"
                        self.failure_count = 0
                    return result
                except self.expected_exception as e:
                    self.failure_count += 1
                    self.last_failure_time = time.time()

                    if self.failure_count >= self.failure_threshold:
                        self.state = "open"

                    raise e

            @functools.wraps(func)
            def sync_wrapper(*args, **kwargs) -> T:
                if self.state == "open":
                    if (
                        self.last_failure_time and
                        time.time() - self.last_failure_time > self.recovery_timeout
                    ):
                        self.state = "half-open"
                    else:
                        raise Exception("Circuit breaker is open")

                try:
                    result = func(*args, **kwargs)
                    if self.state == "half-open":
                        self.state = "closed"
                        self.failure_count = 0
                    return result
                except self.expected_exception as e:
                    self.failure_count += 1
                    self.last_failure_time = time.time()

                    if self.failure_count >= self.failure_threshold:
                        self.state = "open"

                    raise e

            if asyncio.iscoroutinefunction(func):
                return async_wrapper
            else:
                return sync_wrapper
