//  AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AgentInfoAgentType.
const (
	AgentInfoAgentTypeApi      AgentInfoAgentType = "api"
	AgentInfoAgentTypeMcpAgent AgentInfoAgentType = "mcp_agent"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for DependencyResolutionInfoStatus.
const (
	DependencyResolutionInfoStatusAvailable   DependencyResolutionInfoStatus = "available"
	DependencyResolutionInfoStatusUnavailable DependencyResolutionInfoStatus = "unavailable"
	DependencyResolutionInfoStatusUnresolved  DependencyResolutionInfoStatus = "unresolved"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	MeshAgentRegistrationAgentTypeApi      MeshAgentRegistrationAgentType = "api"
	MeshAgentRegistrationAgentTypeMcpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	MeshRegistrationResponseDependenciesResolvedStatusAvailable   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	MeshRegistrationResponseDependenciesResolvedStatusDegraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	MeshRegistrationResponseDependenciesResolvedStatusUnavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// Defines values for ResolvedLLMProviderStatus.
const (
	Available   ResolvedLLMProviderStatus = "available"
	Degraded    ResolvedLLMProviderStatus = "degraded"
	Unavailable ResolvedLLMProviderStatus = "unavailable"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType    AgentInfoAgentType `json:"agent_type"`
	Capabilities []CapabilityInfo   `json:"capabilities"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int `json:"dependencies_resolved"`

	// DependencyResolutions List of all dependency resolutions (both resolved and unresolved)
	DependencyResolutions *[]DependencyResolutionInfo `json:"dependency_resolutions,omitempty"`
	Endpoint              string                      `json:"endpoint"`
	Id                    string                      `json:"id"`
	LastSeen              *time.Time                  `json:"last_seen,omitempty"`
	Name                  string                      `json:"name"`
	Status                AgentInfoStatus             `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoAgentType Type of service - mcp_agent provides capabilities, api consumes them
type AgentInfoAgentType string

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// DependencyResolutionInfo defines model for DependencyResolutionInfo.
type DependencyResolutionInfo struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Endpoint Provider endpoint (NULL if unresolved)
	Endpoint *string `json:"endpoint,omitempty"`

	// FunctionName Function requiring this dependency
	FunctionName string `json:"function_name"`

	// McpTool MCP tool name on provider (NULL if unresolved)
	McpTool *string `json:"mcp_tool,omitempty"`

	// ProviderAgentId Provider agent ID (NULL if unresolved)
	ProviderAgentId *string `json:"provider_agent_id,omitempty"`

	// Status Dependency resolution status
	Status DependencyResolutionInfoStatus `json:"status"`

	// Tags Required tags for matching
	Tags *[]string `json:"tags,omitempty"`
}

// DependencyResolutionInfoStatus Dependency resolution status
type DependencyResolutionInfoStatus string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// LLMProvider LLM provider specification for mesh delegation mode.
// When @mesh.llm uses provider=dict, the registry resolves a matching LLM provider
// agent and returns its endpoint in llm_providers response field.
//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
type LLMProvider struct {
	// Capability Required capability name (typically "llm")
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching with operators:
	// - "tag" = required
	// - "+tag" = preferred
	// - "-tag" = excluded
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint (semver format)
	Version *string `json:"version,omitempty"`
}

// LLMToolInfo Complete tool information for LLM consumption.
// Includes everything an LLM needs to understand and call the tool via MCP protocol.
type LLMToolInfo struct {
	// Capability Capability name this tool provides
	Capability string `json:"capability"`

	// Description Human-readable tool description for LLM context
	Description string `json:"description"`

	// Endpoint Agent endpoint for MCP protocol calls
	Endpoint string `json:"endpoint"`

	// InputSchema JSON Schema for tool parameters (MCP format).
	// LLM uses this to understand required and optional parameters.
	InputSchema map[string]interface{} `json:"inputSchema"`

	// Kwargs Proxy configuration for tool execution (timeout, retry, streaming, etc.).
	// Passed to UnifiedMCPProxy for enhanced client behavior.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Name Function name (MCP protocol level)
	Name string `json:"name"`

	// Tags Capability tags
	Tags *[]string `json:"tags,omitempty"`

	// Version Tool version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistration Service registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Supports both agents (agent_type=mcp_agent) and API services (agent_type=api).
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions).
	// Tools can optionally include llm_filter if decorated with @mesh.llm.
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of service - mcp_agent provides capabilities, api consumes them
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	//  AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`

	// LlmProviders Map of function_name to resolved LLM provider for mesh delegation.
	// Populated only when tool includes llm_provider specification.
	// Registry resolves matching LLM provider agent based on capability/tags/version.
	//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
	LlmProviders *map[string]ResolvedLLMProvider `json:"llm_providers,omitempty"`

	// LlmTools Map of function_name to filtered tool list for LLM agents.
	// Enables LLM agents to receive auto-filtered, up-to-date tool lists based on llm_filter in tool registration.
	//  AI NOTE: This is populated only when tool includes llm_filter.
	// Registry applies filtering logic and returns matching tools with full schemas.
	LlmTools  *map[string][]LLMToolInfo      `json:"llm_tools,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// InputSchema JSON Schema for function parameters (MCP tool format).
	// Auto-generated from function signature by FastMCP.
	// Used by LLM agents to understand how to call this tool.
	InputSchema *map[string]interface{} `json:"inputSchema,omitempty"`

	// Kwargs Additional kwargs from @mesh.tool decorator for enhanced client proxy configuration.
	// Supports timeout, retry_count, custom_headers, streaming, auth_required, etc.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// LlmFilter Optional LLM tool filter specification when function is decorated with @mesh.llm.
	// Defines which tools this LLM agent needs access to.
	// Stored as JSON, follows LLMToolFilter schema structure.
	LlmFilter *map[string]interface{} `json:"llm_filter,omitempty"`

	// LlmProvider LLM provider specification for mesh delegation mode.
	// When @mesh.llm uses provider=dict, the registry resolves a matching LLM provider
	// agent and returns its endpoint in llm_providers response field.
	//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
	LlmProvider *LLMProvider `json:"llm_provider,omitempty"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// ResolvedLLMProvider Resolved LLM provider information for mesh delegation.
// Contains all necessary data to create a proxy and delegate LLM calls to this provider.
//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
type ResolvedLLMProvider struct {
	// AgentId ID of the provider agent
	AgentId string `json:"agent_id"`

	// Capability Capability name (typically "llm")
	Capability string `json:"capability"`

	// Endpoint Provider agent endpoint for MCP protocol calls
	Endpoint string `json:"endpoint"`

	// Kwargs Optional proxy configuration (timeout, retry, etc.).
	// Passed to UnifiedMCPProxy for enhanced client behavior.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Name Function name of the LLM provider tool
	Name string `json:"name"`

	// Status Current status of the provider
	Status ResolvedLLMProviderStatus `json:"status"`

	// Tags Provider capability tags
	Tags *[]string `json:"tags,omitempty"`

	// Vendor LLM vendor/provider name extracted from model string.
	// Used by consumer to select appropriate ProviderHandler for optimal LLM interaction.
	// Automatically extracted using LiteLLM's get_llm_provider() function during provider registration.
	// Common values: "anthropic", "openai", "google", "cohere", "ollama", "together", etc.
	Vendor string `json:"vendor"`

	// Version Provider version
	Version *string `json:"version,omitempty"`
}

// ResolvedLLMProviderStatus Current status of the provider
type ResolvedLLMProviderStatus string

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Graceful agent unregistration
	// (DELETE /agents/{agent_id})
	UnregisterAgent(c *gin.Context, agentId string)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Registry health check (headers only)
	// (HEAD /health)
	HeadHealth(c *gin.Context)
	// Agent registration and heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
	// Fast agent health check
	// (HEAD /heartbeat/{agent_id})
	FastHeartbeatCheck(c *gin.Context, agentId string)
	// Stream trace events for a specific trace ID
	// (GET /traces/{trace_id}/stream)
	StreamTrace(c *gin.Context, traceId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// UnregisterAgent operation middleware
func (siw *ServerInterfaceWrapper) UnregisterAgent(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterAgent(c, agentId)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// HeadHealth operation middleware
func (siw *ServerInterfaceWrapper) HeadHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeadHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// FastHeartbeatCheck operation middleware
func (siw *ServerInterfaceWrapper) FastHeartbeatCheck(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FastHeartbeatCheck(c, agentId)
}

// StreamTrace operation middleware
func (siw *ServerInterfaceWrapper) StreamTrace(c *gin.Context) {

	var err error

	// ------------- Path parameter "trace_id" -------------
	var traceId string

	err = runtime.BindStyledParameterWithOptions("simple", "trace_id", c.Param("trace_id"), &traceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trace_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.StreamTrace(c, traceId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.DELETE(options.BaseURL+"/agents/:agent_id", wrapper.UnregisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.HEAD(options.BaseURL+"/health", wrapper.HeadHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
	router.HEAD(options.BaseURL+"/heartbeat/:agent_id", wrapper.FastHeartbeatCheck)
	router.GET(options.BaseURL+"/traces/:trace_id/stream", wrapper.StreamTrace)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"24f/DQAA//+N0oEGIWIAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
