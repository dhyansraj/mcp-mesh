// ðŸ¤– AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	McpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	Available   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	Degraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	Unavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	Capabilities []CapabilityInfo `json:"capabilities"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int             `json:"dependencies_resolved"`
	Endpoint             string          `json:"endpoint"`
	Id                   string          `json:"id"`
	LastSeen             *time.Time      `json:"last_seen,omitempty"`
	Name                 string          `json:"name"`
	Status               AgentInfoStatus `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// MeshAgentRegistration Agent registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Based on @mesh.tool decorator processing - always has at least one tool.
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of agent (always mcp_agent for mesh tools)
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions)
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of agent (always mcp_agent for mesh tools)
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	// ðŸ¤– AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// Kwargs Additional kwargs from @mesh.tool decorator for enhanced client proxy configuration.
	// Supports timeout, retry_count, custom_headers, streaming, auth_required, etc.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Graceful agent unregistration
	// (DELETE /agents/{agent_id})
	UnregisterAgent(c *gin.Context, agentId string)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Registry health check (headers only)
	// (HEAD /health)
	HeadHealth(c *gin.Context)
	// Agent registration and heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
	// Fast agent health check
	// (HEAD /heartbeat/{agent_id})
	FastHeartbeatCheck(c *gin.Context, agentId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// UnregisterAgent operation middleware
func (siw *ServerInterfaceWrapper) UnregisterAgent(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterAgent(c, agentId)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// HeadHealth operation middleware
func (siw *ServerInterfaceWrapper) HeadHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeadHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// FastHeartbeatCheck operation middleware
func (siw *ServerInterfaceWrapper) FastHeartbeatCheck(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FastHeartbeatCheck(c, agentId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.DELETE(options.BaseURL+"/agents/:agent_id", wrapper.UnregisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.HEAD(options.BaseURL+"/health", wrapper.HeadHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
	router.HEAD(options.BaseURL+"/heartbeat/:agent_id", wrapper.FastHeartbeatCheck)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"4LKtL9dobFfp3OU+3Dz8XwAAAP//3sYjrvU4AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
