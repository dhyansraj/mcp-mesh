// ðŸ¤– AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	McpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	Available   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	Degraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	Unavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	Capabilities []CapabilityInfo `json:"capabilities"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int             `json:"dependencies_resolved"`
	Endpoint             string          `json:"endpoint"`
	Id                   string          `json:"id"`
	LastSeen             *time.Time      `json:"last_seen,omitempty"`
	Name                 string          `json:"name"`
	Status               AgentInfoStatus `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// MeshAgentRegistration Agent registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Based on @mesh.tool decorator processing - always has at least one tool.
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of agent (always mcp_agent for mesh tools)
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions)
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of agent (always mcp_agent for mesh tools)
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	// ðŸ¤– AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// Kwargs Additional kwargs from @mesh.tool decorator for enhanced client proxy configuration.
	// Supports timeout, retry_count, custom_headers, streaming, auth_required, etc.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Graceful agent unregistration
	// (DELETE /agents/{agent_id})
	UnregisterAgent(c *gin.Context, agentId string)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Registry health check (headers only)
	// (HEAD /health)
	HeadHealth(c *gin.Context)
	// Agent registration and heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
	// Fast agent health check
	// (HEAD /heartbeat/{agent_id})
	FastHeartbeatCheck(c *gin.Context, agentId string)
	// Stream trace events for a specific trace ID
	// (GET /traces/{trace_id}/stream)
	StreamTrace(c *gin.Context, traceId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// UnregisterAgent operation middleware
func (siw *ServerInterfaceWrapper) UnregisterAgent(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterAgent(c, agentId)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// HeadHealth operation middleware
func (siw *ServerInterfaceWrapper) HeadHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeadHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// FastHeartbeatCheck operation middleware
func (siw *ServerInterfaceWrapper) FastHeartbeatCheck(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FastHeartbeatCheck(c, agentId)
}

// StreamTrace operation middleware
func (siw *ServerInterfaceWrapper) StreamTrace(c *gin.Context) {

	var err error

	// ------------- Path parameter "trace_id" -------------
	var traceId string

	err = runtime.BindStyledParameterWithOptions("simple", "trace_id", c.Param("trace_id"), &traceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trace_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.StreamTrace(c, traceId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.DELETE(options.BaseURL+"/agents/:agent_id", wrapper.UnregisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.HEAD(options.BaseURL+"/health", wrapper.HeadHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
	router.HEAD(options.BaseURL+"/heartbeat/:agent_id", wrapper.FastHeartbeatCheck)
	router.GET(options.BaseURL+"/traces/:trace_id/stream", wrapper.StreamTrace)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
