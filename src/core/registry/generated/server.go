// ðŸ¤– AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	McpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	Available   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	Degraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	Unavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	Capabilities []CapabilityInfo `json:"capabilities"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int             `json:"dependencies_resolved"`
	Endpoint             string          `json:"endpoint"`
	Id                   string          `json:"id"`
	LastSeen             *time.Time      `json:"last_seen,omitempty"`
	Name                 string          `json:"name"`
	Status               AgentInfoStatus `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// MeshAgentRegistration Agent registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Based on @mesh.tool decorator processing - always has at least one tool.
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of agent (always mcp_agent for mesh tools)
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions)
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of agent (always mcp_agent for mesh tools)
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	// ðŸ¤– AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Graceful agent unregistration
	// (DELETE /agents/{agent_id})
	UnregisterAgent(c *gin.Context, agentId string)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Registry health check (headers only)
	// (HEAD /health)
	HeadHealth(c *gin.Context)
	// Agent registration and heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
	// Fast agent health check
	// (HEAD /heartbeat/{agent_id})
	FastHeartbeatCheck(c *gin.Context, agentId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// UnregisterAgent operation middleware
func (siw *ServerInterfaceWrapper) UnregisterAgent(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterAgent(c, agentId)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// HeadHealth operation middleware
func (siw *ServerInterfaceWrapper) HeadHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeadHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// FastHeartbeatCheck operation middleware
func (siw *ServerInterfaceWrapper) FastHeartbeatCheck(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FastHeartbeatCheck(c, agentId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.DELETE(options.BaseURL+"/agents/:agent_id", wrapper.UnregisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.HEAD(options.BaseURL+"/health", wrapper.HeadHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
	router.HEAD(options.BaseURL+"/heartbeat/:agent_id", wrapper.FastHeartbeatCheck)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"tlZpNwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
