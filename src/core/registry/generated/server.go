// ðŸ¤– AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AgentInfoAgentType.
const (
	AgentInfoAgentTypeApi      AgentInfoAgentType = "api"
	AgentInfoAgentTypeMcpAgent AgentInfoAgentType = "mcp_agent"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	MeshAgentRegistrationAgentTypeApi      MeshAgentRegistrationAgentType = "api"
	MeshAgentRegistrationAgentTypeMcpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	Available   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	Degraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	Unavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType    AgentInfoAgentType `json:"agent_type"`
	Capabilities []CapabilityInfo   `json:"capabilities"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int             `json:"dependencies_resolved"`
	Endpoint             string          `json:"endpoint"`
	Id                   string          `json:"id"`
	LastSeen             *time.Time      `json:"last_seen,omitempty"`
	Name                 string          `json:"name"`
	Status               AgentInfoStatus `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoAgentType Type of service - mcp_agent provides capabilities, api consumes them
type AgentInfoAgentType string

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// LLMToolInfo Complete tool information for LLM consumption.
// Includes everything an LLM needs to understand and call the tool via MCP protocol.
type LLMToolInfo struct {
	// Capability Capability name this tool provides
	Capability string `json:"capability"`

	// Description Human-readable tool description for LLM context
	Description string `json:"description"`

	// Endpoint Agent endpoint for MCP protocol calls
	Endpoint string `json:"endpoint"`

	// InputSchema JSON Schema for tool parameters (MCP format).
	// LLM uses this to understand required and optional parameters.
	InputSchema map[string]interface{} `json:"inputSchema"`

	// Kwargs Proxy configuration for tool execution (timeout, retry, streaming, etc.).
	// Passed to UnifiedMCPProxy for enhanced client behavior.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Name Function name (MCP protocol level)
	Name string `json:"name"`

	// Tags Capability tags
	Tags *[]string `json:"tags,omitempty"`

	// Version Tool version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistration Service registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Supports both agents (agent_type=mcp_agent) and API services (agent_type=api).
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions).
	// Tools can optionally include llm_filter if decorated with @mesh.llm.
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of service - mcp_agent provides capabilities, api consumes them
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	// ðŸ¤– AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`

	// LlmTools Map of function_name to filtered tool list for LLM agents.
	// Enables LLM agents to receive auto-filtered, up-to-date tool lists based on llm_filter in tool registration.
	// ðŸ¤– AI NOTE: This is populated only when tool includes llm_filter.
	// Registry applies filtering logic and returns matching tools with full schemas.
	LlmTools  *map[string][]LLMToolInfo      `json:"llm_tools,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// InputSchema JSON Schema for function parameters (MCP tool format).
	// Auto-generated from function signature by FastMCP.
	// Used by LLM agents to understand how to call this tool.
	InputSchema *map[string]interface{} `json:"inputSchema,omitempty"`

	// Kwargs Additional kwargs from @mesh.tool decorator for enhanced client proxy configuration.
	// Supports timeout, retry_count, custom_headers, streaming, auth_required, etc.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// LlmFilter Optional LLM tool filter specification when function is decorated with @mesh.llm.
	// Defines which tools this LLM agent needs access to.
	// Stored as JSON, follows LLMToolFilter schema structure.
	LlmFilter *map[string]interface{} `json:"llm_filter,omitempty"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Graceful agent unregistration
	// (DELETE /agents/{agent_id})
	UnregisterAgent(c *gin.Context, agentId string)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Registry health check (headers only)
	// (HEAD /health)
	HeadHealth(c *gin.Context)
	// Agent registration and heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
	// Fast agent health check
	// (HEAD /heartbeat/{agent_id})
	FastHeartbeatCheck(c *gin.Context, agentId string)
	// Stream trace events for a specific trace ID
	// (GET /traces/{trace_id}/stream)
	StreamTrace(c *gin.Context, traceId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// UnregisterAgent operation middleware
func (siw *ServerInterfaceWrapper) UnregisterAgent(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterAgent(c, agentId)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// HeadHealth operation middleware
func (siw *ServerInterfaceWrapper) HeadHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeadHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// FastHeartbeatCheck operation middleware
func (siw *ServerInterfaceWrapper) FastHeartbeatCheck(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FastHeartbeatCheck(c, agentId)
}

// StreamTrace operation middleware
func (siw *ServerInterfaceWrapper) StreamTrace(c *gin.Context) {

	var err error

	// ------------- Path parameter "trace_id" -------------
	var traceId string

	err = runtime.BindStyledParameterWithOptions("simple", "trace_id", c.Param("trace_id"), &traceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trace_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.StreamTrace(c, traceId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.DELETE(options.BaseURL+"/agents/:agent_id", wrapper.UnregisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.HEAD(options.BaseURL+"/health", wrapper.HeadHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
	router.HEAD(options.BaseURL+"/heartbeat/:agent_id", wrapper.FastHeartbeatCheck)
	router.GET(options.BaseURL+"/traces/:trace_id/stream", wrapper.StreamTrace)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"tfXdajsU08F+Y1U39/8XAAD//5uTFT+RTgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
