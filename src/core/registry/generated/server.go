//  AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AgentInfoAgentType.
const (
	AgentInfoAgentTypeApi      AgentInfoAgentType = "api"
	AgentInfoAgentTypeMcpAgent AgentInfoAgentType = "mcp_agent"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for DependencyResolutionInfoStatus.
const (
	DependencyResolutionInfoStatusAvailable   DependencyResolutionInfoStatus = "available"
	DependencyResolutionInfoStatusUnavailable DependencyResolutionInfoStatus = "unavailable"
	DependencyResolutionInfoStatusUnresolved  DependencyResolutionInfoStatus = "unresolved"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for LLMProviderResolutionInfoStatus.
const (
	LLMProviderResolutionInfoStatusAvailable   LLMProviderResolutionInfoStatus = "available"
	LLMProviderResolutionInfoStatusUnavailable LLMProviderResolutionInfoStatus = "unavailable"
	LLMProviderResolutionInfoStatusUnresolved  LLMProviderResolutionInfoStatus = "unresolved"
)

// Defines values for LLMToolFilterFilterMode.
const (
	LLMToolFilterFilterModeAll       LLMToolFilterFilterMode = "all"
	LLMToolFilterFilterModeAsterisk  LLMToolFilterFilterMode = "*"
	LLMToolFilterFilterModeBestMatch LLMToolFilterFilterMode = "best_match"
)

// Defines values for LLMToolResolutionInfoFilterMode.
const (
	LLMToolResolutionInfoFilterModeAll       LLMToolResolutionInfoFilterMode = "all"
	LLMToolResolutionInfoFilterModeAsterisk  LLMToolResolutionInfoFilterMode = "*"
	LLMToolResolutionInfoFilterModeBestMatch LLMToolResolutionInfoFilterMode = "best_match"
)

// Defines values for LLMToolResolutionInfoStatus.
const (
	LLMToolResolutionInfoStatusAvailable   LLMToolResolutionInfoStatus = "available"
	LLMToolResolutionInfoStatusUnavailable LLMToolResolutionInfoStatus = "unavailable"
	LLMToolResolutionInfoStatusUnresolved  LLMToolResolutionInfoStatus = "unresolved"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	MeshAgentRegistrationAgentTypeApi      MeshAgentRegistrationAgentType = "api"
	MeshAgentRegistrationAgentTypeMcpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	MeshRegistrationResponseDependenciesResolvedStatusAvailable   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	MeshRegistrationResponseDependenciesResolvedStatusDegraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	MeshRegistrationResponseDependenciesResolvedStatusUnavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// Defines values for ResolvedLLMProviderStatus.
const (
	Available   ResolvedLLMProviderStatus = "available"
	Degraded    ResolvedLLMProviderStatus = "degraded"
	Unavailable ResolvedLLMProviderStatus = "unavailable"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType    AgentInfoAgentType `json:"agent_type"`
	Capabilities []CapabilityInfo   `json:"capabilities"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int `json:"dependencies_resolved"`

	// DependencyResolutions List of all dependency resolutions (both resolved and unresolved)
	DependencyResolutions *[]DependencyResolutionInfo `json:"dependency_resolutions,omitempty"`
	Endpoint              string                      `json:"endpoint"`
	Id                    string                      `json:"id"`
	LastSeen              *time.Time                  `json:"last_seen,omitempty"`

	// LlmProviderResolutions List of all LLM provider resolutions for @mesh.llm provider
	LlmProviderResolutions *[]LLMProviderResolutionInfo `json:"llm_provider_resolutions,omitempty"`

	// LlmToolResolutions List of all LLM tool resolutions for @mesh.llm filter
	LlmToolResolutions *[]LLMToolResolutionInfo `json:"llm_tool_resolutions,omitempty"`
	Name               string                   `json:"name"`
	Status             AgentInfoStatus          `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoAgentType Type of service - mcp_agent provides capabilities, api consumes them
type AgentInfoAgentType string

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// LlmFilter Tool filter specification for an @mesh.llm decorated function.
	// Embedded within MeshToolRegistration - function_name is implicit from parent tool.
	// Registry matches tools based on filter criteria and returns filtered list in llm_tools response.
	LlmFilter *LLMToolFilter `json:"llm_filter,omitempty"`

	// LlmProvider LLM provider specification for mesh delegation mode.
	// When @mesh.llm uses provider=dict, the registry resolves a matching LLM provider
	// agent and returns its endpoint in llm_providers response field.
	//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
	LlmProvider *LLMProvider `json:"llm_provider,omitempty"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// DependencyResolutionInfo defines model for DependencyResolutionInfo.
type DependencyResolutionInfo struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Endpoint Provider endpoint (NULL if unresolved)
	Endpoint *string `json:"endpoint,omitempty"`

	// FunctionName Function requiring this dependency
	FunctionName string `json:"function_name"`

	// McpTool MCP tool name on provider (NULL if unresolved)
	McpTool *string `json:"mcp_tool,omitempty"`

	// ProviderAgentId Provider agent ID (NULL if unresolved)
	ProviderAgentId *string `json:"provider_agent_id,omitempty"`

	// Status Dependency resolution status
	Status DependencyResolutionInfoStatus `json:"status"`

	// Tags Required tags for matching
	Tags *[]string `json:"tags,omitempty"`
}

// DependencyResolutionInfoStatus Dependency resolution status
type DependencyResolutionInfoStatus string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// LLMProvider LLM provider specification for mesh delegation mode.
// When @mesh.llm uses provider=dict, the registry resolves a matching LLM provider
// agent and returns its endpoint in llm_providers response field.
//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
type LLMProvider struct {
	// Capability Required capability name (typically "llm")
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching with operators:
	// - "tag" = required
	// - "+tag" = preferred
	// - "-tag" = excluded
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint (semver format)
	Version *string `json:"version,omitempty"`
}

// LLMProviderResolutionInfo Resolution info for LLM provider (@mesh.llm provider).
// Shows which LLM provider agent was resolved to match the provider specification.
type LLMProviderResolutionInfo struct {
	// Endpoint Provider endpoint (NULL if unresolved)
	Endpoint *string `json:"endpoint,omitempty"`

	// FunctionName Function with @mesh.llm decorator
	FunctionName string `json:"function_name"`

	// McpTool MCP tool name on provider (NULL if unresolved)
	McpTool *string `json:"mcp_tool,omitempty"`

	// ProviderAgentId Provider agent ID (NULL if unresolved)
	ProviderAgentId *string `json:"provider_agent_id,omitempty"`

	// RequiredCapability Required capability (typically 'llm')
	RequiredCapability string `json:"required_capability"`

	// RequiredTags Required tags for matching
	RequiredTags *[]string `json:"required_tags,omitempty"`

	// Status Provider resolution status
	Status LLMProviderResolutionInfoStatus `json:"status"`
}

// LLMProviderResolutionInfoStatus Provider resolution status
type LLMProviderResolutionInfoStatus string

// LLMToolFilter Tool filter specification for an @mesh.llm decorated function.
// Embedded within MeshToolRegistration - function_name is implicit from parent tool.
// Registry matches tools based on filter criteria and returns filtered list in llm_tools response.
type LLMToolFilter struct {
	// Filter List of capability filters. Can be simple strings (capability names)
	// or rich objects with tags and version constraints.
	Filter []LLMToolFilter_Filter_Item `json:"filter"`

	// FilterMode Filter mode for tool matching:
	// - "all": Include all tools matching any filter criteria
	// - "best_match": One tool per capability (best tag match)
	// - "*": All available tools in mesh (ignores filter)
	FilterMode *LLMToolFilterFilterMode `json:"filter_mode,omitempty"`

	// InjectParam Parameter name to inject tools into (for Python runtime)
	InjectParam *string `json:"inject_param,omitempty"`
}

// LLMToolFilterFilter0 Simple capability name filter
type LLMToolFilterFilter0 = string

// LLMToolFilterFilter1 Rich filter with capability, tags, and version
type LLMToolFilterFilter1 struct {
	// Capability Capability name to match
	Capability string `json:"capability"`

	// Tags Tags for tag-based filtering (subset matching)
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// LLMToolFilter_Filter_Item defines model for LLMToolFilter.filter.Item.
type LLMToolFilter_Filter_Item struct {
	union json.RawMessage
}

// LLMToolFilterFilterMode Filter mode for tool matching:
// - "all": Include all tools matching any filter criteria
// - "best_match": One tool per capability (best tag match)
// - "*": All available tools in mesh (ignores filter)
type LLMToolFilterFilterMode string

// LLMToolInfo Complete tool information for LLM consumption.
// Includes everything an LLM needs to understand and call the tool via MCP protocol.
type LLMToolInfo struct {
	// Capability Capability name this tool provides
	Capability string `json:"capability"`

	// Description Human-readable tool description for LLM context
	Description string `json:"description"`

	// Endpoint Agent endpoint for MCP protocol calls
	Endpoint string `json:"endpoint"`

	// InputSchema JSON Schema for tool parameters (MCP format).
	// LLM uses this to understand required and optional parameters.
	InputSchema map[string]interface{} `json:"inputSchema"`

	// Kwargs Proxy configuration for tool execution (timeout, retry, streaming, etc.).
	// Passed to UnifiedMCPProxy for enhanced client behavior.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Name Function name (MCP protocol level)
	Name string `json:"name"`

	// Tags Capability tags
	Tags *[]string `json:"tags,omitempty"`

	// Version Tool version
	Version *string `json:"version,omitempty"`
}

// LLMToolResolutionInfo Resolution info for LLM tool filters (@mesh.llm filter).
// Shows which tools were resolved to match the filter specification.
type LLMToolResolutionInfo struct {
	// Endpoint Provider endpoint (NULL if unresolved)
	Endpoint *string `json:"endpoint,omitempty"`

	// FilterCapability Capability specified in the filter
	FilterCapability *string `json:"filter_capability,omitempty"`

	// FilterMode Filter mode used
	FilterMode *LLMToolResolutionInfoFilterMode `json:"filter_mode,omitempty"`

	// FilterTags Tags specified in the filter
	FilterTags *[]string `json:"filter_tags,omitempty"`

	// FunctionName Function with @mesh.llm decorator
	FunctionName string `json:"function_name"`

	// McpTool MCP tool name on provider (NULL if unresolved)
	McpTool *string `json:"mcp_tool,omitempty"`

	// ProviderAgentId Provider agent ID (NULL if unresolved)
	ProviderAgentId *string `json:"provider_agent_id,omitempty"`

	// ProviderCapability Capability of the resolved tool
	ProviderCapability *string `json:"provider_capability,omitempty"`

	// Status Tool resolution status
	Status LLMToolResolutionInfoStatus `json:"status"`
}

// LLMToolResolutionInfoFilterMode Filter mode used
type LLMToolResolutionInfoFilterMode string

// LLMToolResolutionInfoStatus Tool resolution status
type LLMToolResolutionInfoStatus string

// MeshAgentRegistration Service registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Supports both agents (agent_type=mcp_agent) and API services (agent_type=api).
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions).
	// Tools can optionally include llm_filter if decorated with @mesh.llm.
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of service - mcp_agent provides capabilities, api consumes them
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	//  AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`

	// LlmProviders Map of function_name to resolved LLM provider for mesh delegation.
	// Populated only when tool includes llm_provider specification.
	// Registry resolves matching LLM provider agent based on capability/tags/version.
	//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
	LlmProviders *map[string]ResolvedLLMProvider `json:"llm_providers,omitempty"`

	// LlmTools Map of function_name to filtered tool list for LLM agents.
	// Enables LLM agents to receive auto-filtered, up-to-date tool lists based on llm_filter in tool registration.
	//  AI NOTE: This is populated only when tool includes llm_filter.
	// Registry applies filtering logic and returns matching tools with full schemas.
	LlmTools  *map[string][]LLMToolInfo      `json:"llm_tools,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// InputSchema JSON Schema for function parameters (MCP tool format).
	// Auto-generated from function signature by FastMCP.
	// Used by LLM agents to understand how to call this tool.
	InputSchema *map[string]interface{} `json:"inputSchema,omitempty"`

	// Kwargs Additional kwargs from @mesh.tool decorator for enhanced client proxy configuration.
	// Supports timeout, retry_count, custom_headers, streaming, auth_required, etc.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// LlmFilter Optional LLM tool filter specification when function is decorated with @mesh.llm.
	// Defines which tools this LLM agent needs access to.
	// Stored as JSON, follows LLMToolFilter schema structure.
	LlmFilter *map[string]interface{} `json:"llm_filter,omitempty"`

	// LlmProvider LLM provider specification for mesh delegation mode.
	// When @mesh.llm uses provider=dict, the registry resolves a matching LLM provider
	// agent and returns its endpoint in llm_providers response field.
	//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
	LlmProvider *LLMProvider `json:"llm_provider,omitempty"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// ResolvedLLMProvider Resolved LLM provider information for mesh delegation.
// Contains all necessary data to create a proxy and delegate LLM calls to this provider.
//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
type ResolvedLLMProvider struct {
	// AgentId ID of the provider agent
	AgentId string `json:"agent_id"`

	// Capability Capability name (typically "llm")
	Capability string `json:"capability"`

	// Endpoint Provider agent endpoint for MCP protocol calls
	Endpoint string `json:"endpoint"`

	// Kwargs Optional proxy configuration (timeout, retry, etc.).
	// Passed to UnifiedMCPProxy for enhanced client behavior.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Name Function name of the LLM provider tool
	Name string `json:"name"`

	// Status Current status of the provider
	Status ResolvedLLMProviderStatus `json:"status"`

	// Tags Provider capability tags
	Tags *[]string `json:"tags,omitempty"`

	// Vendor LLM vendor/provider name extracted from model string.
	// Used by consumer to select appropriate ProviderHandler for optimal LLM interaction.
	// Automatically extracted using LiteLLM's get_llm_provider() function during provider registration.
	// Common values: "anthropic", "openai", "google", "cohere", "ollama", "together", etc.
	Vendor string `json:"vendor"`

	// Version Provider version
	Version *string `json:"version,omitempty"`
}

// ResolvedLLMProviderStatus Current status of the provider
type ResolvedLLMProviderStatus string

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// AsLLMToolFilterFilter0 returns the union data inside the LLMToolFilter_Filter_Item as a LLMToolFilterFilter0
func (t LLMToolFilter_Filter_Item) AsLLMToolFilterFilter0() (LLMToolFilterFilter0, error) {
	var body LLMToolFilterFilter0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLLMToolFilterFilter0 overwrites any union data inside the LLMToolFilter_Filter_Item as the provided LLMToolFilterFilter0
func (t *LLMToolFilter_Filter_Item) FromLLMToolFilterFilter0(v LLMToolFilterFilter0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLLMToolFilterFilter0 performs a merge with any union data inside the LLMToolFilter_Filter_Item, using the provided LLMToolFilterFilter0
func (t *LLMToolFilter_Filter_Item) MergeLLMToolFilterFilter0(v LLMToolFilterFilter0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLLMToolFilterFilter1 returns the union data inside the LLMToolFilter_Filter_Item as a LLMToolFilterFilter1
func (t LLMToolFilter_Filter_Item) AsLLMToolFilterFilter1() (LLMToolFilterFilter1, error) {
	var body LLMToolFilterFilter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLLMToolFilterFilter1 overwrites any union data inside the LLMToolFilter_Filter_Item as the provided LLMToolFilterFilter1
func (t *LLMToolFilter_Filter_Item) FromLLMToolFilterFilter1(v LLMToolFilterFilter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLLMToolFilterFilter1 performs a merge with any union data inside the LLMToolFilter_Filter_Item, using the provided LLMToolFilterFilter1
func (t *LLMToolFilter_Filter_Item) MergeLLMToolFilterFilter1(v LLMToolFilterFilter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LLMToolFilter_Filter_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LLMToolFilter_Filter_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Graceful agent unregistration
	// (DELETE /agents/{agent_id})
	UnregisterAgent(c *gin.Context, agentId string)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Registry health check (headers only)
	// (HEAD /health)
	HeadHealth(c *gin.Context)
	// Agent registration and heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
	// Fast agent health check
	// (HEAD /heartbeat/{agent_id})
	FastHeartbeatCheck(c *gin.Context, agentId string)
	// Stream trace events for a specific trace ID
	// (GET /traces/{trace_id}/stream)
	StreamTrace(c *gin.Context, traceId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// UnregisterAgent operation middleware
func (siw *ServerInterfaceWrapper) UnregisterAgent(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterAgent(c, agentId)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// HeadHealth operation middleware
func (siw *ServerInterfaceWrapper) HeadHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeadHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// FastHeartbeatCheck operation middleware
func (siw *ServerInterfaceWrapper) FastHeartbeatCheck(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FastHeartbeatCheck(c, agentId)
}

// StreamTrace operation middleware
func (siw *ServerInterfaceWrapper) StreamTrace(c *gin.Context) {

	var err error

	// ------------- Path parameter "trace_id" -------------
	var traceId string

	err = runtime.BindStyledParameterWithOptions("simple", "trace_id", c.Param("trace_id"), &traceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trace_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.StreamTrace(c, traceId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.DELETE(options.BaseURL+"/agents/:agent_id", wrapper.UnregisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.HEAD(options.BaseURL+"/health", wrapper.HeadHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
	router.HEAD(options.BaseURL+"/heartbeat/:agent_id", wrapper.FastHeartbeatCheck)
	router.GET(options.BaseURL+"/traces/:trace_id/stream", wrapper.StreamTrace)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"w/5jiId1AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
