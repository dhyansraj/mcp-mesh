//  AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in ent_handlers.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AgentInfoAgentType.
const (
	AgentInfoAgentTypeApi      AgentInfoAgentType = "api"
	AgentInfoAgentTypeMcpAgent AgentInfoAgentType = "mcp_agent"
)

// Defines values for AgentInfoRuntime.
const (
	AgentInfoRuntimeJava       AgentInfoRuntime = "java"
	AgentInfoRuntimePython     AgentInfoRuntime = "python"
	AgentInfoRuntimeTypescript AgentInfoRuntime = "typescript"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for DependencyResolutionInfoStatus.
const (
	DependencyResolutionInfoStatusAvailable   DependencyResolutionInfoStatus = "available"
	DependencyResolutionInfoStatusUnavailable DependencyResolutionInfoStatus = "unavailable"
	DependencyResolutionInfoStatusUnresolved  DependencyResolutionInfoStatus = "unresolved"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for LLMProviderResolutionInfoStatus.
const (
	LLMProviderResolutionInfoStatusAvailable   LLMProviderResolutionInfoStatus = "available"
	LLMProviderResolutionInfoStatusUnavailable LLMProviderResolutionInfoStatus = "unavailable"
	LLMProviderResolutionInfoStatusUnresolved  LLMProviderResolutionInfoStatus = "unresolved"
)

// Defines values for LLMToolFilterFilterMode.
const (
	LLMToolFilterFilterModeAll       LLMToolFilterFilterMode = "all"
	LLMToolFilterFilterModeAsterisk  LLMToolFilterFilterMode = "*"
	LLMToolFilterFilterModeBestMatch LLMToolFilterFilterMode = "best_match"
)

// Defines values for LLMToolResolutionInfoFilterMode.
const (
	LLMToolResolutionInfoFilterModeAll       LLMToolResolutionInfoFilterMode = "all"
	LLMToolResolutionInfoFilterModeAsterisk  LLMToolResolutionInfoFilterMode = "*"
	LLMToolResolutionInfoFilterModeBestMatch LLMToolResolutionInfoFilterMode = "best_match"
)

// Defines values for LLMToolResolutionInfoStatus.
const (
	LLMToolResolutionInfoStatusAvailable   LLMToolResolutionInfoStatus = "available"
	LLMToolResolutionInfoStatusUnavailable LLMToolResolutionInfoStatus = "unavailable"
	LLMToolResolutionInfoStatusUnresolved  LLMToolResolutionInfoStatus = "unresolved"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	MeshAgentRegistrationAgentTypeApi      MeshAgentRegistrationAgentType = "api"
	MeshAgentRegistrationAgentTypeMcpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshAgentRegistrationRuntime.
const (
	MeshAgentRegistrationRuntimeJava       MeshAgentRegistrationRuntime = "java"
	MeshAgentRegistrationRuntimePython     MeshAgentRegistrationRuntime = "python"
	MeshAgentRegistrationRuntimeTypescript MeshAgentRegistrationRuntime = "typescript"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	MeshRegistrationResponseDependenciesResolvedStatusAvailable   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	MeshRegistrationResponseDependenciesResolvedStatusDegraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	MeshRegistrationResponseDependenciesResolvedStatusUnavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// Defines values for ResolvedLLMProviderStatus.
const (
	Available   ResolvedLLMProviderStatus = "available"
	Degraded    ResolvedLLMProviderStatus = "degraded"
	Unavailable ResolvedLLMProviderStatus = "unavailable"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType    AgentInfoAgentType `json:"agent_type"`
	Capabilities []CapabilityInfo   `json:"capabilities"`

	// CreatedAt When agent was first registered
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int `json:"dependencies_resolved"`

	// DependencyResolutions List of all dependency resolutions (both resolved and unresolved)
	DependencyResolutions *[]DependencyResolutionInfo `json:"dependency_resolutions,omitempty"`
	Endpoint              string                      `json:"endpoint"`
	Id                    string                      `json:"id"`

	// LastSeen Last heartbeat timestamp
	LastSeen *time.Time `json:"last_seen,omitempty"`

	// LlmProviderResolutions List of all LLM provider resolutions for @mesh.llm provider
	LlmProviderResolutions *[]LLMProviderResolutionInfo `json:"llm_provider_resolutions,omitempty"`

	// LlmToolResolutions List of all LLM tool resolutions for @mesh.llm filter
	LlmToolResolutions *[]LLMToolResolutionInfo `json:"llm_tool_resolutions,omitempty"`
	Name               string                   `json:"name"`

	// Runtime SDK runtime language (python, typescript, or java)
	Runtime *AgentInfoRuntime `json:"runtime,omitempty"`
	Status  AgentInfoStatus   `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoAgentType Type of service - mcp_agent provides capabilities, api consumes them
type AgentInfoAgentType string

// AgentInfoRuntime SDK runtime language (python, typescript, or java)
type AgentInfoRuntime string

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// LlmFilter Tool filter specification for an @mesh.llm decorated function.
	// Embedded within MeshToolRegistration - function_name is implicit from parent tool.
	// Registry matches tools based on filter criteria and returns filtered list in llm_tools response.
	LlmFilter *LLMToolFilter `json:"llm_filter,omitempty"`

	// LlmProvider LLM provider specification for mesh delegation mode.
	// When @mesh.llm uses provider=dict, the registry resolves a matching LLM provider
	// agent and returns its endpoint in llm_providers response field.
	//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
	LlmProvider *LLMProvider `json:"llm_provider,omitempty"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// DependencyResolutionInfo defines model for DependencyResolutionInfo.
type DependencyResolutionInfo struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Endpoint Provider endpoint (NULL if unresolved)
	Endpoint *string `json:"endpoint,omitempty"`

	// FunctionName Function requiring this dependency
	FunctionName string `json:"function_name"`

	// McpTool MCP tool name on provider (NULL if unresolved)
	McpTool *string `json:"mcp_tool,omitempty"`

	// ProviderAgentId Provider agent ID (NULL if unresolved)
	ProviderAgentId *string `json:"provider_agent_id,omitempty"`

	// Status Dependency resolution status
	Status DependencyResolutionInfoStatus `json:"status"`

	// Tags Required tags for matching
	Tags *[]string `json:"tags,omitempty"`
}

// DependencyResolutionInfoStatus Dependency resolution status
type DependencyResolutionInfoStatus string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// LLMProvider LLM provider specification for mesh delegation mode.
// When @mesh.llm uses provider=dict, the registry resolves a matching LLM provider
// agent and returns its endpoint in llm_providers response field.
//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
type LLMProvider struct {
	// Capability Required capability name (typically "llm")
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching with operators:
	// - "tag" = required
	// - "+tag" = preferred
	// - "-tag" = excluded
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint (semver format)
	Version *string `json:"version,omitempty"`
}

// LLMProviderResolutionInfo Resolution info for LLM provider (@mesh.llm provider).
// Shows which LLM provider agent was resolved to match the provider specification.
type LLMProviderResolutionInfo struct {
	// Endpoint Provider endpoint (NULL if unresolved)
	Endpoint *string `json:"endpoint,omitempty"`

	// FunctionName Function with @mesh.llm decorator
	FunctionName string `json:"function_name"`

	// McpTool MCP tool name on provider (NULL if unresolved)
	McpTool *string `json:"mcp_tool,omitempty"`

	// ProviderAgentId Provider agent ID (NULL if unresolved)
	ProviderAgentId *string `json:"provider_agent_id,omitempty"`

	// RequiredCapability Required capability (typically 'llm')
	RequiredCapability string `json:"required_capability"`

	// RequiredTags Required tags for matching
	RequiredTags *[]string `json:"required_tags,omitempty"`

	// Status Provider resolution status
	Status LLMProviderResolutionInfoStatus `json:"status"`
}

// LLMProviderResolutionInfoStatus Provider resolution status
type LLMProviderResolutionInfoStatus string

// LLMToolFilter Tool filter specification for an @mesh.llm decorated function.
// Embedded within MeshToolRegistration - function_name is implicit from parent tool.
// Registry matches tools based on filter criteria and returns filtered list in llm_tools response.
type LLMToolFilter struct {
	// Filter List of capability filters. Can be simple strings (capability names)
	// or rich objects with tags and version constraints.
	Filter []LLMToolFilter_Filter_Item `json:"filter"`

	// FilterMode Filter mode for tool matching:
	// - "all": Include all tools matching any filter criteria
	// - "best_match": One tool per capability (best tag match)
	// - "*": All available tools in mesh (ignores filter)
	FilterMode *LLMToolFilterFilterMode `json:"filter_mode,omitempty"`

	// InjectParam Parameter name to inject tools into (for Python runtime)
	InjectParam *string `json:"inject_param,omitempty"`
}

// LLMToolFilterFilter0 Simple capability name filter
type LLMToolFilterFilter0 = string

// LLMToolFilterFilter1 Rich filter with capability, tags, and version
type LLMToolFilterFilter1 struct {
	// Capability Capability name to match
	Capability string `json:"capability"`

	// Tags Tags for tag-based filtering (subset matching)
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// LLMToolFilter_Filter_Item defines model for LLMToolFilter.filter.Item.
type LLMToolFilter_Filter_Item struct {
	union json.RawMessage
}

// LLMToolFilterFilterMode Filter mode for tool matching:
// - "all": Include all tools matching any filter criteria
// - "best_match": One tool per capability (best tag match)
// - "*": All available tools in mesh (ignores filter)
type LLMToolFilterFilterMode string

// LLMToolInfo Complete tool information for LLM consumption.
// Includes everything an LLM needs to understand and call the tool via MCP protocol.
type LLMToolInfo struct {
	// Capability Capability name this tool provides
	Capability string `json:"capability"`

	// Description Human-readable tool description for LLM context
	Description string `json:"description"`

	// Endpoint Agent endpoint for MCP protocol calls
	Endpoint string `json:"endpoint"`

	// InputSchema JSON Schema for tool parameters (MCP format).
	// LLM uses this to understand required and optional parameters.
	InputSchema map[string]interface{} `json:"inputSchema"`

	// Kwargs Proxy configuration for tool execution (timeout, retry, streaming, etc.).
	// Passed to UnifiedMCPProxy for enhanced client behavior.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Name Function name (MCP protocol level)
	Name string `json:"name"`

	// Tags Capability tags
	Tags *[]string `json:"tags,omitempty"`

	// Version Tool version
	Version *string `json:"version,omitempty"`
}

// LLMToolResolutionInfo Resolution info for LLM tool filters (@mesh.llm filter).
// Shows which tools were resolved to match the filter specification.
type LLMToolResolutionInfo struct {
	// Endpoint Provider endpoint (NULL if unresolved)
	Endpoint *string `json:"endpoint,omitempty"`

	// FilterCapability Capability specified in the filter
	FilterCapability *string `json:"filter_capability,omitempty"`

	// FilterMode Filter mode used
	FilterMode *LLMToolResolutionInfoFilterMode `json:"filter_mode,omitempty"`

	// FilterTags Tags specified in the filter
	FilterTags *[]string `json:"filter_tags,omitempty"`

	// FunctionName Function with @mesh.llm decorator
	FunctionName string `json:"function_name"`

	// McpTool MCP tool name on provider (NULL if unresolved)
	McpTool *string `json:"mcp_tool,omitempty"`

	// ProviderAgentId Provider agent ID (NULL if unresolved)
	ProviderAgentId *string `json:"provider_agent_id,omitempty"`

	// ProviderCapability Capability of the resolved tool
	ProviderCapability *string `json:"provider_capability,omitempty"`

	// Status Tool resolution status
	Status LLMToolResolutionInfoStatus `json:"status"`
}

// LLMToolResolutionInfoFilterMode Filter mode used
type LLMToolResolutionInfoFilterMode string

// LLMToolResolutionInfoStatus Tool resolution status
type LLMToolResolutionInfoStatus string

// MeshAgentRegistration Service registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Supports both agents (agent_type=mcp_agent) and API services (agent_type=api).
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Runtime SDK runtime language (python, typescript, or java)
	Runtime *MeshAgentRegistrationRuntime `json:"runtime,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions).
	// Tools can optionally include llm_filter if decorated with @mesh.llm.
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of service - mcp_agent provides capabilities, api consumes them
type MeshAgentRegistrationAgentType string

// MeshAgentRegistrationRuntime SDK runtime language (python, typescript, or java)
type MeshAgentRegistrationRuntime string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	//  AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`

	// LlmProviders Map of function_name to resolved LLM provider for mesh delegation.
	// Populated only when tool includes llm_provider specification.
	// Registry resolves matching LLM provider agent based on capability/tags/version.
	//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
	LlmProviders *map[string]ResolvedLLMProvider `json:"llm_providers,omitempty"`

	// LlmTools Map of function_name to filtered tool list for LLM agents.
	// Enables LLM agents to receive auto-filtered, up-to-date tool lists based on llm_filter in tool registration.
	//  AI NOTE: This is populated only when tool includes llm_filter.
	// Registry applies filtering logic and returns matching tools with full schemas.
	LlmTools  *map[string][]LLMToolInfo      `json:"llm_tools,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function.
//
// Tags support OR alternatives via nested arrays:
// - ["addition", ["python", "typescript"]] means: addition AND (python OR typescript)
// - ["fast"] means: just require "fast" tag
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching. Supports OR alternatives via nested arrays.
	// Example: ["addition", ["python", "typescript"]] = addition AND (python OR typescript)
	Tags *[]MeshToolDependencyRegistration_Tags_Item `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolDependencyRegistrationTags0 defines model for .
type MeshToolDependencyRegistrationTags0 = string

// MeshToolDependencyRegistrationTags1 defines model for .
type MeshToolDependencyRegistrationTags1 = []string

// MeshToolDependencyRegistration_Tags_Item defines model for MeshToolDependencyRegistration.tags.Item.
type MeshToolDependencyRegistration_Tags_Item struct {
	union json.RawMessage
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// InputSchema JSON Schema for function parameters (MCP tool format).
	// Auto-generated from function signature by FastMCP.
	// Used by LLM agents to understand how to call this tool.
	InputSchema *map[string]interface{} `json:"inputSchema,omitempty"`

	// Kwargs Additional kwargs from @mesh.tool decorator for enhanced client proxy configuration.
	// Supports timeout, retry_count, custom_headers, streaming, auth_required, etc.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// LlmFilter Optional LLM tool filter specification when function is decorated with @mesh.llm.
	// Defines which tools this LLM agent needs access to.
	// Stored as JSON, follows LLMToolFilter schema structure.
	LlmFilter *map[string]interface{} `json:"llm_filter,omitempty"`

	// LlmProvider LLM provider specification for mesh delegation mode.
	// When @mesh.llm uses provider=dict, the registry resolves a matching LLM provider
	// agent and returns its endpoint in llm_providers response field.
	//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
	LlmProvider *LLMProvider `json:"llm_provider,omitempty"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// ResolvedLLMProvider Resolved LLM provider information for mesh delegation.
// Contains all necessary data to create a proxy and delegate LLM calls to this provider.
//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
type ResolvedLLMProvider struct {
	// AgentId ID of the provider agent
	AgentId string `json:"agent_id"`

	// Capability Capability name (typically "llm")
	Capability string `json:"capability"`

	// Endpoint Provider agent endpoint for MCP protocol calls
	Endpoint string `json:"endpoint"`

	// Kwargs Optional proxy configuration (timeout, retry, etc.).
	// Passed to UnifiedMCPProxy for enhanced client behavior.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Name Function name of the LLM provider tool
	Name string `json:"name"`

	// Status Current status of the provider
	Status ResolvedLLMProviderStatus `json:"status"`

	// Tags Provider capability tags
	Tags *[]string `json:"tags,omitempty"`

	// Vendor LLM vendor/provider name extracted from model string.
	// Used by consumer to select appropriate ProviderHandler for optimal LLM interaction.
	// Automatically extracted using LiteLLM's get_llm_provider() function during provider registration.
	// Common values: "anthropic", "openai", "google", "cohere", "ollama", "together", etc.
	Vendor string `json:"vendor"`

	// Version Provider version
	Version *string `json:"version,omitempty"`
}

// ResolvedLLMProviderStatus Current status of the provider
type ResolvedLLMProviderStatus string

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// AsLLMToolFilterFilter0 returns the union data inside the LLMToolFilter_Filter_Item as a LLMToolFilterFilter0
func (t LLMToolFilter_Filter_Item) AsLLMToolFilterFilter0() (LLMToolFilterFilter0, error) {
	var body LLMToolFilterFilter0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLLMToolFilterFilter0 overwrites any union data inside the LLMToolFilter_Filter_Item as the provided LLMToolFilterFilter0
func (t *LLMToolFilter_Filter_Item) FromLLMToolFilterFilter0(v LLMToolFilterFilter0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLLMToolFilterFilter0 performs a merge with any union data inside the LLMToolFilter_Filter_Item, using the provided LLMToolFilterFilter0
func (t *LLMToolFilter_Filter_Item) MergeLLMToolFilterFilter0(v LLMToolFilterFilter0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLLMToolFilterFilter1 returns the union data inside the LLMToolFilter_Filter_Item as a LLMToolFilterFilter1
func (t LLMToolFilter_Filter_Item) AsLLMToolFilterFilter1() (LLMToolFilterFilter1, error) {
	var body LLMToolFilterFilter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLLMToolFilterFilter1 overwrites any union data inside the LLMToolFilter_Filter_Item as the provided LLMToolFilterFilter1
func (t *LLMToolFilter_Filter_Item) FromLLMToolFilterFilter1(v LLMToolFilterFilter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLLMToolFilterFilter1 performs a merge with any union data inside the LLMToolFilter_Filter_Item, using the provided LLMToolFilterFilter1
func (t *LLMToolFilter_Filter_Item) MergeLLMToolFilterFilter1(v LLMToolFilterFilter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LLMToolFilter_Filter_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LLMToolFilter_Filter_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMeshToolDependencyRegistrationTags0 returns the union data inside the MeshToolDependencyRegistration_Tags_Item as a MeshToolDependencyRegistrationTags0
func (t MeshToolDependencyRegistration_Tags_Item) AsMeshToolDependencyRegistrationTags0() (MeshToolDependencyRegistrationTags0, error) {
	var body MeshToolDependencyRegistrationTags0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeshToolDependencyRegistrationTags0 overwrites any union data inside the MeshToolDependencyRegistration_Tags_Item as the provided MeshToolDependencyRegistrationTags0
func (t *MeshToolDependencyRegistration_Tags_Item) FromMeshToolDependencyRegistrationTags0(v MeshToolDependencyRegistrationTags0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeshToolDependencyRegistrationTags0 performs a merge with any union data inside the MeshToolDependencyRegistration_Tags_Item, using the provided MeshToolDependencyRegistrationTags0
func (t *MeshToolDependencyRegistration_Tags_Item) MergeMeshToolDependencyRegistrationTags0(v MeshToolDependencyRegistrationTags0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMeshToolDependencyRegistrationTags1 returns the union data inside the MeshToolDependencyRegistration_Tags_Item as a MeshToolDependencyRegistrationTags1
func (t MeshToolDependencyRegistration_Tags_Item) AsMeshToolDependencyRegistrationTags1() (MeshToolDependencyRegistrationTags1, error) {
	var body MeshToolDependencyRegistrationTags1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeshToolDependencyRegistrationTags1 overwrites any union data inside the MeshToolDependencyRegistration_Tags_Item as the provided MeshToolDependencyRegistrationTags1
func (t *MeshToolDependencyRegistration_Tags_Item) FromMeshToolDependencyRegistrationTags1(v MeshToolDependencyRegistrationTags1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeshToolDependencyRegistrationTags1 performs a merge with any union data inside the MeshToolDependencyRegistration_Tags_Item, using the provided MeshToolDependencyRegistrationTags1
func (t *MeshToolDependencyRegistration_Tags_Item) MergeMeshToolDependencyRegistrationTags1(v MeshToolDependencyRegistrationTags1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MeshToolDependencyRegistration_Tags_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MeshToolDependencyRegistration_Tags_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Graceful agent unregistration
	// (DELETE /agents/{agent_id})
	UnregisterAgent(c *gin.Context, agentId string)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Registry health check (headers only)
	// (HEAD /health)
	HeadHealth(c *gin.Context)
	// Agent registration and heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
	// Fast agent health check
	// (HEAD /heartbeat/{agent_id})
	FastHeartbeatCheck(c *gin.Context, agentId string)
	// Stream trace events for a specific trace ID
	// (GET /traces/{trace_id}/stream)
	StreamTrace(c *gin.Context, traceId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// UnregisterAgent operation middleware
func (siw *ServerInterfaceWrapper) UnregisterAgent(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterAgent(c, agentId)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// HeadHealth operation middleware
func (siw *ServerInterfaceWrapper) HeadHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeadHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// FastHeartbeatCheck operation middleware
func (siw *ServerInterfaceWrapper) FastHeartbeatCheck(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FastHeartbeatCheck(c, agentId)
}

// StreamTrace operation middleware
func (siw *ServerInterfaceWrapper) StreamTrace(c *gin.Context) {

	var err error

	// ------------- Path parameter "trace_id" -------------
	var traceId string

	err = runtime.BindStyledParameterWithOptions("simple", "trace_id", c.Param("trace_id"), &traceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trace_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.StreamTrace(c, traceId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.DELETE(options.BaseURL+"/agents/:agent_id", wrapper.UnregisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.HEAD(options.BaseURL+"/health", wrapper.HeadHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
	router.HEAD(options.BaseURL+"/heartbeat/:agent_id", wrapper.FastHeartbeatCheck)
	router.GET(options.BaseURL+"/traces/:trace_id/stream", wrapper.StreamTrace)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
