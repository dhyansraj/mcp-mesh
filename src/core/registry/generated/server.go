// ðŸ¤– AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	McpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	Available   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	Degraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	Unavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	Capabilities []CapabilityInfo `json:"capabilities"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int             `json:"dependencies_resolved"`
	Endpoint             string          `json:"endpoint"`
	Id                   string          `json:"id"`
	LastSeen             *time.Time      `json:"last_seen,omitempty"`
	Name                 string          `json:"name"`
	Status               AgentInfoStatus `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// MeshAgentRegistration Agent registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Based on @mesh.tool decorator processing - always has at least one tool.
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of agent (always mcp_agent for mesh tools)
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions)
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of agent (always mcp_agent for mesh tools)
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	// ðŸ¤– AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// RegisterAgentJSONRequestBody defines body for RegisterAgent for application/json ContentType.
type RegisterAgentJSONRequestBody = MeshAgentRegistration

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Register agent with registry
	// (POST /agents/register)
	RegisterAgent(c *gin.Context)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Send agent heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// RegisterAgent operation middleware
func (siw *ServerInterfaceWrapper) RegisterAgent(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RegisterAgent(c)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.POST(options.BaseURL+"/agents/register", wrapper.RegisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
