// ðŸ¤– AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	McpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	Available   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	Degraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	Unavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	Capabilities []string        `json:"capabilities"`
	Endpoint     string          `json:"endpoint"`
	Id           string          `json:"id"`
	LastSeen     *time.Time      `json:"last_seen,omitempty"`
	Name         string          `json:"name"`
	Status       AgentInfoStatus `json:"status"`
	Version      *string         `json:"version,omitempty"`
}

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// MeshAgentRegistration Agent registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Based on @mesh.tool decorator processing - always has at least one tool.
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of agent (always mcp_agent for mesh tools)
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions)
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of agent (always mcp_agent for mesh tools)
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	// ðŸ¤– AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// RegisterAgentJSONRequestBody defines body for RegisterAgent for application/json ContentType.
type RegisterAgentJSONRequestBody = MeshAgentRegistration

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Register agent with registry
	// (POST /agents/register)
	RegisterAgent(c *gin.Context)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Send agent heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// RegisterAgent operation middleware
func (siw *ServerInterfaceWrapper) RegisterAgent(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RegisterAgent(c)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.POST(options.BaseURL+"/agents/register", wrapper.RegisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"C1wvAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
