// ðŸ¤– AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AgentInfoAgentType.
const (
	AgentInfoAgentTypeApi      AgentInfoAgentType = "api"
	AgentInfoAgentTypeMcpAgent AgentInfoAgentType = "mcp_agent"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for DependencyResolutionInfoStatus.
const (
	DependencyResolutionInfoStatusAvailable   DependencyResolutionInfoStatus = "available"
	DependencyResolutionInfoStatusUnavailable DependencyResolutionInfoStatus = "unavailable"
	DependencyResolutionInfoStatusUnresolved  DependencyResolutionInfoStatus = "unresolved"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	MeshAgentRegistrationAgentTypeApi      MeshAgentRegistrationAgentType = "api"
	MeshAgentRegistrationAgentTypeMcpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	MeshRegistrationResponseDependenciesResolvedStatusAvailable   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	MeshRegistrationResponseDependenciesResolvedStatusDegraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	MeshRegistrationResponseDependenciesResolvedStatusUnavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType    AgentInfoAgentType `json:"agent_type"`
	Capabilities []CapabilityInfo   `json:"capabilities"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int `json:"dependencies_resolved"`

	// DependencyResolutions List of all dependency resolutions (both resolved and unresolved)
	DependencyResolutions *[]DependencyResolutionInfo `json:"dependency_resolutions,omitempty"`
	Endpoint              string                      `json:"endpoint"`
	Id                    string                      `json:"id"`
	LastSeen              *time.Time                  `json:"last_seen,omitempty"`
	Name                  string                      `json:"name"`
	Status                AgentInfoStatus             `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoAgentType Type of service - mcp_agent provides capabilities, api consumes them
type AgentInfoAgentType string

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// DependencyResolutionInfo defines model for DependencyResolutionInfo.
type DependencyResolutionInfo struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Endpoint Provider endpoint (NULL if unresolved)
	Endpoint *string `json:"endpoint,omitempty"`

	// FunctionName Function requiring this dependency
	FunctionName string `json:"function_name"`

	// McpTool MCP tool name on provider (NULL if unresolved)
	McpTool *string `json:"mcp_tool,omitempty"`

	// ProviderAgentId Provider agent ID (NULL if unresolved)
	ProviderAgentId *string `json:"provider_agent_id,omitempty"`

	// Status Dependency resolution status
	Status DependencyResolutionInfoStatus `json:"status"`

	// Tags Required tags for matching
	Tags *[]string `json:"tags,omitempty"`
}

// DependencyResolutionInfoStatus Dependency resolution status
type DependencyResolutionInfoStatus string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// LLMToolInfo Complete tool information for LLM consumption.
// Includes everything an LLM needs to understand and call the tool via MCP protocol.
type LLMToolInfo struct {
	// Capability Capability name this tool provides
	Capability string `json:"capability"`

	// Description Human-readable tool description for LLM context
	Description string `json:"description"`

	// Endpoint Agent endpoint for MCP protocol calls
	Endpoint string `json:"endpoint"`

	// InputSchema JSON Schema for tool parameters (MCP format).
	// LLM uses this to understand required and optional parameters.
	InputSchema map[string]interface{} `json:"inputSchema"`

	// Kwargs Proxy configuration for tool execution (timeout, retry, streaming, etc.).
	// Passed to UnifiedMCPProxy for enhanced client behavior.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Name Function name (MCP protocol level)
	Name string `json:"name"`

	// Tags Capability tags
	Tags *[]string `json:"tags,omitempty"`

	// Version Tool version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistration Service registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Supports both agents (agent_type=mcp_agent) and API services (agent_type=api).
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions).
	// Tools can optionally include llm_filter if decorated with @mesh.llm.
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of service - mcp_agent provides capabilities, api consumes them
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	// ðŸ¤– AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`

	// LlmTools Map of function_name to filtered tool list for LLM agents.
	// Enables LLM agents to receive auto-filtered, up-to-date tool lists based on llm_filter in tool registration.
	// ðŸ¤– AI NOTE: This is populated only when tool includes llm_filter.
	// Registry applies filtering logic and returns matching tools with full schemas.
	LlmTools  *map[string][]LLMToolInfo      `json:"llm_tools,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// InputSchema JSON Schema for function parameters (MCP tool format).
	// Auto-generated from function signature by FastMCP.
	// Used by LLM agents to understand how to call this tool.
	InputSchema *map[string]interface{} `json:"inputSchema,omitempty"`

	// Kwargs Additional kwargs from @mesh.tool decorator for enhanced client proxy configuration.
	// Supports timeout, retry_count, custom_headers, streaming, auth_required, etc.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// LlmFilter Optional LLM tool filter specification when function is decorated with @mesh.llm.
	// Defines which tools this LLM agent needs access to.
	// Stored as JSON, follows LLMToolFilter schema structure.
	LlmFilter *map[string]interface{} `json:"llm_filter,omitempty"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Graceful agent unregistration
	// (DELETE /agents/{agent_id})
	UnregisterAgent(c *gin.Context, agentId string)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Registry health check (headers only)
	// (HEAD /health)
	HeadHealth(c *gin.Context)
	// Agent registration and heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
	// Fast agent health check
	// (HEAD /heartbeat/{agent_id})
	FastHeartbeatCheck(c *gin.Context, agentId string)
	// Stream trace events for a specific trace ID
	// (GET /traces/{trace_id}/stream)
	StreamTrace(c *gin.Context, traceId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// UnregisterAgent operation middleware
func (siw *ServerInterfaceWrapper) UnregisterAgent(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterAgent(c, agentId)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// HeadHealth operation middleware
func (siw *ServerInterfaceWrapper) HeadHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeadHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// FastHeartbeatCheck operation middleware
func (siw *ServerInterfaceWrapper) FastHeartbeatCheck(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FastHeartbeatCheck(c, agentId)
}

// StreamTrace operation middleware
func (siw *ServerInterfaceWrapper) StreamTrace(c *gin.Context) {

	var err error

	// ------------- Path parameter "trace_id" -------------
	var traceId string

	err = runtime.BindStyledParameterWithOptions("simple", "trace_id", c.Param("trace_id"), &traceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trace_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.StreamTrace(c, traceId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.DELETE(options.BaseURL+"/agents/:agent_id", wrapper.UnregisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.HEAD(options.BaseURL+"/health", wrapper.HeadHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
	router.HEAD(options.BaseURL+"/heartbeat/:agent_id", wrapper.FastHeartbeatCheck)
	router.GET(options.BaseURL+"/traces/:trace_id/stream", wrapper.StreamTrace)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"QzEt7DdWdfvwfwEAAP//JAY66ZpUAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
