// ðŸ¤– AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AgentInfoAgentType.
const (
	AgentInfoAgentTypeApi      AgentInfoAgentType = "api"
	AgentInfoAgentTypeMcpAgent AgentInfoAgentType = "mcp_agent"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	MeshAgentRegistrationAgentTypeApi      MeshAgentRegistrationAgentType = "api"
	MeshAgentRegistrationAgentTypeMcpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	Available   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	Degraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	Unavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType    AgentInfoAgentType `json:"agent_type"`
	Capabilities []CapabilityInfo   `json:"capabilities"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int             `json:"dependencies_resolved"`
	Endpoint             string          `json:"endpoint"`
	Id                   string          `json:"id"`
	LastSeen             *time.Time      `json:"last_seen,omitempty"`
	Name                 string          `json:"name"`
	Status               AgentInfoStatus `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoAgentType Type of service - mcp_agent provides capabilities, api consumes them
type AgentInfoAgentType string

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// MeshAgentRegistration Service registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Supports both agents (agent_type=mcp_agent) and API services (agent_type=api).
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions)
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of service - mcp_agent provides capabilities, api consumes them
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	// ðŸ¤– AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// Kwargs Additional kwargs from @mesh.tool decorator for enhanced client proxy configuration.
	// Supports timeout, retry_count, custom_headers, streaming, auth_required, etc.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Graceful agent unregistration
	// (DELETE /agents/{agent_id})
	UnregisterAgent(c *gin.Context, agentId string)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Registry health check (headers only)
	// (HEAD /health)
	HeadHealth(c *gin.Context)
	// Agent registration and heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
	// Fast agent health check
	// (HEAD /heartbeat/{agent_id})
	FastHeartbeatCheck(c *gin.Context, agentId string)
	// Stream trace events for a specific trace ID
	// (GET /traces/{trace_id}/stream)
	StreamTrace(c *gin.Context, traceId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// UnregisterAgent operation middleware
func (siw *ServerInterfaceWrapper) UnregisterAgent(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterAgent(c, agentId)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// HeadHealth operation middleware
func (siw *ServerInterfaceWrapper) HeadHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeadHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// FastHeartbeatCheck operation middleware
func (siw *ServerInterfaceWrapper) FastHeartbeatCheck(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FastHeartbeatCheck(c, agentId)
}

// StreamTrace operation middleware
func (siw *ServerInterfaceWrapper) StreamTrace(c *gin.Context) {

	var err error

	// ------------- Path parameter "trace_id" -------------
	var traceId string

	err = runtime.BindStyledParameterWithOptions("simple", "trace_id", c.Param("trace_id"), &traceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trace_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.StreamTrace(c, traceId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.DELETE(options.BaseURL+"/agents/:agent_id", wrapper.UnregisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.HEAD(options.BaseURL+"/health", wrapper.HeadHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
	router.HEAD(options.BaseURL+"/heartbeat/:agent_id", wrapper.FastHeartbeatCheck)
	router.GET(options.BaseURL+"/traces/:trace_id/stream", wrapper.StreamTrace)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
