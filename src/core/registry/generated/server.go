//  AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AgentInfoAgentType.
const (
	AgentInfoAgentTypeApi      AgentInfoAgentType = "api"
	AgentInfoAgentTypeMcpAgent AgentInfoAgentType = "mcp_agent"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for DependencyResolutionInfoStatus.
const (
	DependencyResolutionInfoStatusAvailable   DependencyResolutionInfoStatus = "available"
	DependencyResolutionInfoStatusUnavailable DependencyResolutionInfoStatus = "unavailable"
	DependencyResolutionInfoStatusUnresolved  DependencyResolutionInfoStatus = "unresolved"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	MeshAgentRegistrationAgentTypeApi      MeshAgentRegistrationAgentType = "api"
	MeshAgentRegistrationAgentTypeMcpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	MeshRegistrationResponseDependenciesResolvedStatusAvailable   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	MeshRegistrationResponseDependenciesResolvedStatusDegraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	MeshRegistrationResponseDependenciesResolvedStatusUnavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// Defines values for ResolvedLLMProviderStatus.
const (
	Available   ResolvedLLMProviderStatus = "available"
	Degraded    ResolvedLLMProviderStatus = "degraded"
	Unavailable ResolvedLLMProviderStatus = "unavailable"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType    AgentInfoAgentType `json:"agent_type"`
	Capabilities []CapabilityInfo   `json:"capabilities"`

	// DependenciesResolved Number of dependencies that have been resolved
	DependenciesResolved int `json:"dependencies_resolved"`

	// DependencyResolutions List of all dependency resolutions (both resolved and unresolved)
	DependencyResolutions *[]DependencyResolutionInfo `json:"dependency_resolutions,omitempty"`
	Endpoint              string                      `json:"endpoint"`
	Id                    string                      `json:"id"`
	LastSeen              *time.Time                  `json:"last_seen,omitempty"`
	Name                  string                      `json:"name"`
	Status                AgentInfoStatus             `json:"status"`

	// TotalDependencies Total number of dependencies required by this agent
	TotalDependencies int     `json:"total_dependencies"`
	Version           *string `json:"version,omitempty"`
}

// AgentInfoAgentType Type of service - mcp_agent provides capabilities, api consumes them
type AgentInfoAgentType string

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// CapabilityInfo defines model for CapabilityInfo.
type CapabilityInfo struct {
	// Description Human-readable description of the capability
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the function that provides this capability
	FunctionName string `json:"function_name"`

	// Name Capability name
	Name string `json:"name"`

	// Tags Tags associated with this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Capability version
	Version string `json:"version"`
}

// DependencyResolutionInfo defines model for DependencyResolutionInfo.
type DependencyResolutionInfo struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Endpoint Provider endpoint (NULL if unresolved)
	Endpoint *string `json:"endpoint,omitempty"`

	// FunctionName Function requiring this dependency
	FunctionName string `json:"function_name"`

	// McpTool MCP tool name on provider (NULL if unresolved)
	McpTool *string `json:"mcp_tool,omitempty"`

	// ProviderAgentId Provider agent ID (NULL if unresolved)
	ProviderAgentId *string `json:"provider_agent_id,omitempty"`

	// Status Dependency resolution status
	Status DependencyResolutionInfoStatus `json:"status"`

	// Tags Required tags for matching
	Tags *[]string `json:"tags,omitempty"`
}

// DependencyResolutionInfoStatus Dependency resolution status
type DependencyResolutionInfoStatus string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// LLMProvider LLM provider specification for mesh delegation mode.
// When @mesh.llm uses provider=dict, the registry resolves a matching LLM provider
// agent and returns its endpoint in llm_providers response field.
//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
type LLMProvider struct {
	// Capability Required capability name (typically "llm")
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching with operators:
	// - "tag" = required
	// - "+tag" = preferred
	// - "-tag" = excluded
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint (semver format)
	Version *string `json:"version,omitempty"`
}

// LLMToolInfo Complete tool information for LLM consumption.
// Includes everything an LLM needs to understand and call the tool via MCP protocol.
type LLMToolInfo struct {
	// Capability Capability name this tool provides
	Capability string `json:"capability"`

	// Description Human-readable tool description for LLM context
	Description string `json:"description"`

	// Endpoint Agent endpoint for MCP protocol calls
	Endpoint string `json:"endpoint"`

	// InputSchema JSON Schema for tool parameters (MCP format).
	// LLM uses this to understand required and optional parameters.
	InputSchema map[string]interface{} `json:"inputSchema"`

	// Kwargs Proxy configuration for tool execution (timeout, retry, streaming, etc.).
	// Passed to UnifiedMCPProxy for enhanced client behavior.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Name Function name (MCP protocol level)
	Name string `json:"name"`

	// Tags Capability tags
	Tags *[]string `json:"tags,omitempty"`

	// Version Tool version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistration Service registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Supports both agents (agent_type=mcp_agent) and API services (agent_type=api).
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of service - mcp_agent provides capabilities, api consumes them
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions).
	// Tools can optionally include llm_filter if decorated with @mesh.llm.
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of service - mcp_agent provides capabilities, api consumes them
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	//  AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`

	// LlmProviders Map of function_name to resolved LLM provider for mesh delegation.
	// Populated only when tool includes llm_provider specification.
	// Registry resolves matching LLM provider agent based on capability/tags/version.
	//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
	LlmProviders *map[string]ResolvedLLMProvider `json:"llm_providers,omitempty"`

	// LlmTools Map of function_name to filtered tool list for LLM agents.
	// Enables LLM agents to receive auto-filtered, up-to-date tool lists based on llm_filter in tool registration.
	//  AI NOTE: This is populated only when tool includes llm_filter.
	// Registry applies filtering logic and returns matching tools with full schemas.
	LlmTools  *map[string][]LLMToolInfo      `json:"llm_tools,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// InputSchema JSON Schema for function parameters (MCP tool format).
	// Auto-generated from function signature by FastMCP.
	// Used by LLM agents to understand how to call this tool.
	InputSchema *map[string]interface{} `json:"inputSchema,omitempty"`

	// Kwargs Additional kwargs from @mesh.tool decorator for enhanced client proxy configuration.
	// Supports timeout, retry_count, custom_headers, streaming, auth_required, etc.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// LlmFilter Optional LLM tool filter specification when function is decorated with @mesh.llm.
	// Defines which tools this LLM agent needs access to.
	// Stored as JSON, follows LLMToolFilter schema structure.
	LlmFilter *map[string]interface{} `json:"llm_filter,omitempty"`

	// LlmProvider LLM provider specification for mesh delegation mode.
	// When @mesh.llm uses provider=dict, the registry resolves a matching LLM provider
	// agent and returns its endpoint in llm_providers response field.
	//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
	LlmProvider *LLMProvider `json:"llm_provider,omitempty"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// ResolvedLLMProvider Resolved LLM provider information for mesh delegation.
// Contains all necessary data to create a proxy and delegate LLM calls to this provider.
//  AI NOTE: This enables LLM mesh delegation (v0.6.1 feature).
type ResolvedLLMProvider struct {
	// AgentId ID of the provider agent
	AgentId string `json:"agent_id"`

	// Capability Capability name (typically "llm")
	Capability string `json:"capability"`

	// Endpoint Provider agent endpoint for MCP protocol calls
	Endpoint string `json:"endpoint"`

	// Kwargs Optional proxy configuration (timeout, retry, etc.).
	// Passed to UnifiedMCPProxy for enhanced client behavior.
	Kwargs *map[string]interface{} `json:"kwargs,omitempty"`

	// Name Function name of the LLM provider tool
	Name string `json:"name"`

	// Status Current status of the provider
	Status ResolvedLLMProviderStatus `json:"status"`

	// Tags Provider capability tags
	Tags *[]string `json:"tags,omitempty"`

	// Vendor LLM vendor/provider name extracted from model string.
	// Used by consumer to select appropriate ProviderHandler for optimal LLM interaction.
	// Automatically extracted using LiteLLM's get_llm_provider() function during provider registration.
	// Common values: "anthropic", "openai", "google", "cohere", "ollama", "together", etc.
	Vendor string `json:"vendor"`

	// Version Provider version
	Version *string `json:"version,omitempty"`
}

// ResolvedLLMProviderStatus Current status of the provider
type ResolvedLLMProviderStatus string

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Graceful agent unregistration
	// (DELETE /agents/{agent_id})
	UnregisterAgent(c *gin.Context, agentId string)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Registry health check (headers only)
	// (HEAD /health)
	HeadHealth(c *gin.Context)
	// Agent registration and heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
	// Fast agent health check
	// (HEAD /heartbeat/{agent_id})
	FastHeartbeatCheck(c *gin.Context, agentId string)
	// Stream trace events for a specific trace ID
	// (GET /traces/{trace_id}/stream)
	StreamTrace(c *gin.Context, traceId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// UnregisterAgent operation middleware
func (siw *ServerInterfaceWrapper) UnregisterAgent(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterAgent(c, agentId)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// HeadHealth operation middleware
func (siw *ServerInterfaceWrapper) HeadHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeadHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// FastHeartbeatCheck operation middleware
func (siw *ServerInterfaceWrapper) FastHeartbeatCheck(c *gin.Context) {

	var err error

	// ------------- Path parameter "agent_id" -------------
	var agentId string

	err = runtime.BindStyledParameterWithOptions("simple", "agent_id", c.Param("agent_id"), &agentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter agent_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FastHeartbeatCheck(c, agentId)
}

// StreamTrace operation middleware
func (siw *ServerInterfaceWrapper) StreamTrace(c *gin.Context) {

	var err error

	// ------------- Path parameter "trace_id" -------------
	var traceId string

	err = runtime.BindStyledParameterWithOptions("simple", "trace_id", c.Param("trace_id"), &traceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter trace_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.StreamTrace(c, traceId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.DELETE(options.BaseURL+"/agents/:agent_id", wrapper.UnregisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.HEAD(options.BaseURL+"/health", wrapper.HeadHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
	router.HEAD(options.BaseURL+"/heartbeat/:agent_id", wrapper.FastHeartbeatCheck)
	router.GET(options.BaseURL+"/traces/:trace_id/stream", wrapper.StreamTrace)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
