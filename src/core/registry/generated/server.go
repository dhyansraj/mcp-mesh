// ðŸ¤– AI BEHAVIOR GUIDANCE:
// This file contains generated REGISTRY server interfaces from OpenAPI spec.
// DO NOT modify this file directly - it will be overwritten.
//
// SCOPE: Registry API endpoints for agent registration and management
//
// TO ADD NEW REGISTRY ENDPOINTS:
// 1. Update api/mcp-mesh-registry.openapi.yaml
// 2. Run: make generate
// 3. Implement business logic in handlers_impl.go
//
// GENERATED FROM: api/mcp-mesh-registry.openapi.yaml
// CONTRACT: Registry service endpoints only

// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// Defines values for AgentInfoStatus.
const (
	AgentInfoStatusDegraded  AgentInfoStatus = "degraded"
	AgentInfoStatusHealthy   AgentInfoStatus = "healthy"
	AgentInfoStatusOffline   AgentInfoStatus = "offline"
	AgentInfoStatusUnhealthy AgentInfoStatus = "unhealthy"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded  HealthResponseStatus = "degraded"
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for MeshAgentRegistrationAgentType.
const (
	McpAgent MeshAgentRegistrationAgentType = "mcp_agent"
)

// Defines values for MeshRegistrationResponseDependenciesResolvedStatus.
const (
	Available   MeshRegistrationResponseDependenciesResolvedStatus = "available"
	Degraded    MeshRegistrationResponseDependenciesResolvedStatus = "degraded"
	Unavailable MeshRegistrationResponseDependenciesResolvedStatus = "unavailable"
)

// Defines values for MeshRegistrationResponseStatus.
const (
	Error   MeshRegistrationResponseStatus = "error"
	Success MeshRegistrationResponseStatus = "success"
)

// AgentInfo defines model for AgentInfo.
type AgentInfo struct {
	Capabilities []string        `json:"capabilities"`
	Dependencies *[]string       `json:"dependencies,omitempty"`
	Endpoint     string          `json:"endpoint"`
	Id           string          `json:"id"`
	LastSeen     *time.Time      `json:"last_seen,omitempty"`
	Name         string          `json:"name"`
	Status       AgentInfoStatus `json:"status"`
	Version      *string         `json:"version,omitempty"`
}

// AgentInfoStatus defines model for AgentInfo.Status.
type AgentInfoStatus string

// AgentsListResponse defines model for AgentsListResponse.
type AgentsListResponse struct {
	// Agents List of registered agents
	Agents []AgentInfo `json:"agents"`

	// Count Total number of agents
	Count     int       `json:"count"`
	Timestamp time.Time `json:"timestamp"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message
	Error     string    `json:"error"`
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Service Service identifier
	Service string `json:"service"`

	// Status Overall registry health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Current server timestamp
	Timestamp time.Time `json:"timestamp"`

	// UptimeSeconds Registry uptime in seconds
	UptimeSeconds int `json:"uptime_seconds"`

	// Version Registry version
	Version string `json:"version"`
}

// HealthResponseStatus Overall registry health status
type HealthResponseStatus string

// MeshAgentRegistration Agent registration request with flattened structure.
// Used by both /agents/register and /heartbeat endpoints.
// Based on @mesh.tool decorator processing - always has at least one tool.
type MeshAgentRegistration struct {
	// AgentId Unique identifier for the agent
	AgentId string `json:"agent_id"`

	// AgentType Type of agent (always mcp_agent for mesh tools)
	AgentType *MeshAgentRegistrationAgentType `json:"agent_type,omitempty"`

	// HttpHost HTTP host for agent endpoint
	HttpHost *string `json:"http_host,omitempty"`

	// HttpPort HTTP port for agent endpoint (0 for stdio)
	HttpPort *int `json:"http_port,omitempty"`

	// Name Human-readable agent name (defaults to agent_id)
	Name *string `json:"name,omitempty"`

	// Namespace Agent namespace for organization
	Namespace *string `json:"namespace,omitempty"`

	// Timestamp Registration/heartbeat timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Tools Array of tools provided by this agent (@mesh.tool functions)
	Tools []MeshToolRegistration `json:"tools"`

	// Version Agent version
	Version *string `json:"version,omitempty"`
}

// MeshAgentRegistrationAgentType Type of agent (always mcp_agent for mesh tools)
type MeshAgentRegistrationAgentType string

// MeshRegistrationResponse Response for both registration and heartbeat requests
type MeshRegistrationResponse struct {
	// AgentId Confirmed agent ID
	AgentId string `json:"agent_id"`

	// DependenciesResolved Function name to array of resolved dependencies mapping.
	// ðŸ¤– AI NOTE: This enables immediate dependency injection setup.
	DependenciesResolved *map[string][]struct {
		// AgentId ID of the agent providing the dependency
		AgentId string `json:"agent_id"`

		// Capability Capability name for dependency matching
		Capability string `json:"capability"`

		// Endpoint Endpoint to connect to the provider
		Endpoint string `json:"endpoint"`

		// FunctionName Actual function name to call on provider
		FunctionName string `json:"function_name"`

		// Status Current status of the dependency
		Status MeshRegistrationResponseDependenciesResolvedStatus `json:"status"`
	} `json:"dependencies_resolved,omitempty"`
	Message   string                         `json:"message"`
	Status    MeshRegistrationResponseStatus `json:"status"`
	Timestamp time.Time                      `json:"timestamp"`
}

// MeshRegistrationResponseDependenciesResolvedStatus Current status of the dependency
type MeshRegistrationResponseDependenciesResolvedStatus string

// MeshRegistrationResponseStatus defines model for MeshRegistrationResponse.Status.
type MeshRegistrationResponseStatus string

// MeshToolDependencyRegistration Dependency specification for a tool function
type MeshToolDependencyRegistration struct {
	// Capability Required capability name
	Capability string `json:"capability"`

	// Namespace Namespace filter
	Namespace *string `json:"namespace,omitempty"`

	// Tags Tags for smart matching
	Tags *[]string `json:"tags,omitempty"`

	// Version Version constraint
	Version *string `json:"version,omitempty"`
}

// MeshToolRegistration Metadata for a single @mesh.tool decorated function
type MeshToolRegistration struct {
	// Capability Capability provided by this function
	Capability string `json:"capability"`

	// Dependencies Dependencies required by this function
	Dependencies *[]MeshToolDependencyRegistration `json:"dependencies,omitempty"`

	// Description Function description
	Description *string `json:"description,omitempty"`

	// FunctionName Name of the decorated function
	FunctionName string `json:"function_name"`

	// Tags Tags for this capability
	Tags *[]string `json:"tags,omitempty"`

	// Version Function/capability version
	Version *string `json:"version,omitempty"`
}

// RootResponse defines model for RootResponse.
type RootResponse struct {
	// Endpoints Available API endpoints
	Endpoints []string `json:"endpoints"`
	Service   string   `json:"service"`
	Status    string   `json:"status"`
	Version   string   `json:"version"`
}

// RegisterAgentJSONRequestBody defines body for RegisterAgent for application/json ContentType.
type RegisterAgentJSONRequestBody = MeshAgentRegistration

// SendHeartbeatJSONRequestBody defines body for SendHeartbeat for application/json ContentType.
type SendHeartbeatJSONRequestBody = MeshAgentRegistration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Registry root information
	// (GET /)
	GetRoot(c *gin.Context)
	// List all registered agents
	// (GET /agents)
	ListAgents(c *gin.Context)
	// Register agent with registry
	// (POST /agents/register)
	RegisterAgent(c *gin.Context)
	// Registry health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Send agent heartbeat
	// (POST /heartbeat)
	SendHeartbeat(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRoot operation middleware
func (siw *ServerInterfaceWrapper) GetRoot(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRoot(c)
}

// ListAgents operation middleware
func (siw *ServerInterfaceWrapper) ListAgents(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAgents(c)
}

// RegisterAgent operation middleware
func (siw *ServerInterfaceWrapper) RegisterAgent(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RegisterAgent(c)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// SendHeartbeat operation middleware
func (siw *ServerInterfaceWrapper) SendHeartbeat(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SendHeartbeat(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/", wrapper.GetRoot)
	router.GET(options.BaseURL+"/agents", wrapper.ListAgents)
	router.POST(options.BaseURL+"/agents/register", wrapper.RegisterAgent)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.POST(options.BaseURL+"/heartbeat", wrapper.SendHeartbeat)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/8xay24cudV+FaL+Wdj4u9Ut2xlMGggQWdbYjdiWIGuMYCxFYFed7uaYRdaQrJZ7DD1B",
	"FlkEyCKbZJGHyPPkBZJHCA4vVawqti4eO8lGUFfxcngu3/nOYX3McllWUoAwOpt9zHS+hpLafw9WIMxc",
	"LCX+qJSsQBkG9lVOK7pgnIXf8IGWFYds9i5bKQDDxCobZUuq4Ao4zy5GGTNQ2qFmW0E2y7RROOh6FB5Q",
	"pegWfxdQgShA5MO1pVmDGlOU635rgigqyYTprJetjalmkwmXOeVrqc3sm+l0PxsNl2NFbyJwLsdXUvEi",
	"NZxTbS41gOjOejR99GQ83R8/mp7tT2ePp7Mnv/getSRVSU02ywpqYGxYCak1BS3hXkJoQ03tFCjqErW3",
	"BsrNepuhileKFoDzatE+lsslZwJQtfE24fVgiw0ozWTvlPt7073pcPT1KFPwY80UFCgLw73tmRpJIyuN",
	"ug520awmFz9AbnBv65z6JdPmFHQlhYahl1pHsf8VoHPFKmOlzXAWkUuiYMW0AQUF8UMjn/pKwTKbZf83",
	"aeNj4oNj0kZGwtdyWTtH6256Jg3lRNTlAhRu3uzYqO7RKCuZYCVaa9qsy4SBFSi7EytBG1pWn82velZp",
	"ZHJniHdM2eBIKal2q78AQxl3ligKhnqg/CQaYlQNo56aDpqRBHB5ElZJ7G8HDDVtxSIlaE1XECs4m4sN",
	"5cxb+5IVxOso4dtfXNdO+NtU/MJG324da1AblsNQCW/cC8IKEIYtGaiOJsq8Gpeg12MXA2p7M4R01z7e",
	"gKKckzCXOIwgUSDfCXEubtN7d9vDWikQhuCZQZF25OhzgWxd4ZtLDbkUReLgp+HAbiBhgoSxkQyPv55O",
	"bwvlCDp3bBFGjO6NrY0Z2iV6B4vVPGp8KOV/r0CvLdp5uahJSm2HBH+wYwhKBNqQK2bWZMmpMSCgINqo",
	"Oje1gr1z8Z2Ggiy2ZCHNmkwc+EwCKBMqCjJZA1VmAdSQkBz03rl4SnGmFOTX6MN7RkpOCsilokYqUimZ",
	"g9ZMrMiYUH5Ft5qsqSbUEA4UoV8AwTl756ibRM64dAm/e8bvBPuxjgMK0YOYNTg4yUY7c3NJP7wEsTLr",
	"bPb1E+sZ4ef+KKtQMwo3+N07Ov7pYPz9dPzLy/HF/3+V8lAnnnuMAi5pzY2L58sgRi/vbCto8g154PXR",
	"jLeHQC1ajeiHUfS2a170oKPZaiAfUqpL5FJd8aZ7U++6XeFenJ2dEBxuxXACRSyg3bRdIL1lJVV3y2ly",
	"KxyW2Io8mNqn2hRMPow3/mb6TTJ+Ax3r7VGXVIwV0IIuuPcLgkPJAy+YJkY26efhp/pMkh3qiuY9rwj/",
	"jZLh2kyyZ5dqRQX7yQV4LFe7yH3AOsaLKIq/AGhbv01AEvIxdHz7HkFhwwqHN2bNdIiHCEGWtchxsg2C",
	"O/FARMczKXkHHK+tteZu/v6QH3agP1hqPxkezk6fngkaMAta2gXx8QFistG3qXtj/cWCdgfxEbBbS3v8",
	"1/dA2EMplkyVgY6T+bMbAmTgB3HdeKlAS76BYjf5/Nia+K7yzZ9ZfwqI730K8ww+a/ZPcqmmoNkmzt28",
	"c2CxtLQ3rEZKavK1q6gHy8aFbY8FB2wzkuRSCMjtvyipjwWVWjAEwWUa4Q5yU9M2VJy8uAPyQSluXHoX",
	"nWx4nX0fVNxRZ0hJdEMZR2y1PDL+1RDMi3sERfew6QJ021aoqegZdi/io33b1xMNqBQclMRuS0paVUys",
	"9s7Fv/7ytz+Rgzl5fXx2NCNniFgg8KyasLKEglET64gwgRLhVhpMXTlqM5A2FEWdmiYmb7YY1nWOBGpZ",
	"c769W2vBz8hCTdYhDO3L/3yV1XDhOPG0pWHjC7uAEdH9WaPlPglOI8uScj2oa9tFiK4gZ0uWO9S0bIR0",
	"EtAAMm8Cj1N/WpJ3UaSbw6lB9u94/udmE69bHsG46RWaN7EHutKdHd5dDMgrXWnHzEqqTIyEUVdQb7WB",
	"MhtlKxBYmN6vNbizEnvrXiB4os37jPS8nk4fw6/ulogjA97kaTcXWa/A0IIa6l0GCxwOiRIIik/zpCgN",
	"DdhStGCrgqjVe4tH9Xu6N5j8WYyHQYcpOe7F0HbE8G0A/nEXnsePY5W8YfgPCZqJ5b1vqsWwapNhwrI9",
	"Q9xuhfsEnNV2JwlGEVdAKbNRttn/GaF2M/MNip5EqPbpPLif528Jx1Mpb+gqN42IBDsKhIQcnMzbjkVX",
	"eRPX/spGWVsX4Y+m+drvhNxPyVFH8JPbfe1EVQuxg3r+jO5/m4lamw5uAVJ8Cxdi/kYql8LQ3DJfF0DZ",
	"q8MTggFPzoBiPqgV97c8ejaZrJhZ14u9XJYTKsxayYrlk6CYIXU7lMqZEfdRNHd9g2aLpk/nz7J3Ls7F",
	"P/7813/+/Q+EHJ7Oz+aHBy/Jt8enSOKeHb09enl8cnT6ZnYuLJc7rkDg4l0uUMCSCdA25A+PT4/I4fHr",
	"s9ODwzOyAHMFIMhz2XZdsd462Zo15ijOwLXGWub49OjFwdv58Sk5/e7lEW48Jq+P3h6dklIWbOnxFPe3",
	"LTpZGwIfKs5yZkitQRFaYRagHCfOl8RgMUeWlHGiYAkKEdpWPn6VEVmyD2Qra0VyWcCICGnsQfAlrnEg",
	"tmShgL7HafmaihVosgYFhC6XWJ3YivK5jM9l0bQEYax+NC5z1ojNnKK0rFXukFLVZm3NhKpdwJpumFRO",
	"J3/8PQkJ/QXTRqqt1cjGOuyMzAUzjPLW2NYUltxZJs1ZDh4NgrPNzwYuJisQTpw9qVYTP0lPcKxlu4Z3",
	"/LRxooOTeRQMIYyuRxmuSCuWzbLHe9O9x5ntF65tkE7wzwpMihKaWglNFlSzvPUXDBwk0KFWb8qnTm+1",
	"X3rYJi3q1BeRbINYjN6AdsR1mi5awXQuN6C2rvpA0LS7zYtslj0Hg7iaIRI4aLWneDSdhmAGV8bSCr3Q",
	"NY5+0A5gXDq/Ldl3cNtixY7eeqQJi026LkuqtvEQJaXpjAvpM9xqZBc4c9LeMSZN8RwM4f66EUvk3NW6",
	"fDu8fNyl+8WWHL6cu1VyWZbWdKKIiz9bTNa4ZUrzL5k2ByG5fDHlJy5kEybYffXatYMd194xde9ogyH8",
	"g9gQbdLEvN30oYdegABHBFz5Vo5UpK6wSiLwgXnXHtxpdCzUYHzAaIsnp/7Ww/kNQtS3898ePSNjUkiL",
	"iB58A+QOkPbpEATLGnWR51AZB7fwwaejkhq3qe/L2ZFM5LwuoHPJGfXlcqkUcOqQbYwuplPXM+7exvVO",
	"XdMCl4mKjYW9g3FaTzhd0PKBvynw7cCnstjeweU8obBOuqw59xcO6IyNixxKHGJCM87KW9bcMCTgXnDR",
	"7a8gxlJeQ7fNl9lZY5/Ix+FuI75q6Vx6RHcc0b1EdA3hLg18nkgvHpXYSC+LuqkS2o7IrjaIb3i/61Zz",
	"WQVKS0E5+wmKy6g069Ze/Vm9zkAsV1S6+4DzlfZFnKo6dfD1oKB43q+EnKGKbvtq0IubZbbivwyVTZCg",
	"U3kM82XvcFdAzRrUpQJrmNt0EYYHdQzW49L5aTviYij4CsylX8m+b6V85KS89pfDNOnWr9yrBPzs8N5e",
	"WzztHPFXWX15rYqvLyxa3w3r07fCCbhP3AsX1NAsLgeMquF6kJj2P1ti2nm/cYu8w1bo9Sh78hkzZvfz",
	"mYQ04XOVof5SpAVUjIRxoZdKl57E3EYh0594WGB17DKiSAkC4/vWnh/qtax54asQZXdwH/loUgsO2vH5",
	"lq9qZPQcqwb5HkT0wYA2VJm6IgUY3/TmcmWFQaq0g32+CGX3F6NAvY91bmSgmoSvYHYQUK/wfA35+13k",
	"s+0f7GQ7b0AUpALFZMHyiAYYSUrKhKFMJKDGGngFJiaZjh/pO5Agyym0v8lCGkT18PMOpBMV1ZptIpMX",
	"oNnK8pIjf9nBMVF0RLtag2hn5LIETaTgTGAh2UaB95EOP/LUSJPkXWH/3q29UvFHt1WsPQa5kuo9biEK",
	"yqWAnlBMk0JeiVGDJGTDaKR8O7opvxLuilZ7ETWHPok9fak88YWyRKse2+R+0HOg2Ace3iGBTP8rCeRF",
	"dP+dA9v8r6SQrnJ7mGMxgnaNkMwbvr0IynlOr7STOeWkgA1wWZURomw7fZL+B9eOtvXuAGT+HtTkN/UC",
	"lAADeudS4blf6aKReud3dR5XEeB8Mov7tN7XPcoOJTtIQ2VJBV3ZRlW7Rqhrh6dLFe6uVgkNlHaVDmO9",
	"vrj+dwAAAP///wtVpLAvAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
