package scaffold

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

// DetectedAgent represents an agent discovered from main.py
type DetectedAgent struct {
	Name     string // From @mesh.agent(name="...")
	Port     int    // From http_port=...
	Dir      string // Directory containing main.py (relative to scan root)
	MainFile string // Full path to main.py
}

// ComposeConfig holds configuration for docker-compose generation
type ComposeConfig struct {
	Agents        []DetectedAgent
	Observability bool   // Include tempo/grafana/redis
	NetworkName   string // Docker network name
	ProjectName   string // Docker compose project name
}

// ScanForAgents walks the directory tree looking for main.py files with @mesh.agent decorator
func ScanForAgents(dir string) ([]DetectedAgent, error) {
	var agents []DetectedAgent

	// Get absolute path for consistent handling
	absDir, err := filepath.Abs(dir)
	if err != nil {
		return nil, fmt.Errorf("failed to get absolute path: %w", err)
	}

	err = filepath.WalkDir(absDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Skip hidden directories
		if d.IsDir() && strings.HasPrefix(d.Name(), ".") {
			return filepath.SkipDir
		}

		// Skip common non-agent directories
		if d.IsDir() {
			switch d.Name() {
			case "node_modules", "__pycache__", "venv", ".venv", "env", ".env", "dist", "build":
				return filepath.SkipDir
			}
		}

		// Look for main.py files
		if d.Name() == "main.py" {
			content, err := os.ReadFile(path)
			if err != nil {
				return nil // Skip unreadable files
			}

			agent, err := parseAgentDecorator(string(content))
			if err != nil || agent == nil {
				return nil // Skip files without @mesh.agent
			}

			// Set directory relative to scan root
			relDir, err := filepath.Rel(absDir, filepath.Dir(path))
			if err != nil {
				relDir = filepath.Dir(path)
			}
			agent.Dir = relDir
			agent.MainFile = path

			agents = append(agents, *agent)
		}
		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to scan directory: %w", err)
	}

	return agents, nil
}

// parseAgentDecorator extracts name and port from @mesh.agent decorator
func parseAgentDecorator(content string) (*DetectedAgent, error) {
	// Pattern to match @mesh.agent decorator (handles multiline)
	// We need to match the decorator and its contents, handling newlines
	agentPattern := regexp.MustCompile(`@mesh\.agent\s*\([\s\S]*?\)`)
	match := agentPattern.FindString(content)
	if match == "" {
		return nil, nil // Not an agent file
	}

	// Extract name - handles both single and double quotes
	namePattern := regexp.MustCompile(`name\s*=\s*["']([^"']+)["']`)
	nameMatch := namePattern.FindStringSubmatch(match)
	if len(nameMatch) < 2 {
		return nil, fmt.Errorf("could not extract agent name from decorator")
	}

	// Extract port (optional, default 9000)
	portPattern := regexp.MustCompile(`http_port\s*=\s*(\d+)`)
	portMatch := portPattern.FindStringSubmatch(match)
	port := 9000 // Default
	if len(portMatch) >= 2 {
		port, _ = strconv.Atoi(portMatch[1])
	}

	return &DetectedAgent{
		Name: nameMatch[1],
		Port: port,
	}, nil
}

// validateAgentPorts checks for port conflicts among agents
func validateAgentPorts(agents []DetectedAgent) error {
	ports := make(map[int]string)
	for _, agent := range agents {
		if existing, ok := ports[agent.Port]; ok {
			return fmt.Errorf("port conflict: %s and %s both use port %d",
				existing, agent.Name, agent.Port)
		}
		ports[agent.Port] = agent.Name
	}
	return nil
}

// GenerateDockerCompose generates a docker-compose.yml file for the given configuration
func GenerateDockerCompose(config *ComposeConfig, outputDir string) error {
	// Validate ports
	if err := validateAgentPorts(config.Agents); err != nil {
		return err
	}

	// Set defaults
	if config.ProjectName == "" {
		// Get absolute path to handle "." properly
		absPath, err := filepath.Abs(outputDir)
		if err == nil {
			config.ProjectName = filepath.Base(absPath)
		} else {
			config.ProjectName = "mcp-mesh"
		}
	}
	if config.NetworkName == "" {
		config.NetworkName = config.ProjectName + "-network"
	}

	// Parse template
	tmpl, err := template.New("docker-compose").Parse(dockerComposeTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outputPath := filepath.Join(outputDir, "docker-compose.yml")
	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create docker-compose.yml: %w", err)
	}
	defer file.Close()

	// Execute template
	if err := tmpl.Execute(file, config); err != nil {
		return fmt.Errorf("failed to render template: %w", err)
	}

	return nil
}

// dockerComposeTemplate is the embedded template for docker-compose.yml
const dockerComposeTemplate = `# MCP Mesh Development Docker Compose
# Generated by: meshctl scaffold --compose
#
# Usage:
#   docker compose up -d
#
# Services:
#   - postgres: PostgreSQL database for registry
#   - registry: MCP Mesh registry service
{{- if .Observability }}
#   - redis: Redis for state/tracing
#   - tempo: Distributed tracing backend
#   - grafana: Observability dashboard
{{- end }}
{{- range .Agents }}
#   - {{ .Name }}: Agent on port {{ .Port }}
{{- end }}

services:
  # ===== INFRASTRUCTURE =====

  postgres:
    image: postgres:15-alpine
    container_name: {{ .ProjectName }}-postgres
    hostname: postgres
    environment:
      POSTGRES_USER: mcpmesh
      POSTGRES_PASSWORD: mcpmesh
      POSTGRES_DB: mcpmesh
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U mcpmesh"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - {{ .NetworkName }}

  registry:
    image: mcpmesh/registry:0.7
    container_name: {{ .ProjectName }}-registry
    hostname: registry
    ports:
      - "8000:8000"
    environment:
      HOST: "0.0.0.0"
      PORT: "8000"
      DATABASE_URL: postgresql://mcpmesh:mcpmesh@postgres:5432/mcpmesh?sslmode=disable
{{- if .Observability }}
      REDIS_URL: redis://redis:6379
{{- end }}
    depends_on:
      postgres:
        condition: service_healthy
{{- if .Observability }}
      redis:
        condition: service_healthy
{{- end }}
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:8000/health"]
      interval: 5s
      timeout: 3s
      retries: 10
    networks:
      - {{ .NetworkName }}
{{- if .Observability }}

  # ===== OBSERVABILITY =====

  redis:
    image: redis:7-alpine
    container_name: {{ .ProjectName }}-redis
    hostname: redis
    command: redis-server --appendonly yes
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - {{ .NetworkName }}

  tempo:
    image: grafana/tempo:2.3.1
    container_name: {{ .ProjectName }}-tempo
    hostname: tempo
    command: ["-config.file=/etc/tempo.yaml"]
    volumes:
      - ./tempo.yaml:/etc/tempo.yaml:ro
    ports:
      - "3200:3200"
      - "4317:4317"
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3200/ready"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - {{ .NetworkName }}

  grafana:
    image: grafana/grafana:10.2.0
    container_name: {{ .ProjectName }}-grafana
    hostname: grafana
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: admin
      GF_AUTH_ANONYMOUS_ENABLED: "true"
      GF_AUTH_ANONYMOUS_ORG_ROLE: Admin
    ports:
      - "3000:3000"
    depends_on:
      tempo:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - {{ .NetworkName }}
{{- end }}
{{- if .Agents }}

  # ===== AGENTS =====
{{- range .Agents }}

  {{ .Name }}:
    image: mcpmesh/python-runtime:0.7
    container_name: {{ $.ProjectName }}-{{ .Name }}
    hostname: {{ .Name }}
    ports:
      - "{{ .Port }}:{{ .Port }}"
    volumes:
      - ./{{ .Dir }}:/app:ro
    working_dir: /app
    command: ["main.py"]
    environment:
      MCP_MESH_REGISTRY_URL: http://registry:8000
      AGENT_NAME: {{ .Name }}
      AGENT_PORT: "{{ .Port }}"
      HOST: "0.0.0.0"
      MCP_MESH_HTTP_HOST: {{ .Name }}
      MCP_MESH_HTTP_PORT: "{{ .Port }}"
      POD_IP: {{ .Name }}
      MCP_MESH_HTTP_ENABLED: "true"
      MCP_MESH_AGENT_NAME: {{ .Name }}
      MCP_MESH_ENABLED: "true"
      MCP_MESH_AUTO_RUN: "true"
      MCP_MESH_LOG_LEVEL: DEBUG
      MCP_MESH_DEBUG_MODE: "true"
      PYTHONUNBUFFERED: "1"
{{- if $.Observability }}
      REDIS_URL: redis://redis:6379
      MCP_MESH_DISTRIBUTED_TRACING_ENABLED: "true"
{{- end }}
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:{{ .Port }}/health').read()"]
      interval: 5s
      timeout: 3s
      retries: 10
    networks:
      - {{ $.NetworkName }}
{{- end }}
{{- end }}

networks:
  {{ .NetworkName }}:
    name: {{ .NetworkName }}
    driver: bridge
`
