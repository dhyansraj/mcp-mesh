/* MCP Mesh Core - C FFI Bindings
 *
 * Auto-generated by cbindgen. Do not modify manually.
 *
 * This header provides C-compatible bindings for the MCP Mesh Rust core,
 * enabling integration with TypeScript, Kotlin, and other languages.
 *
 * Usage:
 *   1. Link with libmcp_mesh_core.so (Linux), libmcp_mesh_core.dylib (macOS),
 *      or mcp_mesh_core.dll (Windows)
 *   2. Include this header
 *   3. Call mesh_start_agent() with JSON spec to start an agent
 *   4. Use mesh_next_event() to receive topology events
 *   5. Call mesh_shutdown() and mesh_free_handle() on cleanup
 *
 * Functions:
 *   - mesh_start_agent(spec_json) - Start an agent, returns handle
 *   - mesh_next_event(handle, timeout_ms) - Poll for next event (JSON string)
 *   - mesh_is_running(handle) - Check if agent is running (returns 1/0)
 *   - mesh_report_health(handle, status_json) - Report health status (returns 0 on success, -1 on error)
 *   - mesh_shutdown(handle) - Signal agent to shut down
 *   - mesh_last_error() - Get last error message for current thread
 *   - mesh_version() - Get library version string
 *
 * Memory Management:
 *   - Strings returned by mesh_* functions must be freed with mesh_free_string()
 *   - Handles returned by mesh_start_agent() must be freed with mesh_free_handle()
 *   - mesh_version() returns a static string that must NOT be freed
 *
 * Thread Safety:
 *   - All functions are thread-safe
 *   - mesh_last_error() is thread-local
 */


#ifndef MCP_MESH_CORE_H
#define MCP_MESH_CORE_H

/* Generated with cbindgen:0.27.0 */

/* Warning: This file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// Opaque handle to a running MCP Mesh agent.
//
// This struct holds all resources needed to interact with the agent runtime.
// It must be freed with `mesh_free_handle` when no longer needed.
//
// Note: This struct is intentionally NOT `#[repr(C)]` to keep its internals
// opaque to C consumers. The FFI functions work with raw pointers.
typedef struct MeshAgentHandle MeshAgentHandle;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Start an agent from JSON specification.
//
// # Arguments
// * `spec_json` - JSON string containing AgentSpec
//
// # Returns
// Handle to agent, or NULL on error (check `mesh_last_error`)
//
// # Safety
// * `spec_json` must be a valid null-terminated C string
// * The returned handle must be freed with `mesh_free_handle`
struct MeshAgentHandle *mesh_start_agent(const char *spec_json);

// Request graceful shutdown of agent.
//
// Sends unregister to registry, stops heartbeat loop.
// Non-blocking - use `mesh_next_event` to wait for shutdown event.
//
// # Safety
// * `handle` must be a valid handle from `mesh_start_agent`
void mesh_shutdown(struct MeshAgentHandle *handle);

// Free agent handle and associated resources.
//
// If the agent is still running, this will trigger graceful shutdown
// and wait briefly (up to 2 seconds) for the agent to unregister from
// the registry before dropping resources.
//
// # Safety
// * `handle` must be a valid handle from `mesh_start_agent` or NULL
// * After this call, `handle` is invalid and must not be used
void mesh_free_handle(struct MeshAgentHandle *handle);

// Get next event from agent runtime.
//
// Blocks until event available or timeout.
//
// # Arguments
// * `handle` - Agent handle
// * `timeout_ms` - Timeout in milliseconds (-1 for infinite, 0 for non-blocking)
//
// # Returns
// JSON string (caller must free with `mesh_free_string`), or NULL on timeout/shutdown
//
// # Safety
// * `handle` must be a valid handle from `mesh_start_agent`
// * The returned string must be freed with `mesh_free_string`
char *mesh_next_event(struct MeshAgentHandle *handle, int64_t timeout_ms);

// Check if agent is still running.
//
// # Arguments
// * `handle` - Agent handle
//
// # Returns
// 1 if running, 0 if shutdown/error
//
// # Safety
// * `handle` must be a valid handle from `mesh_start_agent`
int32_t mesh_is_running(const struct MeshAgentHandle *handle);

// Report agent health status.
//
// # Arguments
// * `handle` - Agent handle
// * `status` - Health status: "healthy", "degraded", or "unhealthy"
//
// # Returns
// 0 on success, -1 on error
//
// # Safety
// * `handle` must be a valid handle from `mesh_start_agent`
// * `status` must be a valid null-terminated C string
int32_t mesh_report_health(struct MeshAgentHandle *handle, const char *status);

// Get last error message.
//
// Thread-local, cleared on next `mesh_*` call.
//
// # Returns
// Error message (caller must free with `mesh_free_string`), or NULL if no error
//
// # Safety
// * The returned string must be freed with `mesh_free_string`
char *mesh_last_error(void);

// Free string returned by `mesh_*` functions.
//
// # Safety
// * `s` must be a string returned by a `mesh_*` function or NULL
// * After this call, `s` is invalid and must not be used
void mesh_free_string(char *s);

// Resolve configuration value with priority: ENV > param > default.
//
// For http_host, auto-detects external IP if no value provided.
//
// # Arguments
// * `key_name` - Config key (e.g., "http_host", "registry_url", "namespace")
// * `param_value` - Optional value from code/config (NULL for none)
//
// # Returns
// Resolved value (caller must free with `mesh_free_string`), or NULL if unknown key
//
// # Safety
// * `key_name` must be a valid null-terminated C string
// * `param_value` may be NULL or a valid null-terminated C string
// * The returned string must be freed with `mesh_free_string`
char *mesh_resolve_config(const char *key_name, const char *param_value);

// Resolve integer configuration value with priority: ENV > param > default.
//
// # Arguments
// * `key_name` - Config key (e.g., "http_port", "health_interval")
// * `param_value` - Value from code/config (-1 for none)
//
// # Returns
// Resolved value, or -1 if unknown key or no value available
//
// # Safety
// * `key_name` must be a valid null-terminated C string
int64_t mesh_resolve_config_int(const char *key_name, int64_t param_value);

// Auto-detect external IP address.
//
// Uses UDP socket trick to find IP that routes to external networks.
// Falls back to "localhost" if detection fails.
//
// # Returns
// IP address string (caller must free with `mesh_free_string`)
//
// # Safety
// * The returned string must be freed with `mesh_free_string`
char *mesh_auto_detect_ip(void);

// Get library version string.
//
// # Returns
// Version string (do not free)
const char *mesh_version(void);

// Check if distributed tracing is enabled.
//
// Checks MCP_MESH_DISTRIBUTED_TRACING_ENABLED environment variable.
//
// # Returns
// 1 if tracing is enabled, 0 otherwise
int32_t mesh_is_tracing_enabled(void);

// Initialize the trace publisher.
//
// Must be called before `mesh_publish_span`. Connects to Redis.
//
// # Returns
// 1 on success (Redis connected), 0 on failure
int32_t mesh_init_trace_publisher(void);

// Check if trace publisher is available.
//
// # Returns
// 1 if publisher is initialized and ready, 0 otherwise
int32_t mesh_is_trace_publisher_available(void);

// Publish a trace span to Redis.
//
// Non-blocking (from the caller's perspective) - returns after queuing the span.
// Silently handles failures to never break agent operations.
//
// # Arguments
// * `span_json` - JSON string containing span data (all values should be strings)
//
// # Returns
// 1 on success (queued), 0 on failure
//
// # Safety
// * `span_json` must be a valid null-terminated C string
int32_t mesh_publish_span(const char *span_json);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* MCP_MESH_CORE_H */
