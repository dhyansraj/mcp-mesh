#+TITLE: MCP Mesh TypeScript SDK Design
#+AUTHOR: MCP Mesh Contributors
#+DATE: 2026-01-08
#+OPTIONS: toc:3 num:t

* Overview

This document outlines the design for the MCP Mesh TypeScript SDK, enabling TypeScript/Node.js developers to build MCP Mesh agents with the same developer experience as the Python SDK.

** Goals

1. Provide a clean, idiomatic TypeScript API for building MCP Mesh agents
2. Match the Python SDK's "no boilerplate" experience (no main function needed)
3. Leverage fastmcp (TypeScript) as the underlying MCP framework
4. Connect to Rust core for heartbeat/topology management (via napi-rs)

** Non-Goals

1. Replacing the Python SDK
2. Supporting browser environments (Node.js only)
3. Reimplementing Rust core logic in TypeScript (integrate, don't recreate)

* Key Decisions

| Decision              | Choice                                                    |
|-----------------------+-----------------------------------------------------------|
| Package name          | =@mcpmesh/sdk= (alongside existing =@mcpmesh/cli=)        |
| Repository            | Same repo (mcp-mesh)                                      |
| Location              | =src/runtime/typescript/= (parallel to =python/=)         |
| Rust integration      | napi-rs bindings in =src/runtime/core/typescript/=        |
| Phase 1 scope         | =mesh.tool= equivalent (MCP agents)                       |
| Phase 2 scope         | =mesh.route= for Express routes (REST APIs)               |
| LLM/LLM Provider      | Deferred to Phase 3                                       |
| CLI tooling           | Use existing Go-based =meshctl= (TS support in Phase 6)   |

* Package Structure

#+BEGIN_EXAMPLE
src/runtime/
├── core/                    # Rust core
│   ├── src/                 # Rust source (ffi.rs, heartbeat.rs, runtime.rs, etc.)
│   ├── python/              # PyO3 bindings (existing) - mcp_mesh_core
│   ├── typescript/          # napi-rs bindings (new)
│   ├── pyproject.toml       # maturin config for Python
│   └── Cargo.toml
├── python/                  # Python SDK - mesh package (existing)
└── typescript/              # TypeScript SDK - @mcpmesh/sdk (new)
    ├── package.json
    ├── tsconfig.json
    ├── src/
    │   └── index.ts
    └── README.md
#+END_EXAMPLE

* Current Python Agent Patterns

** Test Agents in Repository

| Agent            | Type         | Decorators Used                      | Port |
|------------------+--------------+--------------------------------------+------|
| calculator       | Tool Provider | @mesh.tool, @mesh.agent              | 9002 |
| smart-assistant  | LLM Agent    | @mesh.tool, @mesh.llm, @mesh.agent   | 9003 |
| openai-provider  | LLM Provider | @mesh.llm_provider, @mesh.agent      | 9004 |
| claude-provider  | LLM Provider | @mesh.llm_provider, @mesh.agent      | 9001 |

** Python Calculator Example

#+BEGIN_SRC python
import mesh
from fastmcp import FastMCP

app = FastMCP("Calculator Service")

@app.tool()
@mesh.tool(
    capability="add",
    description="Add two numbers together",
    tags=["tools", "math"],
)
async def add(a: float, b: float) -> float:
    return a + b

@mesh.agent(
    name="calculator",
    version="1.0.0",
    http_port=9002,
    auto_run=True,
)
class CalculatorAgent:
    pass

# No main method needed!
#+END_SRC

** Python Auto-Start Mechanism

#+BEGIN_EXAMPLE
User writes code → @mesh.agent(auto_run=True) applied
                             ↓
                   _trigger_debounced_processing()
                             ↓
                   Wait 1 second (debounce)
                             ↓
                   StartupPipeline.execute()
                             ↓
                   uvicorn.run() (blocks main thread)
#+END_EXAMPLE

Key files:
- =src/runtime/python/mesh/decorators.py= - Decorator implementations
- =src/runtime/python/_mcp_mesh/pipeline/mcp_startup/startup_orchestrator.py= - Pipeline

* fastmcp TypeScript Research

** Source

- GitHub: https://github.com/punkpeye/fastmcp
- npm: https://www.npmjs.com/package/fastmcp
- Version: 3.26.8 (as of 2026-01-08)

** Key Features

- Tool, Resource, and Prompt definitions
- Authentication and sessions
- SSE and HTTP Streaming transports
- Zod/ArkType/Valibot schema validation
- Built-in CLI for testing (=npx fastmcp dev=)

** Basic Tool Definition

#+BEGIN_SRC typescript
import { FastMCP } from "fastmcp";
import { z } from "zod";

const server = new FastMCP({
  name: "My Server",
  version: "1.0.0",
});

server.addTool({
  name: "add",
  description: "Add two numbers",
  parameters: z.object({
    a: z.number(),
    b: z.number(),
  }),
  execute: async (args) => {
    return String(args.a + args.b);
  },
});

server.start({ transportType: "stdio" });
#+END_SRC

** Transport Options

#+BEGIN_SRC typescript
// Stdio transport (default)
server.start({ transportType: "stdio" });

// HTTP Streaming transport
server.start({
  transportType: "httpStream",
  httpStream: {
    port: 8080,
    endpoint: "/mcp",
  },
});
#+END_SRC

** Context and Session

#+BEGIN_SRC typescript
server.addTool({
  name: "download",
  parameters: z.object({ url: z.string() }),
  execute: async (args, { log, session, sessionId, requestId }) => {
    log.info("Downloading file...", { url: args.url });
    return "done";
  },
});
#+END_SRC

** HTTP Server Stack

fastmcp uses =mcp-proxy= library internally:
- =startHTTPServer()= from mcp-proxy
- Supports health check endpoints (=/health=, =/ready=)
- OAuth discovery endpoints
- Session lifecycle management

* TypeScript SDK Design

** Architecture

#+BEGIN_EXAMPLE
┌─────────────────────────────────────────────────────────┐
│                    User Code                            │
│  const agent = mesh(server, { name: "calc", port: 9002 })│
│  agent.addTool({ capability: "add", ... })              │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                  @mcpmesh/sdk                           │
│  - MeshAgent class (wraps FastMCP)                      │
│  - Auto-start via process.nextTick()                    │
│  - Heartbeat management                                 │
│  - Dependency injection                                 │
└─────────────────────────────────────────────────────────┘
                           │
              ┌────────────┴────────────┐
              ▼                         ▼
┌─────────────────────────┐   ┌─────────────────────────┐
│      fastmcp (TS)       │   │    mcp-mesh-core        │
│  - MCP protocol         │   │    (Rust via napi-rs)   │
│  - Tool/Resource/Prompt │   │  - Heartbeat loop       │
│  - HTTP/SSE transport   │   │  - Topology management  │
└─────────────────────────┘   │  - Registry client      │
              │               └─────────────────────────┘
              ▼
┌─────────────────────────┐
│      mcp-proxy          │
│  - HTTP server          │
│  - Session management   │
└─────────────────────────┘
#+END_EXAMPLE

** Core Implementation

#+BEGIN_SRC typescript
// @mcpmesh/sdk/src/index.ts

import { FastMCP } from "fastmcp";
import { z } from "zod";

// Types
export interface AgentConfig {
  name: string;
  version?: string;
  port: number;
  namespace?: string;
  registryUrl?: string;
}

export interface MeshToolDef<T extends z.ZodType = z.ZodType> {
  name: string;
  capability?: string;
  description?: string;
  tags?: string[];
  dependencies?: string[];
  parameters: T;
  execute: (args: z.infer<T>) => Promise<string> | string;
}

// Internal: pending agent for auto-start
let pendingAgent: MeshAgent | null = null;

// Auto-start after module loading completes
process.nextTick(() => {
  if (pendingAgent) {
    pendingAgent._autoStart().catch((err) => {
      console.error("MCP Mesh auto-start failed:", err);
      process.exit(1);
    });
  }
});

export class MeshAgent {
  private server: FastMCP;
  private config: AgentConfig;
  private tools: Map<string, { capability: string; tags: string[] }> = new Map();

  constructor(server: FastMCP, config: AgentConfig) {
    this.server = server;
    this.config = {
      version: "1.0.0",
      namespace: "default",
      registryUrl: process.env.MCP_MESH_REGISTRY_URL || "http://localhost:8000",
      ...config,
    };
    pendingAgent = this;
  }

  addTool<T extends z.ZodType>(def: MeshToolDef<T>): this {
    // Register with fastmcp
    this.server.addTool({
      name: def.name,
      description: def.description,
      parameters: def.parameters,
      execute: def.execute,
    });

    // Store mesh metadata
    this.tools.set(def.name, {
      capability: def.capability || def.name,
      tags: def.tags || [],
    });

    return this;
  }

  async _autoStart(): Promise<void> {
    console.log(`Starting MCP Mesh agent: ${this.config.name}`);

    // 1. Start HTTP server via fastmcp
    this.server.start({
      transportType: "httpStream",
      httpStream: { port: this.config.port },
    });

    console.log(`Agent listening on port ${this.config.port}`);

    // 2. Start heartbeat to registry (via Rust core)
    await this.startHeartbeat();
  }

  private async startHeartbeat(): Promise<void> {
    // TODO: Connect to Rust core via napi-rs
    // For now, use JS implementation
    const capabilities = Array.from(this.tools.entries()).map(([name, meta]) => ({
      name,
      capability: meta.capability,
      tags: meta.tags,
    }));

    console.log(`Registered ${capabilities.length} capabilities with registry`);

    // Heartbeat loop placeholder
    setInterval(() => {
      // POST to registry
    }, 5000);
  }
}

// User-facing wrapper function
export function mesh(server: FastMCP, config: AgentConfig): MeshAgent {
  return new MeshAgent(server, config);
}
#+END_SRC

** User Code Example

#+BEGIN_SRC typescript
// calculator/index.ts
import { FastMCP } from "fastmcp";
import { mesh } from "@mcpmesh/sdk";
import { z } from "zod";

const server = new FastMCP({ name: "Calculator", version: "1.0.0" });

const agent = mesh(server, {
  name: "calculator",
  port: 9002,
});

agent.addTool({
  name: "add",
  capability: "add",
  tags: ["tools", "math"],
  description: "Add two numbers together",
  parameters: z.object({ a: z.number(), b: z.number() }),
  execute: async ({ a, b }) => String(a + b),
});

agent.addTool({
  name: "subtract",
  capability: "subtract",
  tags: ["tools", "math"],
  parameters: z.object({ a: z.number(), b: z.number() }),
  execute: async ({ a, b }) => String(a - b),
});

// No server.start() or main function needed!
// The SDK auto-starts after module loading completes
#+END_SRC

* Stack Comparison

| Layer              | Python                | TypeScript            |
|--------------------+-----------------------+-----------------------|
| MCP Framework      | fastmcp (Python)      | fastmcp (TS)          |
| HTTP Server        | uvicorn + FastAPI     | mcp-proxy (built-in)  |
| REST Integration   | FastAPI (@mesh.route) | Express (mesh.route)  |
| Auto-start trigger | @mesh.agent decorator | process.nextTick()    |
| Debounce           | threading.Timer       | setTimeout            |
| Heartbeat          | Rust core (PyO3)      | Rust core (napi-rs)   |
| Schema validation  | Type hints + Pydantic | Zod/ArkType/Valibot   |

* Rust Core Bindings

** Binding Strategy

Use napi-rs for TypeScript SDK (mirrors PyO3 approach for Python):

| Language   | Binding Tool | Location                          |
|------------+--------------+-----------------------------------|
| Python     | PyO3/maturin | =src/runtime/core/python/=        |
| TypeScript | napi-rs      | =src/runtime/core/typescript/=    |

** napi-rs Implementation

Bindings will expose same functions as PyO3:
- =mesh_start_agent()= - Start agent runtime
- =mesh_next_event()= - Get next topology event
- =mesh_stop_agent()= - Stop agent runtime

* Implementation Phases

** Target: User Code Example

The goal is to enable this developer experience:

#+BEGIN_SRC typescript
import { FastMCP } from "fastmcp";
import { mesh } from "@mcpmesh/sdk";
import { z } from "zod";

const server = new FastMCP({ name: "Calculator", version: "1.0.0" });

const agent = mesh(server, {
  name: "calculator",
  port: 9002,
});

agent.addTool({
  name: "add",
  capability: "add",
  tags: ["tools", "math"],
  description: "Add two numbers together",
  parameters: z.object({ a: z.number(), b: z.number() }),
  execute: async ({ a, b }) => String(a + b),
});

// No server.start() or main function needed!
#+END_SRC

** Phase 1: TypeScript SDK with Rust Core [COMPLETED]

- [X] Add napi-rs bindings to Rust core (=src/runtime/core/=)
- [X] Create =@mcpmesh/core= package for napi-rs output
- [X] Create =src/runtime/typescript/= directory structure (=@mcpmesh/sdk=)
- [X] Implement =MeshAgent= class wrapping fastmcp
- [X] Implement auto-start via =process.nextTick()=
- [X] Connect to Rust core for heartbeat (via napi-rs)
- [X] Implement =mesh.tool= equivalent (=agent.addTool()=)
- [X] Implement dependency injection for tools
- [X] Implement distributed tracing (OTel-compliant)

Deliverable: TypeScript agents can run and register with mesh using Rust core

** Phase 2: Express Middleware Integration [COMPLETED]

Add =mesh.route= for injecting mesh dependencies into Express routes.

*** User Experience

Zero-boilerplate API development - no =mesh.bind()= or manual initialization:

#+BEGIN_SRC typescript
import express from "express";
import { mesh } from "@mcpmesh/sdk";

const app = express();
app.use(express.json());

// mesh.route() triggers auto-init - no mesh.bind() or start() needed!
app.get("/time", mesh.route(
  [{ capability: "time_service" }],
  async (req, res, { time_service }) => {
    if (!time_service) {
      return res.status(503).json({ error: "Service unavailable" });
    }
    const result = await time_service({});
    res.json({ time: result });
  }
));

// Multiple dependencies
app.get("/status", mesh.route(
  [{ capability: "time_service" }, { capability: "system_info_service" }],
  async (req, res, { time_service, system_info_service }) => {
    const results = {};
    if (time_service) results.time = await time_service({});
    if (system_info_service) results.system = await system_info_service({});
    res.json(results);
  }
));

// Works with existing middleware (auth, session, etc.)
app.post("/protected",
  requireAuth,
  mesh.route(
    [{ capability: "calculator" }],
    async (req, res, { calculator }) => {
      // req.session, req.user etc. still available
      const result = await calculator({ a: req.body.a, b: req.body.b });
      res.json({ result, user: req.session.user });
    }
  )
);

app.listen(4000);  // That's it - fully automatic!
#+END_SRC

*** Architecture

#+BEGIN_EXAMPLE
┌─────────────────────────────────────────────────────────────────────┐
│                         Express App                                  │
│   app.get("/time", mesh.route([deps], handler))                     │
│   app.listen(4000)                                                  │
└─────────────────────────────────────────────────────────────────────┘
                                │
                    mesh.route() called
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     RouteRegistry                                    │
│   - Stores route metadata with placeholder IDs                      │
│   - route_0_UNKNOWN:UNKNOWN, route_1_UNKNOWN:UNKNOWN, ...           │
└─────────────────────────────────────────────────────────────────────┘
                                │
                    process.nextTick()
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      ApiRuntime                                      │
│   - Starts Rust core with initial tools                             │
│   - Sends first heartbeat with UNKNOWN route names                  │
│   - Installs SIGINT/SIGTERM handlers                                │
└─────────────────────────────────────────────────────────────────────┘
                                │
                    First HTTP request
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                   Auto-Detection (on first request)                  │
│   - Extract port from req.socket.localPort                          │
│   - Introspect routes from req.app._router                          │
│   - Update route names: GET:/time, GET:/status, POST:/protected     │
│   - Call Rust core's updateTools() and updatePort()                 │
└─────────────────────────────────────────────────────────────────────┘
                                │
                    Smart diffing in Rust
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      Rust Core                                       │
│   - Compares new tools with cached tools                            │
│   - Only sends heartbeat if tools actually changed                  │
│   - Registry receives proper route names                            │
└─────────────────────────────────────────────────────────────────────┘
#+END_EXAMPLE

*** Key Implementation Details

**** Auto-Initialization Flow

1. =mesh.route()= is called during Express route registration
2. Routes stored in =RouteRegistry= with placeholder IDs (=route_X_UNKNOWN:UNKNOWN=)
3. =ApiRuntime.scheduleStart()= queues startup via =process.nextTick()=
4. After all routes registered, =ApiRuntime.start()= runs:
   - Generates unique service ID (=api-<random>=)
   - Initializes distributed tracing
   - Starts Rust core with initial tool specs
   - Begins event loop for dependency resolution
   - Installs graceful shutdown handlers

**** Express Route Introspection

On first HTTP request, auto-detection runs once:

#+BEGIN_SRC typescript
function performExpressAutoDetection(req: Request): void {
  // Get port from socket
  const port = req.socket?.localPort || 0;

  // Get Express app from request
  const app = req.app;

  // Introspect routes from app._router (Express 4) or app.router (Express 5)
  const routeCount = introspectExpressRoutes(app);

  // Update Rust core with detected info
  getApiRuntime().updateExpressInfo(port, routeCount);
}
#+END_SRC

**** Dynamic Tools Update (Rust Core)

Added =RuntimeCommand= enum for SDK-to-runtime communication:

#+BEGIN_SRC rust
pub enum RuntimeCommand {
    UpdateTools(Vec<ToolSpec>),
    UpdatePort(u16),
}
#+END_SRC

Smart diffing prevents unnecessary heartbeats:

#+BEGIN_SRC rust
fn tools_are_different(old: &[ToolSpec], new: &[ToolSpec]) -> bool {
    if old.len() != new.len() {
        return true;
    }
    for (o, n) in old.iter().zip(new.iter()) {
        if o.function_name != n.function_name
            || o.capability != n.capability
            || o.dependencies.len() != n.dependencies.len()
        {
            return true;
        }
    }
    false
}
#+END_SRC

**** Graceful Shutdown

Signal handlers properly cleanup and exit:

#+BEGIN_SRC typescript
process.on("SIGINT", async () => {
  console.log("\nReceived SIGINT, shutting down...");
  await runtime.shutdown();  // Unregisters from registry
  process.exit(0);
});
#+END_SRC

*** Files Implemented

| File                                    | Purpose                                    |
|-----------------------------------------+--------------------------------------------|
| =src/runtime/typescript/src/route.ts=   | =mesh.route()= Express middleware          |
| =src/runtime/typescript/src/api-runtime.ts= | API runtime singleton, auto-start      |
| =src/runtime/typescript/src/proxy.ts=   | Dependency proxy for calling services     |
| =src/runtime/core/src/runtime.rs=       | =RuntimeCommand= enum, smart diffing       |
| =src/runtime/core/src/handle.rs=        | =update_tools()=, =update_port()= methods  |
| =src/runtime/core/src/napi.rs=          | JS bindings for update methods            |

*** Completed Tasks

- [X] Implement =mesh.route()= wrapper for Express routes
- [X] Support dependency resolution via registry
- [X] Integrate with existing Express middleware chain
- [X] Add distributed tracing support for HTTP routes
- [X] Auto-initialization via =process.nextTick()= (no =mesh.bind()= needed)
- [X] Auto-detection of port and routes on first HTTP request
- [X] Express route introspection (=app._router= / =app.router=)
- [X] Dynamic tools update in Rust core (=updateTools()=, =updatePort()=)
- [X] Smart diffing - only heartbeat if tools changed
- [X] Graceful shutdown with SIGINT/SIGTERM handlers
- [X] Route ID mapping for dependency resolution during transition

*** Example: Database Output

After first HTTP request, the =dependency_resolutions= table shows proper route names:

#+BEGIN_EXAMPLE
consumer_function_name | capability_required |  provider_function_name  |  status
------------------------+---------------------+--------------------------+-----------
 GET:/time              | time_service        | get_current_time         | available
 GET:/status            | time_service        | get_current_time         | available
 GET:/status            | system_info_service | get_enriched_system_info | available
 GET:/system            | system_info_service | get_enriched_system_info | available
#+END_EXAMPLE

Deliverable: TypeScript REST APIs can use mesh dependencies via Express with zero boilerplate

** Phase 3: LLM Agent Support [COMPLETED]

Implement =mesh.llm()= for LLM-powered tools with agentic loops and mesh tool access.

*** User Experience

#+BEGIN_SRC typescript
import { FastMCP } from "fastmcp";
import { mesh } from "@mcpmesh/sdk";
import { z } from "zod";

const server = new FastMCP({ name: "Smart Assistant", version: "1.0.0" });

// Define response schema with Zod
const AssistResponse = z.object({
  answer: z.string(),
  confidence: z.number(),
  sources: z.array(z.string()),
});

// LLM-powered tool with mesh tool access
server.addTool(mesh.llm({
  name: "assist",
  capability: "smart_assistant",
  description: "LLM-powered assistant with tool access",

  // LLM Configuration
  provider: "claude",                              // Direct LiteLLM provider
  // OR mesh delegation:
  // provider: { capability: "llm", tags: ["+claude"] },

  model: "anthropic/claude-sonnet-4-20250514",     // Override model
  maxIterations: 10,                               // Agentic loop limit

  // System prompt (inline or template file)
  systemPrompt: "file://prompts/assistant.hbs",   // Handlebars template
  contextParam: "ctx",                             // Links to template context

  // Tool filtering - which mesh tools the LLM can access
  filter: [{ capability: "calculator" }, { tags: ["tools"] }],
  filterMode: "all",                               // "all" | "best_match" | "*"

  // LiteLLM parameters
  maxTokens: 4096,
  temperature: 0.7,

  // Input/output schemas
  parameters: z.object({
    message: z.string(),
    ctx: AssistContext,  // Context for template rendering
  }),
  returns: AssistResponse,  // Structured output via Zod

  // Handler receives injected LLM agent
  execute: async ({ message, ctx }, { llm }) => {
    // Simple call - returns AssistResponse
    return await llm(message);

    // With runtime context override
    // return await llm(message, { context: { extra: "data" } });

    // With model parameter override
    // return await llm(message, { maxTokens: 8000 });
  },
}));

const agent = mesh(server, { name: "smart-assistant", port: 9003 });
#+END_SRC

*** Architecture

#+BEGIN_EXAMPLE
┌─────────────────────────────────────────────────────────────────────────┐
│                         mesh.llm() Decorator                             │
│   - Wraps fastmcp tool definition                                       │
│   - Extracts LLM config (provider, filter, systemPrompt, etc.)          │
│   - Registers with DecoratorRegistry                                    │
└─────────────────────────────────────────────────────────────────────────┘
                                │
                    process.nextTick() auto-start
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         Rust Core (napi-rs)                              │
│   - JsLlmAgentSpec: { functionId, filter, filterMode, provider }        │
│   - Sends llm_filter/llm_provider in heartbeat                          │
│   - Receives llm_tools from registry                                    │
│   - Emits "llm_tools_updated" events                                    │
└─────────────────────────────────────────────────────────────────────────┘
                                │
                    llm_tools_updated event
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                      MeshLlmAgentInjector                                │
│   - Creates tool proxies from resolved endpoints                        │
│   - Creates MeshLlmAgent instance with config + proxies                 │
│   - Injects into tool handler                                           │
└─────────────────────────────────────────────────────────────────────────┘
                                │
                    Tool invocation
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         MeshLlmAgent                                     │
│   1. Render system prompt (template + context)                          │
│   2. Build messages array                                               │
│   3. Agentic loop (max_iterations):                                     │
│      a. Call LLM (direct LiteLLM or mesh provider)                      │
│      b. If tool_calls → execute via proxies → add results → loop        │
│      c. Parse final response (Zod validation)                           │
│   4. Attach _meshMeta (tokens, latency)                                 │
└─────────────────────────────────────────────────────────────────────────┘
#+END_EXAMPLE

*** Implementation Tasks

**** Rust Core (napi-rs bindings)

- [X] Add =JsLlmAgentSpec= interface (functionId, filter, filterMode, provider, maxIterations)
- [X] Add =JsLlmToolInfo= interface (name, endpoint, inputSchema, description)
- [X] Add =JsLlmProviderInfo= interface (functionId, agentId, endpoint, functionName, model)
- [X] Extend =JsToolSpec= with =llmFilter= and =llmProvider= fields
- [X] Extend =JsAgentSpec= with =llmAgents= array
- [X] Extend =JsMeshEvent= with =tools= array and =providerInfo= for LLM events

**** TypeScript SDK

- [X] Implement =mesh.llm()= wrapper function
- [X] Implement =MeshLlmAgent= class (agentic loop, tool execution)
- [X] Implement =LlmToolRegistry= for DI from llm_tools_updated events
- [X] Implement =ResponseParser= (Zod schema validation, JSON extraction)
- [X] Implement template rendering (Handlebars with file support)
- [X] Implement provider handlers (LiteLLM + mesh delegation)
- [X] Add =LlmMeta= type for response metadata (tokens, latency)
- [X] Context injection (auto + runtime merge modes)
- [X] LLM event handling in MeshAgent (llm_tools_updated, llm_provider_available)

*** Files Created

| File | Purpose |
|------|---------|
| =src/runtime/core/src/napi.rs= | Extended with LLM types |
| =src/runtime/typescript/src/llm.ts= | =mesh.llm()= wrapper + LlmToolRegistry |
| =src/runtime/typescript/src/llm-agent.ts= | =MeshLlmAgent= class, providers |
| =src/runtime/typescript/src/response-parser.ts= | Zod validation |
| =src/runtime/typescript/src/template.ts= | Handlebars rendering (inline + file://) |
| =src/runtime/typescript/src/types.ts= | LLM type definitions |

*** Parameters Reference

| Parameter | Type | Description |
|-----------|------|-------------|
| =provider= | =string \| object= | ="claude"= (direct) or ={capability, tags}= (mesh) |
| =model= | =string= | LiteLLM model ID (e.g., ="anthropic/claude-sonnet-4-20250514"=) |
| =maxIterations= | =number= | Max agentic loop iterations (default: 10) |
| =systemPrompt= | =string= | Inline or =file://path/to/template.hbs= (Handlebars) |
| =contextParam= | =string= | Parameter name for template context |
| =filter= | =array= | Tool filter criteria =[{capability}, {tags}]= |
| =filterMode= | =string= | ="all"=, ="best_match"=, or ="*"= |
| =returns= | =ZodSchema= | Structured output schema (or omit for string) |
| =<litellm>= | =any= | maxTokens, temperature, topP, etc. |

Deliverable: TypeScript LLM agents with agentic loops and mesh tool access ✓

*** Next Items: Python Feature Parity

The following features are available in Python =mesh.llm()= but not yet in TypeScript.
These should be implemented to achieve full parity:

**** Multi-turn Conversation Support

| Python | TypeScript |
|--------|------------|
| =await llm([{"role": "user", "content": "Hi"}, ...])= | Single string only |

Python supports passing a list of message dicts for multi-turn conversations.
TypeScript currently only accepts a single string message.

#+BEGIN_SRC typescript
// Target API:
const response = await llm([
  { role: "user", content: "What is 5+3?" },
  { role: "assistant", content: "8" },
  { role: "user", content: "Now multiply that by 2" },
]);
#+END_SRC

**** Runtime Context Override

| Python | TypeScript |
|--------|------------|
| =context== parameter | Not implemented |
| =context_mode="merge"/"replace"= | Not implemented |

Python allows runtime context override and merge modes:

#+BEGIN_SRC python
# Python:
result = await llm("query", context={"extra": "data"}, context_mode="merge")
#+END_SRC

#+BEGIN_SRC typescript
// Target API:
const result = await llm("query", {
  context: { extra: "data" },
  contextMode: "merge",  // or "replace"
});
#+END_SRC

**** JSON Schema Injection in System Prompt

| Python | TypeScript |
|--------|------------|
| Auto-injects tool schemas | Not implemented |

Python automatically injects available tool JSON schemas into the system prompt,
helping the LLM understand tool capabilities. TypeScript should add this feature.

**** Typed Error Classes

| Python | TypeScript |
|--------|------------|
| =MaxIterationsError= | Generic errors |
| =ToolExecutionError= | Generic errors |
| =LLMAPIError= | Generic errors |

Python has specific exception types for different failure modes.
TypeScript should implement typed error classes:

#+BEGIN_SRC typescript
// Target implementation:
export class MaxIterationsError extends Error {
  constructor(public iterations: number, public lastResponse: unknown) {
    super(`Max iterations (${iterations}) reached`);
  }
}

export class ToolExecutionError extends Error {
  constructor(public toolName: string, public cause: Error) {
    super(`Tool '${toolName}' failed: ${cause.message}`);
  }
}

export class LLMAPIError extends Error {
  constructor(public statusCode: number, public body: string) {
    super(`LLM API error (${statusCode}): ${body}`);
  }
}
#+END_SRC

**** Runtime System Prompt Override

| Python | TypeScript |
|--------|------------|
| =set_system_prompt(prompt)= | Not implemented |

Python allows changing the system prompt at runtime:

#+BEGIN_SRC typescript
// Target API:
const { llm } = injected;
llm.setSystemPrompt("New instructions...");
const result = await llm("query");
#+END_SRC

**** Output Mode (strict/hint/text)

| Python | TypeScript |
|--------|------------|
| =output_mode="strict"= | Not implemented |
| =output_mode="hint"= | Not implemented |
| =output_mode="text"= | Not implemented |

Python supports different output modes that control how the LLM response
is parsed and validated against the schema:

- =strict=: Enforce exact schema compliance (use provider's native structured output)
- =hint=: Include schema in prompt but accept any response
- =text=: Return raw text without parsing

#+BEGIN_SRC typescript
// Target API:
const tool = mesh.llm({
  outputMode: "strict",  // | "hint" | "text"
  returns: ResponseSchema,
  // ...
});
#+END_SRC

**** Implementation Priority

| Priority | Feature | Complexity | Impact |
|----------|---------|------------|--------|
| High | Multi-turn conversation | Low | Enables chat-like interactions |
| High | Typed error classes | Low | Better error handling |
| Medium | Runtime context override | Medium | Flexible context injection |
| Medium | Output mode | Medium | Better schema enforcement |
| Medium | JSON schema injection | Medium | Improves tool usage |
| Low | Runtime system prompt | Low | Edge case utility |

Note: Provider handlers (vendor-specific optimizations) are addressed in Phase 4
with =mesh.llmProvider()= implementation.

** Phase 4: LLM Provider Support [IN PROGRESS]

Implement =mesh.llmProvider()= to enable zero-code LLM providers in TypeScript,
matching Python's =@mesh.llm_provider= decorator functionality.

*** Underlying LLM Library

Python uses LiteLLM for unified multi-provider access. For TypeScript, use:

| Library | Description |
|---------|-------------|
| [[https://github.com/vercel/ai][Vercel AI SDK]] | Industry standard (20M+ downloads), unified API for OpenAI/Anthropic/Google/etc |

Install: =npm install ai @ai-sdk/openai @ai-sdk/anthropic @ai-sdk/google=

*** Target API

#+BEGIN_SRC typescript
import { FastMCP } from "fastmcp";
import { mesh } from "@mcpmesh/sdk";

const server = new FastMCP({ name: "Claude Provider", version: "1.0.0" });

// Zero-code LLM provider (mirrors Python @mesh.llm_provider)
server.addTool(mesh.llmProvider({
  model: "anthropic/claude-sonnet-4-5",  // Vercel AI SDK model ID
  capability: "llm",
  tags: ["llm", "claude", "anthropic", "provider"],
  version: "1.0.0",

  // Optional: Vercel AI SDK options
  maxTokens: 4096,
  temperature: 0.7,
}));

// Optional health check
async function healthCheck() {
  // Validate API key and reachability
  return { status: "healthy", checks: { api_key: true } };
}

const agent = mesh(server, {
  name: "claude-provider",
  port: 9011,
  healthCheck,
  healthCheckTtl: 30,
});
#+END_SRC

*** Implementation Tasks

**** Core Implementation
- [X] Create =src/runtime/typescript/src/llm-provider.ts=
- [X] Implement =mesh.llmProvider()= wrapper function
- [X] Create =MeshLlmRequest= type (matches Python dataclass)
- [X] Create =processChat(request: MeshLlmRequest)= generated handler
- [X] Integrate Vercel AI SDK for multi-provider support
- [X] Register as both fastmcp tool and mesh tool

**** Vendor Handling
- [X] Extract vendor from model string (e.g., "anthropic/claude-sonnet-4-5" → "anthropic")
- [X] Pass vendor to registry for provider handler selection
- [X] Support model override with vendor validation (Issue #308)
- [X] Log warning on vendor mismatch, fallback to provider's model

**** Response Format
- [X] Return full message dict: ={ role, content, tool_calls? }=
- [X] Include =_mesh_usage= metadata: ={ prompt_tokens, completion_tokens, model }=
- [X] Handle content as string or array of content blocks
- [X] Support tool_calls for agentic loop (critical!)

**** Health Checks
- [ ] API key presence validation
- [ ] API reachability check (use free endpoint like /v1/models)
- [ ] Return structured health: ={ status, checks, errors }=
- [ ] Support =healthCheckTtl= for caching

**** Vendor-Specific Optimizations
- [ ] Claude: Strict output mode via =response_format=
- [ ] OpenAI: JSON mode (=response_format: { type: "json_object" }=)
- [ ] OpenAI: Strict mode (=response_format: { type: "json_schema", ... }=)
- [ ] Google Gemini: Structured output support

*** Files Created

| File | Purpose |
|------|---------|
| =src/runtime/typescript/src/llm-provider.ts= | =mesh.llmProvider()= implementation |
| =src/runtime/typescript/src/types.ts= | Added =MeshLlmRequest=, =LlmProviderConfig= types |

*** Files Created

| File | Purpose |
|------|---------|
| =test/ts-claude-provider/= | Test Claude provider agent |

*** Provider Handler Plugin Architecture

Python has a sophisticated handler plugin system for vendor-specific optimizations.
TypeScript should implement the same pattern for feature parity and performance.

**** Python Architecture Reference

#+BEGIN_EXAMPLE
src/runtime/python/_mcp_mesh/engine/provider_handlers/
├── __init__.py
├── base_provider_handler.py     # Abstract base class
├── claude_handler.py            # Claude-specific optimizations
├── openai_handler.py            # OpenAI-specific optimizations
├── generic_handler.py           # Fallback handler
└── provider_handler_registry.py # Registry + vendor mapping
#+END_EXAMPLE

**** Key Components

| Component | Python | TypeScript (Target) |
|-----------|--------|---------------------|
| Base Handler | =BaseProviderHandler= (ABC) | =ProviderHandler= interface |
| Claude Handler | =ClaudeHandler= | =ClaudeHandler= class |
| OpenAI Handler | =OpenAIHandler= | =OpenAIHandler= class |
| Generic Handler | =GenericHandler= | =GenericHandler= class |
| Registry | =ProviderHandlerRegistry= | =ProviderHandlerRegistry= singleton |

**** Handler Interface

Each handler implements:

| Method | Purpose |
|--------|---------|
| =prepareRequest()= | Vendor-specific request params (response_format, schema) |
| =formatSystemPrompt()= | Vendor-specific prompt formatting |
| =getCapabilities()= | Capability flags (streaming, vision, json_mode, etc.) |

**** Claude Handler Features (from Python)

| Feature | Description | Benefit |
|---------|-------------|---------|
| Prompt Caching | =cache_control: {type: "ephemeral"}= | Up to 90% cost reduction |
| Output Modes | strict/hint/text | Performance vs reliability tradeoff |
| Anti-XML Instructions | Prevents =<invoke>= style tool calls | Better tool calling |
| Schema Strictness | =additionalProperties: false= | Valid JSON output |

**** OpenAI Handler Features (from Python)

| Feature | Description | Benefit |
|---------|-------------|---------|
| response_format | Native structured output | Guaranteed schema compliance |
| Strict Mode | =additionalProperties: false= recursively | Valid JSON output |
| Concise Prompts | Shorter system prompts | Better performance |

**** Implementation Tasks

***** Handler Interface & Registry
- [ ] Create =src/runtime/typescript/src/provider-handlers/= directory
- [ ] Create =provider-handler.ts= - =ProviderHandler= interface
- [ ] Create =provider-handler-registry.ts= - Registry singleton with vendor mapping
- [ ] Create =generic-handler.ts= - Fallback handler

***** Claude Handler
- [ ] Create =claude-handler.ts= - Claude-specific handler
- [ ] Implement prompt caching (=cache_control=)
- [ ] Implement output modes (strict/hint/text)
- [ ] Implement anti-XML tool calling instructions
- [ ] Implement =additionalProperties: false= for schema strictness
- [ ] Implement =determineOutputMode()= based on return type

***** OpenAI Handler
- [ ] Create =openai-handler.ts= - OpenAI-specific handler
- [ ] Implement =response_format= with json_schema
- [ ] Implement recursive =additionalProperties: false=
- [ ] Implement =strict: true= for schema enforcement

***** Integration
- [ ] Integrate handlers into =llm-provider.ts=
- [ ] Update =llm-agent.ts= to use handlers for provider calls
- [ ] Add tests for handler selection and behavior

**** Files to Create

| File | Purpose |
|------|---------|
| =src/runtime/typescript/src/provider-handlers/index.ts= | Exports all handlers |
| =src/runtime/typescript/src/provider-handlers/provider-handler.ts= | Base interface |
| =src/runtime/typescript/src/provider-handlers/provider-handler-registry.ts= | Registry singleton |
| =src/runtime/typescript/src/provider-handlers/claude-handler.ts= | Claude optimizations |
| =src/runtime/typescript/src/provider-handlers/openai-handler.ts= | OpenAI optimizations |
| =src/runtime/typescript/src/provider-handlers/generic-handler.ts= | Fallback handler |

*** Python Reference

Python implementation: =src/runtime/python/mesh/helpers.py= (=llm_provider= function)
Example agent: =test/claude-provider/main.py=

Key features to match:
1. Zero-code: decorator generates =process_chat= function automatically
2. Vendor extraction: =litellm.get_llm_provider(model)= → use similar logic
3. Model override: Consumer can request different model (same vendor only)
4. Usage tracking: Return =_mesh_usage= for cost monitoring
5. Error handling: Wrap LLM errors with informative messages

Deliverable: Zero-code LLM providers in TypeScript

** Phase 5: Unit Test Coverage [COMPLETED]

Comprehensive unit test coverage for TypeScript SDK components.

*** Test Files Created

| File | Tests | Coverage |
|------|-------|----------|
| =provider-handler-registry.test.ts= | 17 | Registry singleton, caching, vendor lookup |
| =claude-handler.test.ts= | 30 | Output modes, schema strictness, prompt caching |
| =openai-handler.test.ts= | 26 | Strict mode, additionalProperties, anyOf/oneOf/allOf |
| =generic-handler.test.ts= | 20 | Fallback behavior, conservative capabilities |
| =response-parser.test.ts= | 45 | JSON extraction, Zod schema validation |
| =sse.test.ts= | 20 | SSE parsing, streaming responses |
| =llm-provider.test.ts= | 30 | Vendor extraction, tool generation |
| =template.test.ts= | 25 | Handlebars rendering, built-in helpers |
| =errors.test.ts= | 20 | Custom error classes |

*** CI Enhancements

- Added Ent ORM code generation validation to =contract-first-development.yml=
- Added =generate-ent= target to Makefile
- Added =.gitattributes= to exclude ~32k lines of generated code from language stats

*** Running Tests

#+BEGIN_SRC bash
cd src/runtime/typescript
npm test
#+END_SRC

Deliverable: 284 unit tests covering provider handlers, response parsing, templates, and errors ✓

** Phase 6: meshctl TypeScript Support

Enable =meshctl= to manage TypeScript agents alongside Python agents.

*** Pre-requisite: Runtime Field in Database and Heartbeat

Before meshctl can distinguish between Python and TypeScript agents, we need to add
a =runtime= field throughout the stack. This is a cross-cutting change affecting all
four languages (Go, Rust, Python, TypeScript).

**** Runtime Enum Values

| Value | Description |
|-------|-------------|
| =python= | Python SDK agent (using mcp_mesh_core via PyO3) |
| =typescript= | TypeScript SDK agent (using mcp-mesh-core via napi-rs) |

**** Changes Required

***** 1. Go - Database (Ent ORM)

File: =src/core/ent/schema/agent.go=

#+BEGIN_SRC go
// Add to Fields():
field.Enum("runtime").
    Values("python", "typescript").
    Optional().
    Comment("SDK runtime: python or typescript"),
#+END_SRC

Then run: =make generate-ent=

***** 2. Go - OpenAPI Specification

File: =api/mcp-mesh-registry.openapi.yaml=

Add =runtime= to HeartbeatRequest schema:

#+BEGIN_SRC yaml
HeartbeatRequest:
  type: object
  required: [agent_id, status, metadata]
  properties:
    # ... existing fields ...
    runtime:
      type: string
      enum: [python, typescript]
      description: SDK runtime language
      example: "python"
#+END_SRC

Then run: =make generate-go=

***** 3. Go - Registry Handlers

File: =src/core/registry/handlers/heartbeat.go=

- Extract =runtime= from heartbeat request
- Save to Agent entity in database
- Include in response for debugging

***** 4. Rust Core - Spec and Registry

Files:
- =src/runtime/core/src/spec.rs= - Add =runtime= field to =AgentSpec=
- =src/runtime/core/src/registry.rs= - Add =runtime= to =HeartbeatRequest=

#+BEGIN_SRC rust
// In spec.rs
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum RuntimeType {
    #[default]
    #[serde(rename = "python")]
    Python,
    #[serde(rename = "typescript")]
    TypeScript,
}

// In AgentSpec struct:
pub runtime: RuntimeType,
#+END_SRC

***** 5. Rust Core - napi.rs (TypeScript bindings)

File: =src/runtime/core/src/napi.rs=

#+BEGIN_SRC rust
// Add to JsAgentSpec:
pub runtime: Option<String>,  // "python" | "typescript"

// In From<JsAgentSpec> for RustAgentSpec:
runtime: js.runtime
    .map(|s| RuntimeType::from_str(&s))
    .unwrap_or(RuntimeType::TypeScript),  // Default for TS SDK
#+END_SRC

***** 6. Rust Core - pyo3.rs (Python bindings)

File: =src/runtime/core/src/spec.rs= (PyO3 section)

#+BEGIN_SRC rust
// In py_new():
runtime: Option<String>,  // defaults to "python"

// Default to Python for Python SDK
runtime: runtime
    .map(|s| RuntimeType::from_str(&s))
    .unwrap_or(RuntimeType::Python),
#+END_SRC

***** 7. Python SDK

File: =src/runtime/python/mesh/decorators.py=

The Python SDK automatically uses the Rust core which will default to =runtime: "python"=.
No changes needed if we set the default correctly in PyO3 bindings.

***** 8. TypeScript SDK

File: =src/runtime/typescript/src/mesh-agent.ts=

The TypeScript SDK automatically uses the Rust core which will default to =runtime: "typescript"=.
No changes needed if we set the default correctly in napi-rs bindings.

**** Implementation Order

1. [ ] OpenAPI spec - Add runtime field
2. [ ] Go registry - Generate code, update handlers
3. [ ] Ent schema - Add runtime field, generate code
4. [ ] Rust core - Add RuntimeType enum and update specs
5. [ ] Rebuild Python SDK (maturin)
6. [ ] Rebuild TypeScript SDK (napi-rs)
7. [ ] Test end-to-end with both Python and TypeScript agents

*** Architecture: Language Handler Pattern

Create a unified handler pattern for language-specific operations across meshctl commands.
This allows clean separation of Python vs TypeScript logic.

#+BEGIN_EXAMPLE
cmd/meshctl/internal/handlers/
├── language.go           # Interface + detection logic
├── python_handler.go     # Python-specific operations
└── typescript_handler.go # TypeScript-specific operations
#+END_EXAMPLE

**** Language Handler Interface

#+BEGIN_SRC go
type LanguageHandler interface {
    // Detection
    Language() string                           // "python" | "typescript"
    CanHandle(path string) bool                 // Check if file/dir is this language
    DetectInDirectory(dir string) bool          // Check if dir contains this language

    // Scaffold
    GetTemplates() map[string]string            // Template files
    GenerateAgent(config ScaffoldConfig) error  // Generate agent files
    GenerateDockerfile() string                 // Dockerfile content
    GenerateHelmValues() map[string]interface{} // Helm values

    // Compose
    ParseAgentFile(path string) (*AgentInfo, error)  // Extract name, port, caps
    GetDockerImage() string                          // Runtime image name

    // Start
    ValidatePrerequisites(dir string) error     // Check .venv or node_modules
    GetStartCommand(file string) []string       // Command to start agent
    GetEnvironment() map[string]string          // Required env vars
}
#+END_SRC

**** Language Normalization

#+BEGIN_SRC go
// NormalizeLanguage converts shorthand to canonical form
func NormalizeLanguage(lang string) string {
    switch strings.ToLower(lang) {
    case "python", "py", "":
        return "python"
    case "typescript", "ts":
        return "typescript"
    default:
        return lang // let validation handle unknown
    }
}

// GetHandlerByLanguage returns handler for explicit --lang flag
func GetHandlerByLanguage(lang string) (LanguageHandler, error) {
    switch NormalizeLanguage(lang) {
    case "python":
        return &PythonHandler{}, nil
    case "typescript":
        return &TypeScriptHandler{}, nil
    default:
        return nil, fmt.Errorf("unsupported language: %s (use: python, py, typescript, ts)", lang)
    }
}
#+END_SRC

**** Auto-Detection Logic

#+BEGIN_SRC go
// DetectLanguage auto-detects from file/directory (used when --lang not specified)
func DetectLanguage(path string) LanguageHandler {
    // 1. File extension check
    if strings.HasSuffix(path, ".py") {
        return &PythonHandler{}
    }
    if strings.HasSuffix(path, ".ts") || strings.HasSuffix(path, ".js") {
        return &TypeScriptHandler{}
    }

    // 2. Directory detection
    if fileExists(filepath.Join(path, "pyproject.toml")) ||
       fileExists(filepath.Join(path, "requirements.txt")) ||
       fileExists(filepath.Join(path, ".venv")) {
        return &PythonHandler{}
    }
    if fileExists(filepath.Join(path, "package.json")) ||
       fileExists(filepath.Join(path, "tsconfig.json")) ||
       fileExists(filepath.Join(path, "node_modules")) {
        return &TypeScriptHandler{}
    }

    // 3. Default to Python for backwards compatibility
    return &PythonHandler{}
}
#+END_SRC

*** meshctl scaffold

**** Language Flag

#+BEGIN_EXAMPLE
--lang, -l <language>    Language: python, py, typescript, ts (default: python)
#+END_EXAMPLE

| Flag Value | Language |
|------------|----------|
| =python= | Python |
| =py= | Python (shorthand) |
| =typescript= | TypeScript |
| =ts= | TypeScript (shorthand) |
| (omitted) | Python (default) |

**** Examples

#+BEGIN_SRC bash
# Python (default - backwards compatible)
meshctl scaffold --name my-agent --agent-type tool
meshctl scaffold --name my-agent --agent-type tool --lang python
meshctl scaffold --name my-agent --agent-type tool -l py

# TypeScript
meshctl scaffold --name my-agent --agent-type tool --lang typescript
meshctl scaffold --name my-agent --agent-type tool -l ts
meshctl scaffold -n my-agent -t tool -l typescript
#+END_SRC

**** Python Output (default)

#+BEGIN_SRC bash
meshctl scaffold --name my-agent --agent-type tool
# Creates:
# my-agent/
# ├── __init__.py
# ├── __main__.py
# ├── main.py
# ├── Dockerfile
# ├── .dockerignore
# ├── requirements.txt
# ├── helm-values.yaml
# └── README.md
#+END_SRC

**** TypeScript Output

#+BEGIN_SRC bash
meshctl scaffold --name my-agent --agent-type tool -l ts
# Creates:
# my-agent/
# ├── src/
# │   └── index.ts
# ├── package.json
# ├── tsconfig.json
# ├── Dockerfile
# ├── .dockerignore
# ├── helm-values.yaml
# └── README.md
#+END_SRC

**** TypeScript Templates

| Agent Type | Template File | Key Imports |
|------------|---------------|-------------|
| tool | basic.ts.tmpl | =fastmcp=, =@mcpmesh/sdk=, =zod= |
| llm-agent | llm-agent.ts.tmpl | + =mesh.llm()= |
| llm-provider | llm-provider.ts.tmpl | + =mesh.llmProvider()= |

**** Docker Images

| Image | Base | Pre-installed | Built During |
|-------|------|---------------|--------------|
| =mcpmesh/python-runtime:0.8= | python:3.11-slim | mcp-mesh SDK | Release |
| =mcpmesh/typescript-runtime:0.8= | node:20-slim | @mcpmesh/sdk, tsx | Release |

Both images are pushed to Docker Hub during release workflow.

**** TypeScript Dockerfile Template

#+BEGIN_SRC dockerfile
# Dockerfile for {{name}} MCP Mesh agent
FROM mcpmesh/typescript-runtime:0.8

WORKDIR /app

# Switch to root to copy files (base image runs as non-root mcp-mesh user)
USER root

# Copy package files and install app-specific dependencies only
COPY package*.json ./
RUN npm ci --omit=dev

# Copy agent source code and set permissions
COPY --chmod=755 . .
RUN chown -R mcp-mesh:mcp-mesh /app

# Switch back to non-root user for security
USER mcp-mesh

# Expose the agent port
EXPOSE 9000

# Run the agent (tsx for .ts, node for .js)
# NOTE: Base image has tsx installed for TypeScript execution
CMD ["npx", "tsx", "src/index.ts"]
#+END_SRC

**** TypeScript Runtime Base Image

The =mcpmesh/typescript-runtime= base image includes:

#+BEGIN_SRC dockerfile
# Base image definition (built during release)
FROM node:20-slim

# Create non-root user (same as Python runtime)
RUN groupadd -r mcp-mesh && useradd -r -g mcp-mesh mcp-mesh

WORKDIR /app

# Pre-install mesh SDK and tsx runtime
RUN npm install -g @mcpmesh/sdk tsx

# Set non-root user
USER mcp-mesh

ENTRYPOINT []
#+END_SRC

This means scaffolded agents only install their app-specific dependencies,
not the mesh SDK (already in base image).

**** Implementation Tasks

- [ ] Create =cmd/meshctl/internal/handlers/= directory
- [ ] Create =language.go= with =LanguageHandler= interface
- [ ] Create =python_handler.go= (extract from current code)
- [ ] Create =typescript_handler.go= (new implementation)
- [ ] Add TypeScript templates to =cmd/meshctl/templates/typescript/=
- [ ] Update scaffold command to use handler pattern
- [ ] Add TypeScript Dockerfile template
- [ ] Add TypeScript helm values template

*** meshctl scaffold --compose

**** Current Behavior

Scans directory for =.py= files, parses =@mesh.agent= decorator to extract:
- Agent name
- Port
- Capabilities

**** New Behavior (Language Detection)

#+BEGIN_SRC bash
meshctl scaffold --compose
# Auto-detects language per subdirectory:
# ./calculator/       -> Python (has main.py)
# ./smart-assistant/  -> TypeScript (has package.json)
#+END_SRC

**** TypeScript Agent Parsing

Extract agent info from TypeScript files:

#+BEGIN_SRC typescript
// Pattern to detect:
const agent = mesh(server, {
  name: "calculator",
  port: 9002,
});
#+END_SRC

Parser needs to extract:
- =name= from config object
- =port= from config object
- Tool names from =agent.addTool()= or =server.addTool(mesh.llm(...))=

**** Implementation Tasks

- [ ] Add =ParseAgentFile()= to TypeScript handler
- [ ] Use regex or simple AST parsing for config extraction
- [ ] Support both =mesh()= and =mesh.route()= patterns
- [ ] Update compose generation to use handlers

*** meshctl start

**** Current Behavior (Python)

#+BEGIN_SRC bash
meshctl start agent.py
# 1. Checks .venv exists in PWD
# 2. Checks mcp-mesh package installed
# 3. Runs: .venv/bin/python agent.py
#+END_SRC

**** New Behavior (Auto-Detection)

#+BEGIN_SRC bash
# Auto-detect by extension
meshctl start agent.py        # Python
meshctl start agent.ts        # TypeScript
meshctl start agent/          # Detect by directory contents

# Explicit override (rare)
meshctl start --lang python agent.py
meshctl start --lang typescript src/index.ts
#+END_SRC

**** TypeScript Prerequisites Check

#+BEGIN_SRC go
func (h *TypeScriptHandler) ValidatePrerequisites(dir string) error {
    // 1. Check node_modules exists
    if !fileExists(filepath.Join(dir, "node_modules")) {
        return fmt.Errorf("node_modules not found. Run: npm install")
    }

    // 2. Check @mcpmesh/sdk installed
    pkgJson := filepath.Join(dir, "package.json")
    if !hasDependency(pkgJson, "@mcpmesh/sdk") {
        return fmt.Errorf("@mcpmesh/sdk not found. Run: npm install @mcpmesh/sdk")
    }

    // 3. Check TypeScript compiled (if .ts file)
    // OR use ts-node/tsx for development

    return nil
}
#+END_SRC

**** TypeScript Start Command

#+BEGIN_SRC go
func (h *TypeScriptHandler) GetStartCommand(file string) []string {
    if strings.HasSuffix(file, ".ts") {
        // Development: use tsx (fast TypeScript execution)
        return []string{"npx", "tsx", file}
    }
    // Production: use compiled JS
    return []string{"node", file}
}
#+END_SRC

**** Implementation Tasks

- [ ] Add language detection to start command
- [ ] Implement TypeScript prerequisites check
- [ ] Implement TypeScript start command (tsx for .ts, node for .js)
- [ ] Update PID file handling for both languages
- [ ] Test detached mode with TypeScript agents

*** meshctl stop

**** Current Behavior

- Stops agents started with =--detach= flag
- Uses PID files stored in =~/.mcp-mesh/pids/=
- Works via =kill= syscall

**** Analysis

Stop is language-agnostic since it uses PID files:

#+BEGIN_EXAMPLE
~/.mcp-mesh/pids/
├── calculator.pid      # Contains PID
├── smart-assistant.pid
└── registry.pid
#+END_EXAMPLE

No changes needed for TypeScript support - as long as start creates PID files
correctly, stop will work.

**** Implementation Tasks

- [ ] Verify PID file creation in TypeScript start path
- [ ] Test stop with TypeScript agents

*** meshctl list / status

**** Current Output

#+BEGIN_EXAMPLE
$ meshctl list
NAME              PORT   STATUS    DEPS      CAPABILITIES
calculator        9002   healthy   0/0       add, subtract
smart-assistant   9003   healthy   1/1       assist
#+END_EXAMPLE

**** New Output (with Runtime Column)

#+BEGIN_EXAMPLE
$ meshctl list
NAME              RUNTIME     PORT   STATUS    DEPS      CAPABILITIES
calculator        python      9002   healthy   0/0       add, subtract
smart-assistant   typescript  9003   healthy   1/1       assist
api-gateway       typescript  4000   healthy   2/2       GET:/time, GET:/status
#+END_EXAMPLE

**** meshctl list --wide

#+BEGIN_EXAMPLE
$ meshctl list --wide
NAME              RUNTIME     PORT   STATUS    DEPS   ENDPOINT                      TOOLS
calculator        python      9002   healthy   0/0    http://localhost:9002/mcp     2
smart-assistant   typescript  9003   healthy   1/1    http://localhost:9003/mcp     1
#+END_EXAMPLE

**** Implementation Tasks

- [ ] Add =runtime= field to registry API response (from DB)
- [ ] Add =RUNTIME= column to list table output
- [ ] Add =runtime= to JSON output
- [ ] Add =runtime= to status output
- [ ] Color-code by runtime (optional): Python=green, TypeScript=blue

*** meshctl man (Manual Pages)

**** Current Behavior

Manual pages are Python-focused with Python examples.

**** New Behavior

- Default: Python examples (backwards compatible)
- =--typescript= flag: Show TypeScript examples
- Footer note: "See also: meshctl man <topic> --typescript"

#+BEGIN_SRC bash
meshctl man decorators              # Python examples (default)
meshctl man decorators --typescript # TypeScript examples

meshctl man deployment              # Python Dockerfile examples
meshctl man deployment --typescript # TypeScript Dockerfile examples
#+END_SRC

**** Topics Needing TypeScript Variants

| Topic | Python Content | TypeScript Content |
|-------|----------------|-------------------|
| decorators | =@mesh.tool=, =@mesh.llm= | =mesh()=, =mesh.llm()=, =mesh.route()= |
| llm | LLM integration with Python | LLM integration with TypeScript |
| deployment | Python Dockerfile, helm | TypeScript Dockerfile, helm |
| testing | Python curl examples | TypeScript curl examples |
| quickstart | Python hello world | TypeScript hello world |

**** Implementation

#+BEGIN_SRC go
// In man command
var typescriptFlag bool

func init() {
    manCmd.Flags().BoolVar(&typescriptFlag, "typescript", false,
        "Show TypeScript examples instead of Python")
}

func getManPage(topic string) string {
    if typescriptFlag {
        return manPages[topic + "_typescript"]
    }
    content := manPages[topic]
    // Append footer
    return content + "\n\nSee also: meshctl man " + topic + " --typescript"
}
#+END_SRC

**** Implementation Tasks

- [ ] Add =--typescript= flag to man command
- [ ] Create TypeScript variants for key topics
- [ ] Add footer note to Python man pages
- [ ] Update embedded man page content

*** Implementation Summary

**** Pre-requisite: Runtime Field
- [ ] Add runtime to OpenAPI spec
- [ ] Update Go registry handlers
- [ ] Add runtime to Ent schema
- [ ] Add RuntimeType to Rust core
- [ ] Update napi.rs bindings (default: typescript)
- [ ] Update pyo3 bindings (default: python)
- [ ] Rebuild SDKs and test

**** Language Handler Pattern
- [ ] Create =LanguageHandler= interface
- [ ] Extract Python handler from existing code
- [ ] Implement TypeScript handler
- [ ] Add detection logic

**** meshctl scaffold
- [ ] TypeScript templates (tool, llm-agent, llm-provider)
- [ ] TypeScript Dockerfile template
- [ ] TypeScript helm values template
- [ ] Update scaffold to use handlers

**** meshctl scaffold --compose
- [ ] TypeScript agent file parsing
- [ ] Mixed-language compose generation

**** meshctl start
- [ ] Language auto-detection
- [ ] TypeScript prerequisites check
- [ ] TypeScript start command (tsx/node)
- [ ] PID file handling

**** meshctl list/status
- [ ] Add RUNTIME column
- [ ] Update JSON output

**** meshctl man
- [ ] Add =--typescript= flag
- [ ] Create TypeScript man page variants
- [ ] Add footer notes

Deliverable: Full CLI support for TypeScript agents with runtime visibility

* Technical Debt / Refactoring

Items identified during code review that should be addressed:

** DONE Duplicate SSE Parsing Logic [HIGH]
:PROPERTIES:
:FILE: src/runtime/typescript/src/llm-agent.ts
:LINES: 251-268, 758-774
:END:

SSE (Server-Sent Events) parsing code is duplicated in two places:
- =MeshDelegatedProvider.complete()= - parses SSE response from LLM provider
- =createLlmToolProxy()= - parses SSE response from tool calls

*Current code (duplicated):*
#+BEGIN_SRC typescript
// Check if it's SSE format (starts with "event:")
if (responseText.startsWith("event:")) {
  const lines = responseText.split("\n");
  let jsonData = "";
  for (const line of lines) {
    if (line.startsWith("data: ")) {
      jsonData = line.slice(6);
    }
  }
  if (!jsonData) {
    throw new Error("No data in SSE response");
  }
  result = JSON.parse(jsonData);
} else {
  result = JSON.parse(responseText);
}
#+END_SRC

*Recommended fix:* Extract to shared utility function:
#+BEGIN_SRC typescript
// In a new file: src/runtime/typescript/src/sse.ts
export function parseSSEResponse<T>(responseText: string): T {
  if (responseText.startsWith("event:")) {
    const lines = responseText.split("\n");
    let jsonData = "";
    for (const line of lines) {
      if (line.startsWith("data: ")) {
        jsonData = line.slice(6);
      }
    }
    if (!jsonData) {
      throw new Error("No data in SSE response");
    }
    return JSON.parse(jsonData);
  }
  return JSON.parse(responseText);
}
#+END_SRC

** DONE Duplicate ResponseParseError Class [MEDIUM]
:PROPERTIES:
:FILES: src/runtime/typescript/src/errors.ts, src/runtime/typescript/src/response-parser.ts
:END:

Two different =ResponseParseError= classes exist with different shapes:

| File | Properties |
|------|------------|
| errors.ts | =rawContent=, =cause: Error=, =expectedSchema?= |
| response-parser.ts | =rawContent=, =zodError?: ZodErrorType= |

*Recommended fix:* Consolidate into single class in =errors.ts=:
#+BEGIN_SRC typescript
export class ResponseParseError extends Error {
  readonly name = "ResponseParseError";
  constructor(
    public readonly rawContent: string,
    public readonly cause?: Error,
    public readonly zodError?: ZodErrorType,
    public readonly expectedSchema?: unknown
  ) {
    super(`Failed to parse LLM response: ${cause?.message ?? "unknown error"}`);
  }
}
#+END_SRC

Then update =response-parser.ts= to import from =errors.ts=.

** DONE Debug Logging Should Be Configurable [MEDIUM]
:PROPERTIES:
:FILES: src/runtime/typescript/src/llm-agent.ts, src/runtime/typescript/src/llm.ts
:END:

Many =console.log= statements throughout the LLM code:
- =[mesh.llm] Executing...=
- =[mesh.llm] Tools: X, Provider: Y=
- =[mesh.llm] Raw provider response...=
- =[mesh.llm] SSE parsed JSON...=

*Recommended fix:* Add debug flag or use existing tracing infrastructure:
#+BEGIN_SRC typescript
// Option 1: Environment variable
const DEBUG = process.env.MESH_LLM_DEBUG === "true";

function debug(message: string, ...args: unknown[]) {
  if (DEBUG) console.log(message, ...args);
}

// Option 2: Use tracing module
import { publishTraceSpan } from "./tracing.js";
#+END_SRC

** DONE MeshLlmAgent Created on Every Tool Call [LOW]
:PROPERTIES:
:FILE: src/runtime/typescript/src/llm.ts
:LINES: 249-263
:END:

In =wrappedExecute=, a new =MeshLlmAgent= instance is created for every tool
invocation, even though the config is static.

*Current code:*
#+BEGIN_SRC typescript
const wrappedExecute = async (args) => {
  // Created every time!
  const agent = new MeshLlmAgent({
    functionId,
    provider: llmConfig.provider,
    // ... static config
  });
  // ...
};
#+END_SRC

*Recommended fix:* Create agent once at registration time:
#+BEGIN_SRC typescript
// Create once
const agent = new MeshLlmAgent({ functionId, provider, ... });

const wrappedExecute = async (args) => {
  // Reuse existing agent
  const llmCallable = agent.createCallable({ tools, meshProvider, ... });
  // ...
};
#+END_SRC

*Note:* Need to verify =MeshLlmAgent= is stateless enough for reuse (check
=_systemPromptOverride= and =_meta= state).

** DONE Template Cache Key Uses Raw Path [LOW]
:PROPERTIES:
:FILE: src/runtime/typescript/src/template.ts
:LINES: 85-86
:END:

For file templates, the cache key is the original =file://...= string, not the
resolved absolute path. This means the same file accessed via different relative
paths won't share the cache.

*Current code:*
#+BEGIN_SRC typescript
const cacheKey = template;  // "file://prompts/foo.hbs"
const cached = templateCache.get(cacheKey);
#+END_SRC

*Recommended fix:* Use resolved absolute path as cache key:
#+BEGIN_SRC typescript
let cacheKey = template;
if (isFileTemplate(template)) {
  const filePath = extractFilePath(template);
  cacheKey = resolveTemplatePath(filePath);  // Absolute path
}
const cached = templateCache.get(cacheKey);
#+END_SRC

* References

- fastmcp TypeScript: https://github.com/punkpeye/fastmcp
- mcp-proxy: https://github.com/punkpeye/mcp-proxy
- napi-rs: https://napi.rs/
- MCP Specification: https://modelcontextprotocol.info/
