#+TITLE: MCP Mesh TypeScript SDK Design
#+AUTHOR: MCP Mesh Contributors
#+DATE: 2026-01-08
#+OPTIONS: toc:3 num:t

* Overview

This document outlines the design for the MCP Mesh TypeScript SDK, enabling TypeScript/Node.js developers to build MCP Mesh agents with the same developer experience as the Python SDK.

** Goals

1. Provide a clean, idiomatic TypeScript API for building MCP Mesh agents
2. Match the Python SDK's "no boilerplate" experience (no main function needed)
3. Leverage fastmcp (TypeScript) as the underlying MCP framework
4. Connect to Rust core for heartbeat/topology management (via napi-rs)

** Non-Goals

1. Replacing the Python SDK
2. Supporting browser environments (Node.js only)
3. Reimplementing Rust core logic in TypeScript (integrate, don't recreate)

* Key Decisions

| Decision              | Choice                                                    |
|-----------------------+-----------------------------------------------------------|
| Package name          | =@mcpmesh/sdk= (alongside existing =@mcpmesh/cli=)        |
| Repository            | Same repo (mcp-mesh)                                      |
| Location              | =src/runtime/typescript/= (parallel to =python/=)         |
| Rust integration      | napi-rs bindings in =src/runtime/core/typescript/=        |
| Phase 1 scope         | =mesh.tool= equivalent (MCP agents)                       |
| Phase 2 scope         | =mesh.route= for Express routes (REST APIs)               |
| LLM/LLM Provider      | Deferred to Phase 3                                       |
| CLI tooling           | Use existing Go-based =meshctl= (TS support in Phase 4)   |

* Package Structure

#+BEGIN_EXAMPLE
src/runtime/
├── core/                    # Rust core
│   ├── src/                 # Rust source (ffi.rs, heartbeat.rs, runtime.rs, etc.)
│   ├── python/              # PyO3 bindings (existing) - mcp_mesh_core
│   ├── typescript/          # napi-rs bindings (new)
│   ├── pyproject.toml       # maturin config for Python
│   └── Cargo.toml
├── python/                  # Python SDK - mesh package (existing)
└── typescript/              # TypeScript SDK - @mcpmesh/sdk (new)
    ├── package.json
    ├── tsconfig.json
    ├── src/
    │   └── index.ts
    └── README.md
#+END_EXAMPLE

* Current Python Agent Patterns

** Test Agents in Repository

| Agent            | Type         | Decorators Used                      | Port |
|------------------+--------------+--------------------------------------+------|
| calculator       | Tool Provider | @mesh.tool, @mesh.agent              | 9002 |
| smart-assistant  | LLM Agent    | @mesh.tool, @mesh.llm, @mesh.agent   | 9003 |
| openai-provider  | LLM Provider | @mesh.llm_provider, @mesh.agent      | 9004 |
| claude-provider  | LLM Provider | @mesh.llm_provider, @mesh.agent      | 9001 |

** Python Calculator Example

#+BEGIN_SRC python
import mesh
from fastmcp import FastMCP

app = FastMCP("Calculator Service")

@app.tool()
@mesh.tool(
    capability="add",
    description="Add two numbers together",
    tags=["tools", "math"],
)
async def add(a: float, b: float) -> float:
    return a + b

@mesh.agent(
    name="calculator",
    version="1.0.0",
    http_port=9002,
    auto_run=True,
)
class CalculatorAgent:
    pass

# No main method needed!
#+END_SRC

** Python Auto-Start Mechanism

#+BEGIN_EXAMPLE
User writes code → @mesh.agent(auto_run=True) applied
                             ↓
                   _trigger_debounced_processing()
                             ↓
                   Wait 1 second (debounce)
                             ↓
                   StartupPipeline.execute()
                             ↓
                   uvicorn.run() (blocks main thread)
#+END_EXAMPLE

Key files:
- =src/runtime/python/mesh/decorators.py= - Decorator implementations
- =src/runtime/python/_mcp_mesh/pipeline/mcp_startup/startup_orchestrator.py= - Pipeline

* fastmcp TypeScript Research

** Source

- GitHub: https://github.com/punkpeye/fastmcp
- npm: https://www.npmjs.com/package/fastmcp
- Version: 3.26.8 (as of 2026-01-08)

** Key Features

- Tool, Resource, and Prompt definitions
- Authentication and sessions
- SSE and HTTP Streaming transports
- Zod/ArkType/Valibot schema validation
- Built-in CLI for testing (=npx fastmcp dev=)

** Basic Tool Definition

#+BEGIN_SRC typescript
import { FastMCP } from "fastmcp";
import { z } from "zod";

const server = new FastMCP({
  name: "My Server",
  version: "1.0.0",
});

server.addTool({
  name: "add",
  description: "Add two numbers",
  parameters: z.object({
    a: z.number(),
    b: z.number(),
  }),
  execute: async (args) => {
    return String(args.a + args.b);
  },
});

server.start({ transportType: "stdio" });
#+END_SRC

** Transport Options

#+BEGIN_SRC typescript
// Stdio transport (default)
server.start({ transportType: "stdio" });

// HTTP Streaming transport
server.start({
  transportType: "httpStream",
  httpStream: {
    port: 8080,
    endpoint: "/mcp",
  },
});
#+END_SRC

** Context and Session

#+BEGIN_SRC typescript
server.addTool({
  name: "download",
  parameters: z.object({ url: z.string() }),
  execute: async (args, { log, session, sessionId, requestId }) => {
    log.info("Downloading file...", { url: args.url });
    return "done";
  },
});
#+END_SRC

** HTTP Server Stack

fastmcp uses =mcp-proxy= library internally:
- =startHTTPServer()= from mcp-proxy
- Supports health check endpoints (=/health=, =/ready=)
- OAuth discovery endpoints
- Session lifecycle management

* TypeScript SDK Design

** Architecture

#+BEGIN_EXAMPLE
┌─────────────────────────────────────────────────────────┐
│                    User Code                            │
│  const agent = mesh(server, { name: "calc", port: 9002 })│
│  agent.addTool({ capability: "add", ... })              │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                  @mcpmesh/sdk                           │
│  - MeshAgent class (wraps FastMCP)                      │
│  - Auto-start via process.nextTick()                    │
│  - Heartbeat management                                 │
│  - Dependency injection                                 │
└─────────────────────────────────────────────────────────┘
                           │
              ┌────────────┴────────────┐
              ▼                         ▼
┌─────────────────────────┐   ┌─────────────────────────┐
│      fastmcp (TS)       │   │    mcp-mesh-core        │
│  - MCP protocol         │   │    (Rust via napi-rs)   │
│  - Tool/Resource/Prompt │   │  - Heartbeat loop       │
│  - HTTP/SSE transport   │   │  - Topology management  │
└─────────────────────────┘   │  - Registry client      │
              │               └─────────────────────────┘
              ▼
┌─────────────────────────┐
│      mcp-proxy          │
│  - HTTP server          │
│  - Session management   │
└─────────────────────────┘
#+END_EXAMPLE

** Core Implementation

#+BEGIN_SRC typescript
// @mcpmesh/sdk/src/index.ts

import { FastMCP } from "fastmcp";
import { z } from "zod";

// Types
export interface AgentConfig {
  name: string;
  version?: string;
  port: number;
  namespace?: string;
  registryUrl?: string;
}

export interface MeshToolDef<T extends z.ZodType = z.ZodType> {
  name: string;
  capability?: string;
  description?: string;
  tags?: string[];
  dependencies?: string[];
  parameters: T;
  execute: (args: z.infer<T>) => Promise<string> | string;
}

// Internal: pending agent for auto-start
let pendingAgent: MeshAgent | null = null;

// Auto-start after module loading completes
process.nextTick(() => {
  if (pendingAgent) {
    pendingAgent._autoStart().catch((err) => {
      console.error("MCP Mesh auto-start failed:", err);
      process.exit(1);
    });
  }
});

export class MeshAgent {
  private server: FastMCP;
  private config: AgentConfig;
  private tools: Map<string, { capability: string; tags: string[] }> = new Map();

  constructor(server: FastMCP, config: AgentConfig) {
    this.server = server;
    this.config = {
      version: "1.0.0",
      namespace: "default",
      registryUrl: process.env.MCP_MESH_REGISTRY_URL || "http://localhost:8000",
      ...config,
    };
    pendingAgent = this;
  }

  addTool<T extends z.ZodType>(def: MeshToolDef<T>): this {
    // Register with fastmcp
    this.server.addTool({
      name: def.name,
      description: def.description,
      parameters: def.parameters,
      execute: def.execute,
    });

    // Store mesh metadata
    this.tools.set(def.name, {
      capability: def.capability || def.name,
      tags: def.tags || [],
    });

    return this;
  }

  async _autoStart(): Promise<void> {
    console.log(`Starting MCP Mesh agent: ${this.config.name}`);

    // 1. Start HTTP server via fastmcp
    this.server.start({
      transportType: "httpStream",
      httpStream: { port: this.config.port },
    });

    console.log(`Agent listening on port ${this.config.port}`);

    // 2. Start heartbeat to registry (via Rust core)
    await this.startHeartbeat();
  }

  private async startHeartbeat(): Promise<void> {
    // TODO: Connect to Rust core via napi-rs
    // For now, use JS implementation
    const capabilities = Array.from(this.tools.entries()).map(([name, meta]) => ({
      name,
      capability: meta.capability,
      tags: meta.tags,
    }));

    console.log(`Registered ${capabilities.length} capabilities with registry`);

    // Heartbeat loop placeholder
    setInterval(() => {
      // POST to registry
    }, 5000);
  }
}

// User-facing wrapper function
export function mesh(server: FastMCP, config: AgentConfig): MeshAgent {
  return new MeshAgent(server, config);
}
#+END_SRC

** User Code Example

#+BEGIN_SRC typescript
// calculator/index.ts
import { FastMCP } from "fastmcp";
import { mesh } from "@mcpmesh/sdk";
import { z } from "zod";

const server = new FastMCP({ name: "Calculator", version: "1.0.0" });

const agent = mesh(server, {
  name: "calculator",
  port: 9002,
});

agent.addTool({
  name: "add",
  capability: "add",
  tags: ["tools", "math"],
  description: "Add two numbers together",
  parameters: z.object({ a: z.number(), b: z.number() }),
  execute: async ({ a, b }) => String(a + b),
});

agent.addTool({
  name: "subtract",
  capability: "subtract",
  tags: ["tools", "math"],
  parameters: z.object({ a: z.number(), b: z.number() }),
  execute: async ({ a, b }) => String(a - b),
});

// No server.start() or main function needed!
// The SDK auto-starts after module loading completes
#+END_SRC

* Stack Comparison

| Layer              | Python                | TypeScript            |
|--------------------+-----------------------+-----------------------|
| MCP Framework      | fastmcp (Python)      | fastmcp (TS)          |
| HTTP Server        | uvicorn + FastAPI     | mcp-proxy (built-in)  |
| REST Integration   | FastAPI (@mesh.route) | Express (mesh.route)  |
| Auto-start trigger | @mesh.agent decorator | process.nextTick()    |
| Debounce           | threading.Timer       | setTimeout            |
| Heartbeat          | Rust core (PyO3)      | Rust core (napi-rs)   |
| Schema validation  | Type hints + Pydantic | Zod/ArkType/Valibot   |

* Rust Core Bindings

** Binding Strategy

Use napi-rs for TypeScript SDK (mirrors PyO3 approach for Python):

| Language   | Binding Tool | Location                          |
|------------+--------------+-----------------------------------|
| Python     | PyO3/maturin | =src/runtime/core/python/=        |
| TypeScript | napi-rs      | =src/runtime/core/typescript/=    |

** napi-rs Implementation

Bindings will expose same functions as PyO3:
- =mesh_start_agent()= - Start agent runtime
- =mesh_next_event()= - Get next topology event
- =mesh_stop_agent()= - Stop agent runtime

* Implementation Phases

** Target: User Code Example

The goal is to enable this developer experience:

#+BEGIN_SRC typescript
import { FastMCP } from "fastmcp";
import { mesh } from "@mcpmesh/sdk";
import { z } from "zod";

const server = new FastMCP({ name: "Calculator", version: "1.0.0" });

const agent = mesh(server, {
  name: "calculator",
  port: 9002,
});

agent.addTool({
  name: "add",
  capability: "add",
  tags: ["tools", "math"],
  description: "Add two numbers together",
  parameters: z.object({ a: z.number(), b: z.number() }),
  execute: async ({ a, b }) => String(a + b),
});

// No server.start() or main function needed!
#+END_SRC

** Phase 1: TypeScript SDK with Rust Core [COMPLETED]

- [X] Add napi-rs bindings to Rust core (=src/runtime/core/=)
- [X] Create =@mcpmesh/core= package for napi-rs output
- [X] Create =src/runtime/typescript/= directory structure (=@mcpmesh/sdk=)
- [X] Implement =MeshAgent= class wrapping fastmcp
- [X] Implement auto-start via =process.nextTick()=
- [X] Connect to Rust core for heartbeat (via napi-rs)
- [X] Implement =mesh.tool= equivalent (=agent.addTool()=)
- [X] Implement dependency injection for tools
- [X] Implement distributed tracing (OTel-compliant)

Deliverable: TypeScript agents can run and register with mesh using Rust core

** Phase 2: Express Middleware Integration [COMPLETED]

Add =mesh.route= for injecting mesh dependencies into Express routes.

*** User Experience

Zero-boilerplate API development - no =mesh.bind()= or manual initialization:

#+BEGIN_SRC typescript
import express from "express";
import { mesh } from "@mcpmesh/sdk";

const app = express();
app.use(express.json());

// mesh.route() triggers auto-init - no mesh.bind() or start() needed!
app.get("/time", mesh.route(
  [{ capability: "time_service" }],
  async (req, res, { time_service }) => {
    if (!time_service) {
      return res.status(503).json({ error: "Service unavailable" });
    }
    const result = await time_service({});
    res.json({ time: result });
  }
));

// Multiple dependencies
app.get("/status", mesh.route(
  [{ capability: "time_service" }, { capability: "system_info_service" }],
  async (req, res, { time_service, system_info_service }) => {
    const results = {};
    if (time_service) results.time = await time_service({});
    if (system_info_service) results.system = await system_info_service({});
    res.json(results);
  }
));

// Works with existing middleware (auth, session, etc.)
app.post("/protected",
  requireAuth,
  mesh.route(
    [{ capability: "calculator" }],
    async (req, res, { calculator }) => {
      // req.session, req.user etc. still available
      const result = await calculator({ a: req.body.a, b: req.body.b });
      res.json({ result, user: req.session.user });
    }
  )
);

app.listen(4000);  // That's it - fully automatic!
#+END_SRC

*** Architecture

#+BEGIN_EXAMPLE
┌─────────────────────────────────────────────────────────────────────┐
│                         Express App                                  │
│   app.get("/time", mesh.route([deps], handler))                     │
│   app.listen(4000)                                                  │
└─────────────────────────────────────────────────────────────────────┘
                                │
                    mesh.route() called
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     RouteRegistry                                    │
│   - Stores route metadata with placeholder IDs                      │
│   - route_0_UNKNOWN:UNKNOWN, route_1_UNKNOWN:UNKNOWN, ...           │
└─────────────────────────────────────────────────────────────────────┘
                                │
                    process.nextTick()
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      ApiRuntime                                      │
│   - Starts Rust core with initial tools                             │
│   - Sends first heartbeat with UNKNOWN route names                  │
│   - Installs SIGINT/SIGTERM handlers                                │
└─────────────────────────────────────────────────────────────────────┘
                                │
                    First HTTP request
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                   Auto-Detection (on first request)                  │
│   - Extract port from req.socket.localPort                          │
│   - Introspect routes from req.app._router                          │
│   - Update route names: GET:/time, GET:/status, POST:/protected     │
│   - Call Rust core's updateTools() and updatePort()                 │
└─────────────────────────────────────────────────────────────────────┘
                                │
                    Smart diffing in Rust
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      Rust Core                                       │
│   - Compares new tools with cached tools                            │
│   - Only sends heartbeat if tools actually changed                  │
│   - Registry receives proper route names                            │
└─────────────────────────────────────────────────────────────────────┘
#+END_EXAMPLE

*** Key Implementation Details

**** Auto-Initialization Flow

1. =mesh.route()= is called during Express route registration
2. Routes stored in =RouteRegistry= with placeholder IDs (=route_X_UNKNOWN:UNKNOWN=)
3. =ApiRuntime.scheduleStart()= queues startup via =process.nextTick()=
4. After all routes registered, =ApiRuntime.start()= runs:
   - Generates unique service ID (=api-<random>=)
   - Initializes distributed tracing
   - Starts Rust core with initial tool specs
   - Begins event loop for dependency resolution
   - Installs graceful shutdown handlers

**** Express Route Introspection

On first HTTP request, auto-detection runs once:

#+BEGIN_SRC typescript
function performExpressAutoDetection(req: Request): void {
  // Get port from socket
  const port = req.socket?.localPort || 0;

  // Get Express app from request
  const app = req.app;

  // Introspect routes from app._router (Express 4) or app.router (Express 5)
  const routeCount = introspectExpressRoutes(app);

  // Update Rust core with detected info
  getApiRuntime().updateExpressInfo(port, routeCount);
}
#+END_SRC

**** Dynamic Tools Update (Rust Core)

Added =RuntimeCommand= enum for SDK-to-runtime communication:

#+BEGIN_SRC rust
pub enum RuntimeCommand {
    UpdateTools(Vec<ToolSpec>),
    UpdatePort(u16),
}
#+END_SRC

Smart diffing prevents unnecessary heartbeats:

#+BEGIN_SRC rust
fn tools_are_different(old: &[ToolSpec], new: &[ToolSpec]) -> bool {
    if old.len() != new.len() {
        return true;
    }
    for (o, n) in old.iter().zip(new.iter()) {
        if o.function_name != n.function_name
            || o.capability != n.capability
            || o.dependencies.len() != n.dependencies.len()
        {
            return true;
        }
    }
    false
}
#+END_SRC

**** Graceful Shutdown

Signal handlers properly cleanup and exit:

#+BEGIN_SRC typescript
process.on("SIGINT", async () => {
  console.log("\nReceived SIGINT, shutting down...");
  await runtime.shutdown();  // Unregisters from registry
  process.exit(0);
});
#+END_SRC

*** Files Implemented

| File                                    | Purpose                                    |
|-----------------------------------------+--------------------------------------------|
| =src/runtime/typescript/src/route.ts=   | =mesh.route()= Express middleware          |
| =src/runtime/typescript/src/api-runtime.ts= | API runtime singleton, auto-start      |
| =src/runtime/typescript/src/proxy.ts=   | Dependency proxy for calling services     |
| =src/runtime/core/src/runtime.rs=       | =RuntimeCommand= enum, smart diffing       |
| =src/runtime/core/src/handle.rs=        | =update_tools()=, =update_port()= methods  |
| =src/runtime/core/src/napi.rs=          | JS bindings for update methods            |

*** Completed Tasks

- [X] Implement =mesh.route()= wrapper for Express routes
- [X] Support dependency resolution via registry
- [X] Integrate with existing Express middleware chain
- [X] Add distributed tracing support for HTTP routes
- [X] Auto-initialization via =process.nextTick()= (no =mesh.bind()= needed)
- [X] Auto-detection of port and routes on first HTTP request
- [X] Express route introspection (=app._router= / =app.router=)
- [X] Dynamic tools update in Rust core (=updateTools()=, =updatePort()=)
- [X] Smart diffing - only heartbeat if tools changed
- [X] Graceful shutdown with SIGINT/SIGTERM handlers
- [X] Route ID mapping for dependency resolution during transition

*** Example: Database Output

After first HTTP request, the =dependency_resolutions= table shows proper route names:

#+BEGIN_EXAMPLE
consumer_function_name | capability_required |  provider_function_name  |  status
------------------------+---------------------+--------------------------+-----------
 GET:/time              | time_service        | get_current_time         | available
 GET:/status            | time_service        | get_current_time         | available
 GET:/status            | system_info_service | get_enriched_system_info | available
 GET:/system            | system_info_service | get_enriched_system_info | available
#+END_EXAMPLE

Deliverable: TypeScript REST APIs can use mesh dependencies via Express with zero boilerplate

** Phase 3: LLM Agent Support [COMPLETED]

Implement =mesh.llm()= for LLM-powered tools with agentic loops and mesh tool access.

*** User Experience

#+BEGIN_SRC typescript
import { FastMCP } from "fastmcp";
import { mesh } from "@mcpmesh/sdk";
import { z } from "zod";

const server = new FastMCP({ name: "Smart Assistant", version: "1.0.0" });

// Define response schema with Zod
const AssistResponse = z.object({
  answer: z.string(),
  confidence: z.number(),
  sources: z.array(z.string()),
});

// LLM-powered tool with mesh tool access
server.addTool(mesh.llm({
  name: "assist",
  capability: "smart_assistant",
  description: "LLM-powered assistant with tool access",

  // LLM Configuration
  provider: "claude",                              // Direct LiteLLM provider
  // OR mesh delegation:
  // provider: { capability: "llm", tags: ["+claude"] },

  model: "anthropic/claude-sonnet-4-20250514",     // Override model
  maxIterations: 10,                               // Agentic loop limit

  // System prompt (inline or template file)
  systemPrompt: "file://prompts/assistant.hbs",   // Handlebars template
  contextParam: "ctx",                             // Links to template context

  // Tool filtering - which mesh tools the LLM can access
  filter: [{ capability: "calculator" }, { tags: ["tools"] }],
  filterMode: "all",                               // "all" | "best_match" | "*"

  // LiteLLM parameters
  maxTokens: 4096,
  temperature: 0.7,

  // Input/output schemas
  parameters: z.object({
    message: z.string(),
    ctx: AssistContext,  // Context for template rendering
  }),
  returns: AssistResponse,  // Structured output via Zod

  // Handler receives injected LLM agent
  execute: async ({ message, ctx }, { llm }) => {
    // Simple call - returns AssistResponse
    return await llm(message);

    // With runtime context override
    // return await llm(message, { context: { extra: "data" } });

    // With model parameter override
    // return await llm(message, { maxTokens: 8000 });
  },
}));

const agent = mesh(server, { name: "smart-assistant", port: 9003 });
#+END_SRC

*** Architecture

#+BEGIN_EXAMPLE
┌─────────────────────────────────────────────────────────────────────────┐
│                         mesh.llm() Decorator                             │
│   - Wraps fastmcp tool definition                                       │
│   - Extracts LLM config (provider, filter, systemPrompt, etc.)          │
│   - Registers with DecoratorRegistry                                    │
└─────────────────────────────────────────────────────────────────────────┘
                                │
                    process.nextTick() auto-start
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         Rust Core (napi-rs)                              │
│   - JsLlmAgentSpec: { functionId, filter, filterMode, provider }        │
│   - Sends llm_filter/llm_provider in heartbeat                          │
│   - Receives llm_tools from registry                                    │
│   - Emits "llm_tools_updated" events                                    │
└─────────────────────────────────────────────────────────────────────────┘
                                │
                    llm_tools_updated event
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                      MeshLlmAgentInjector                                │
│   - Creates tool proxies from resolved endpoints                        │
│   - Creates MeshLlmAgent instance with config + proxies                 │
│   - Injects into tool handler                                           │
└─────────────────────────────────────────────────────────────────────────┘
                                │
                    Tool invocation
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         MeshLlmAgent                                     │
│   1. Render system prompt (template + context)                          │
│   2. Build messages array                                               │
│   3. Agentic loop (max_iterations):                                     │
│      a. Call LLM (direct LiteLLM or mesh provider)                      │
│      b. If tool_calls → execute via proxies → add results → loop        │
│      c. Parse final response (Zod validation)                           │
│   4. Attach _meshMeta (tokens, latency)                                 │
└─────────────────────────────────────────────────────────────────────────┘
#+END_EXAMPLE

*** Implementation Tasks

**** Rust Core (napi-rs bindings)

- [X] Add =JsLlmAgentSpec= interface (functionId, filter, filterMode, provider, maxIterations)
- [X] Add =JsLlmToolInfo= interface (name, endpoint, inputSchema, description)
- [X] Add =JsLlmProviderInfo= interface (functionId, agentId, endpoint, functionName, model)
- [X] Extend =JsToolSpec= with =llmFilter= and =llmProvider= fields
- [X] Extend =JsAgentSpec= with =llmAgents= array
- [X] Extend =JsMeshEvent= with =tools= array and =providerInfo= for LLM events

**** TypeScript SDK

- [X] Implement =mesh.llm()= wrapper function
- [X] Implement =MeshLlmAgent= class (agentic loop, tool execution)
- [X] Implement =LlmToolRegistry= for DI from llm_tools_updated events
- [X] Implement =ResponseParser= (Zod schema validation, JSON extraction)
- [X] Implement template rendering (Handlebars with file support)
- [X] Implement provider handlers (LiteLLM + mesh delegation)
- [X] Add =LlmMeta= type for response metadata (tokens, latency)
- [X] Context injection (auto + runtime merge modes)
- [X] LLM event handling in MeshAgent (llm_tools_updated, llm_provider_available)

*** Files Created

| File | Purpose |
|------|---------|
| =src/runtime/core/src/napi.rs= | Extended with LLM types |
| =src/runtime/typescript/src/llm.ts= | =mesh.llm()= wrapper + LlmToolRegistry |
| =src/runtime/typescript/src/llm-agent.ts= | =MeshLlmAgent= class, providers |
| =src/runtime/typescript/src/response-parser.ts= | Zod validation |
| =src/runtime/typescript/src/template.ts= | Handlebars rendering (inline + file://) |
| =src/runtime/typescript/src/types.ts= | LLM type definitions |

*** Parameters Reference

| Parameter | Type | Description |
|-----------|------|-------------|
| =provider= | =string \| object= | ="claude"= (direct) or ={capability, tags}= (mesh) |
| =model= | =string= | LiteLLM model ID (e.g., ="anthropic/claude-sonnet-4-20250514"=) |
| =maxIterations= | =number= | Max agentic loop iterations (default: 10) |
| =systemPrompt= | =string= | Inline or =file://path/to/template.hbs= (Handlebars) |
| =contextParam= | =string= | Parameter name for template context |
| =filter= | =array= | Tool filter criteria =[{capability}, {tags}]= |
| =filterMode= | =string= | ="all"=, ="best_match"=, or ="*"= |
| =returns= | =ZodSchema= | Structured output schema (or omit for string) |
| =<litellm>= | =any= | maxTokens, temperature, topP, etc. |

Deliverable: TypeScript LLM agents with agentic loops and mesh tool access ✓

*** Next Items: Python Feature Parity

The following features are available in Python =mesh.llm()= but not yet in TypeScript.
These should be implemented to achieve full parity:

**** Multi-turn Conversation Support

| Python | TypeScript |
|--------|------------|
| =await llm([{"role": "user", "content": "Hi"}, ...])= | Single string only |

Python supports passing a list of message dicts for multi-turn conversations.
TypeScript currently only accepts a single string message.

#+BEGIN_SRC typescript
// Target API:
const response = await llm([
  { role: "user", content: "What is 5+3?" },
  { role: "assistant", content: "8" },
  { role: "user", content: "Now multiply that by 2" },
]);
#+END_SRC

**** Runtime Context Override

| Python | TypeScript |
|--------|------------|
| =context== parameter | Not implemented |
| =context_mode="merge"/"replace"= | Not implemented |

Python allows runtime context override and merge modes:

#+BEGIN_SRC python
# Python:
result = await llm("query", context={"extra": "data"}, context_mode="merge")
#+END_SRC

#+BEGIN_SRC typescript
// Target API:
const result = await llm("query", {
  context: { extra: "data" },
  contextMode: "merge",  // or "replace"
});
#+END_SRC

**** JSON Schema Injection in System Prompt

| Python | TypeScript |
|--------|------------|
| Auto-injects tool schemas | Not implemented |

Python automatically injects available tool JSON schemas into the system prompt,
helping the LLM understand tool capabilities. TypeScript should add this feature.

**** Typed Error Classes

| Python | TypeScript |
|--------|------------|
| =MaxIterationsError= | Generic errors |
| =ToolExecutionError= | Generic errors |
| =LLMAPIError= | Generic errors |

Python has specific exception types for different failure modes.
TypeScript should implement typed error classes:

#+BEGIN_SRC typescript
// Target implementation:
export class MaxIterationsError extends Error {
  constructor(public iterations: number, public lastResponse: unknown) {
    super(`Max iterations (${iterations}) reached`);
  }
}

export class ToolExecutionError extends Error {
  constructor(public toolName: string, public cause: Error) {
    super(`Tool '${toolName}' failed: ${cause.message}`);
  }
}

export class LLMAPIError extends Error {
  constructor(public statusCode: number, public body: string) {
    super(`LLM API error (${statusCode}): ${body}`);
  }
}
#+END_SRC

**** Runtime System Prompt Override

| Python | TypeScript |
|--------|------------|
| =set_system_prompt(prompt)= | Not implemented |

Python allows changing the system prompt at runtime:

#+BEGIN_SRC typescript
// Target API:
const { llm } = injected;
llm.setSystemPrompt("New instructions...");
const result = await llm("query");
#+END_SRC

**** Output Mode (strict/hint/text)

| Python | TypeScript |
|--------|------------|
| =output_mode="strict"= | Not implemented |
| =output_mode="hint"= | Not implemented |
| =output_mode="text"= | Not implemented |

Python supports different output modes that control how the LLM response
is parsed and validated against the schema:

- =strict=: Enforce exact schema compliance (use provider's native structured output)
- =hint=: Include schema in prompt but accept any response
- =text=: Return raw text without parsing

#+BEGIN_SRC typescript
// Target API:
const tool = mesh.llm({
  outputMode: "strict",  // | "hint" | "text"
  returns: ResponseSchema,
  // ...
});
#+END_SRC

**** Implementation Priority

| Priority | Feature | Complexity | Impact |
|----------|---------|------------|--------|
| High | Multi-turn conversation | Low | Enables chat-like interactions |
| High | Typed error classes | Low | Better error handling |
| Medium | Runtime context override | Medium | Flexible context injection |
| Medium | Output mode | Medium | Better schema enforcement |
| Medium | JSON schema injection | Medium | Improves tool usage |
| Low | Runtime system prompt | Low | Edge case utility |

Note: Provider handlers (vendor-specific optimizations) will be addressed in Phase 4
with =mesh.llmProvider()= implementation.

** Phase 4: LLM Provider Support (Future)

- [ ] Implement =mesh.llmProvider()= for LLM provider registration
- [ ] Health checks for LLM providers
- [ ] Vendor-specific optimizations (Claude strict mode, OpenAI response_format)
- [ ] Model override at consumer level

Deliverable: Zero-code LLM providers in TypeScript

** Phase 5: meshctl TypeScript Support (Future)

- [ ] Add =meshctl scaffold --language typescript= support
- [ ] Add =meshctl start= support for TypeScript agents
- [ ] TypeScript agent templates

Deliverable: Full CLI support for TypeScript agents

* Technical Debt / Refactoring

Items identified during code review that should be addressed:

** DONE Duplicate SSE Parsing Logic [HIGH]
:PROPERTIES:
:FILE: src/runtime/typescript/src/llm-agent.ts
:LINES: 251-268, 758-774
:END:

SSE (Server-Sent Events) parsing code is duplicated in two places:
- =MeshDelegatedProvider.complete()= - parses SSE response from LLM provider
- =createLlmToolProxy()= - parses SSE response from tool calls

*Current code (duplicated):*
#+BEGIN_SRC typescript
// Check if it's SSE format (starts with "event:")
if (responseText.startsWith("event:")) {
  const lines = responseText.split("\n");
  let jsonData = "";
  for (const line of lines) {
    if (line.startsWith("data: ")) {
      jsonData = line.slice(6);
    }
  }
  if (!jsonData) {
    throw new Error("No data in SSE response");
  }
  result = JSON.parse(jsonData);
} else {
  result = JSON.parse(responseText);
}
#+END_SRC

*Recommended fix:* Extract to shared utility function:
#+BEGIN_SRC typescript
// In a new file: src/runtime/typescript/src/sse.ts
export function parseSSEResponse<T>(responseText: string): T {
  if (responseText.startsWith("event:")) {
    const lines = responseText.split("\n");
    let jsonData = "";
    for (const line of lines) {
      if (line.startsWith("data: ")) {
        jsonData = line.slice(6);
      }
    }
    if (!jsonData) {
      throw new Error("No data in SSE response");
    }
    return JSON.parse(jsonData);
  }
  return JSON.parse(responseText);
}
#+END_SRC

** DONE Duplicate ResponseParseError Class [MEDIUM]
:PROPERTIES:
:FILES: src/runtime/typescript/src/errors.ts, src/runtime/typescript/src/response-parser.ts
:END:

Two different =ResponseParseError= classes exist with different shapes:

| File | Properties |
|------|------------|
| errors.ts | =rawContent=, =cause: Error=, =expectedSchema?= |
| response-parser.ts | =rawContent=, =zodError?: ZodErrorType= |

*Recommended fix:* Consolidate into single class in =errors.ts=:
#+BEGIN_SRC typescript
export class ResponseParseError extends Error {
  readonly name = "ResponseParseError";
  constructor(
    public readonly rawContent: string,
    public readonly cause?: Error,
    public readonly zodError?: ZodErrorType,
    public readonly expectedSchema?: unknown
  ) {
    super(`Failed to parse LLM response: ${cause?.message ?? "unknown error"}`);
  }
}
#+END_SRC

Then update =response-parser.ts= to import from =errors.ts=.

** DONE Debug Logging Should Be Configurable [MEDIUM]
:PROPERTIES:
:FILES: src/runtime/typescript/src/llm-agent.ts, src/runtime/typescript/src/llm.ts
:END:

Many =console.log= statements throughout the LLM code:
- =[mesh.llm] Executing...=
- =[mesh.llm] Tools: X, Provider: Y=
- =[mesh.llm] Raw provider response...=
- =[mesh.llm] SSE parsed JSON...=

*Recommended fix:* Add debug flag or use existing tracing infrastructure:
#+BEGIN_SRC typescript
// Option 1: Environment variable
const DEBUG = process.env.MESH_LLM_DEBUG === "true";

function debug(message: string, ...args: unknown[]) {
  if (DEBUG) console.log(message, ...args);
}

// Option 2: Use tracing module
import { publishTraceSpan } from "./tracing.js";
#+END_SRC

** DONE MeshLlmAgent Created on Every Tool Call [LOW]
:PROPERTIES:
:FILE: src/runtime/typescript/src/llm.ts
:LINES: 249-263
:END:

In =wrappedExecute=, a new =MeshLlmAgent= instance is created for every tool
invocation, even though the config is static.

*Current code:*
#+BEGIN_SRC typescript
const wrappedExecute = async (args) => {
  // Created every time!
  const agent = new MeshLlmAgent({
    functionId,
    provider: llmConfig.provider,
    // ... static config
  });
  // ...
};
#+END_SRC

*Recommended fix:* Create agent once at registration time:
#+BEGIN_SRC typescript
// Create once
const agent = new MeshLlmAgent({ functionId, provider, ... });

const wrappedExecute = async (args) => {
  // Reuse existing agent
  const llmCallable = agent.createCallable({ tools, meshProvider, ... });
  // ...
};
#+END_SRC

*Note:* Need to verify =MeshLlmAgent= is stateless enough for reuse (check
=_systemPromptOverride= and =_meta= state).

** DONE Template Cache Key Uses Raw Path [LOW]
:PROPERTIES:
:FILE: src/runtime/typescript/src/template.ts
:LINES: 85-86
:END:

For file templates, the cache key is the original =file://...= string, not the
resolved absolute path. This means the same file accessed via different relative
paths won't share the cache.

*Current code:*
#+BEGIN_SRC typescript
const cacheKey = template;  // "file://prompts/foo.hbs"
const cached = templateCache.get(cacheKey);
#+END_SRC

*Recommended fix:* Use resolved absolute path as cache key:
#+BEGIN_SRC typescript
let cacheKey = template;
if (isFileTemplate(template)) {
  const filePath = extractFilePath(template);
  cacheKey = resolveTemplatePath(filePath);  // Absolute path
}
const cached = templateCache.get(cacheKey);
#+END_SRC

* References

- fastmcp TypeScript: https://github.com/punkpeye/fastmcp
- mcp-proxy: https://github.com/punkpeye/mcp-proxy
- napi-rs: https://napi.rs/
- MCP Specification: https://modelcontextprotocol.info/
