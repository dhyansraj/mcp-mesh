# Test Case: Java Trace Context Isolation
# Verifies that rapid sequential tool calls produce independent traces with no
# cross-contamination of trace context between requests.
#
# Bug Reference: #581 - Java SDK InheritableThreadLocal trace context leaks
# across requests when thread pool reuses threads.
#
# Agent Setup:
#   - java-math-agent (port 9010): provides "add" and "multiply" tools
#
# Flow: 3 rapid sequential `meshctl call add` invocations with --trace.
# Each call must produce a completely independent trace.
#
# Expected: FAILS against current codebase (pre-fix for #581)
# Uses UC-level artifacts from /uc-artifacts (symlinked to examples/java)

name: "Java Trace Context Isolation"
description: "Verify rapid sequential tool calls produce independent traces with no cross-contamination (bug #581)"
tags:
  - observability
  - tracing
  - tempo
  - redis
  - java
  - regression
timeout: 300

pre_run:
  # Start observability infrastructure (Redis + Tempo)
  - routine: global.start_observability

  # Setup for Java agents
  - routine: global.setup_for_java_agent
    params:
      meshctl_version: "${config.packages.cli_version}"

test:
  # Copy UC-level artifacts to workspace
  - name: "Copy artifacts to workspace"
    handler: shell
    command: |
      cp -rL /uc-artifacts/java-math-agent /workspace/
      echo "Artifacts copied"
      ls -la /workspace/
    capture: copy_output

  # Create env file with secrets
  - name: "Create env file with secrets"
    handler: secrets
    source: /uc-artifacts/env.template
    target: /workspace/.env

  # Install Maven dependencies for java-math-agent
  - name: "Install Maven dependencies for java-math-agent"
    handler: maven-install
    path: /workspace/java-math-agent
    timeout: 600

  # Start java-math-agent with tracing enabled
  - name: "Start java-math-agent"
    handler: shell
    command: "meshctl start /workspace/java-math-agent --env-file .env -d"
    workdir: /workspace
    capture: start_math_agent

  # Wait for agent to register (Java is slow to start)
  - name: "Wait for agent registration"
    handler: shell
    workdir: /workspace
    command: |
      echo "Waiting for Java agent to start and register..."
      for i in $(seq 1 45); do
        if meshctl list -t 2>/dev/null | grep -q "add"; then
          echo "Agent registered with add tool after ${i} iterations"
          exit 0
        fi
        sleep 2
      done
      echo "ERROR: Agent did not register properly within 90s"
      echo "=== Agent list ==="
      meshctl list 2>/dev/null || true
      echo "=== Tool list ==="
      meshctl list -t 2>/dev/null || true
      echo "=== java-math-agent logs ==="
      meshctl logs java-math-agent 2>/dev/null | tail -30 || true
      exit 1
    capture: wait_registration
    timeout: 120

  # Verify agent is running
  - name: "List agents"
    handler: shell
    command: "meshctl list"
    workdir: /workspace
    capture: list_output

  # List tools to verify capabilities
  - name: "List tools"
    handler: shell
    command: "meshctl list -t"
    workdir: /workspace
    capture: tools_output

  # Call 1: add with tracing
  - name: "Call 1 - add with tracing"
    handler: shell
    command: |
      meshctl call add '{"a": 1, "b": 2}' --trace 2>&1
    workdir: /workspace
    capture: call1_output
    timeout: 60

  # Extract trace ID 1
  - name: "Extract trace ID 1"
    handler: shell
    command: |
      TRACE_ID=$(echo "${captured.call1_output}" | grep "Trace ID:" | awk '{print $3}')
      if [ -z "$TRACE_ID" ]; then
        echo "ERROR: Could not extract trace ID from call 1"
        echo "Output was: ${captured.call1_output}"
        exit 1
      fi
      echo "TRACE_ID=$TRACE_ID"
    workdir: /workspace
    capture: trace_id_1

  # Call 2: add with tracing
  - name: "Call 2 - add with tracing"
    handler: shell
    command: |
      meshctl call add '{"a": 3, "b": 4}' --trace 2>&1
    workdir: /workspace
    capture: call2_output
    timeout: 60

  # Extract trace ID 2
  - name: "Extract trace ID 2"
    handler: shell
    command: |
      TRACE_ID=$(echo "${captured.call2_output}" | grep "Trace ID:" | awk '{print $3}')
      if [ -z "$TRACE_ID" ]; then
        echo "ERROR: Could not extract trace ID from call 2"
        echo "Output was: ${captured.call2_output}"
        exit 1
      fi
      echo "TRACE_ID=$TRACE_ID"
    workdir: /workspace
    capture: trace_id_2

  # Call 3: add with tracing
  - name: "Call 3 - add with tracing"
    handler: shell
    command: |
      meshctl call add '{"a": 5, "b": 6}' --trace 2>&1
    workdir: /workspace
    capture: call3_output
    timeout: 60

  # Extract trace ID 3
  - name: "Extract trace ID 3"
    handler: shell
    command: |
      TRACE_ID=$(echo "${captured.call3_output}" | grep "Trace ID:" | awk '{print $3}')
      if [ -z "$TRACE_ID" ]; then
        echo "ERROR: Could not extract trace ID from call 3"
        echo "Output was: ${captured.call3_output}"
        exit 1
      fi
      echo "TRACE_ID=$TRACE_ID"
    workdir: /workspace
    capture: trace_id_3

  # Wait for traces to be flushed to Tempo
  - name: "Wait for trace flush"
    handler: wait
    seconds: 5

  # Verify all 3 trace IDs are distinct
  - name: "Verify trace ID uniqueness"
    handler: shell
    command: |
      TID1=$(echo "${captured.trace_id_1}" | grep "TRACE_ID=" | head -1 | cut -d= -f2)
      TID2=$(echo "${captured.trace_id_2}" | grep "TRACE_ID=" | head -1 | cut -d= -f2)
      TID3=$(echo "${captured.trace_id_3}" | grep "TRACE_ID=" | head -1 | cut -d= -f2)
      echo "Trace ID 1: $TID1"
      echo "Trace ID 2: $TID2"
      echo "Trace ID 3: $TID3"
      if [ "$TID1" = "$TID2" ] || [ "$TID1" = "$TID3" ] || [ "$TID2" = "$TID3" ]; then
        echo "UNIQUE=false"
        echo "ERROR: Trace IDs are not all distinct - trace context leak detected (bug #581)"
      else
        echo "UNIQUE=true"
      fi
    workdir: /workspace
    capture: uniqueness_check

  # Query trace 1 from Tempo
  - name: "Query trace 1 from Tempo"
    handler: shell
    command: |
      TRACE_ID=$(echo "${captured.trace_id_1}" | grep "TRACE_ID=" | head -1 | cut -d= -f2)
      meshctl trace $TRACE_ID --json 2>&1
    workdir: /workspace
    capture: trace1_json
    timeout: 30

  # Query trace 2 from Tempo
  - name: "Query trace 2 from Tempo"
    handler: shell
    command: |
      TRACE_ID=$(echo "${captured.trace_id_2}" | grep "TRACE_ID=" | head -1 | cut -d= -f2)
      meshctl trace $TRACE_ID --json 2>&1
    workdir: /workspace
    capture: trace2_json
    timeout: 30

  # Query trace 3 from Tempo
  - name: "Query trace 3 from Tempo"
    handler: shell
    command: |
      TRACE_ID=$(echo "${captured.trace_id_3}" | grep "TRACE_ID=" | head -1 | cut -d= -f2)
      meshctl trace $TRACE_ID --json 2>&1
    workdir: /workspace
    capture: trace3_json
    timeout: 30

  # Cross-contamination check: verify no SpanID appears in multiple traces
  - name: "Check for cross-contamination of span IDs"
    handler: shell
    command: |
      # Extract SpanIDs from each trace
      SPANS1=$(echo '${captured.trace1_json}' | jq -r '.Spans[].SpanID' 2>/dev/null)
      SPANS2=$(echo '${captured.trace2_json}' | jq -r '.Spans[].SpanID' 2>/dev/null)
      SPANS3=$(echo '${captured.trace3_json}' | jq -r '.Spans[].SpanID' 2>/dev/null)

      echo "Trace 1 SpanIDs: $SPANS1"
      echo "Trace 2 SpanIDs: $SPANS2"
      echo "Trace 3 SpanIDs: $SPANS3"

      # Combine all SpanIDs and check for duplicates
      ALL_SPANS=$(printf "%s\n%s\n%s" "$SPANS1" "$SPANS2" "$SPANS3" | grep -v '^$' | sort)
      UNIQUE_SPANS=$(echo "$ALL_SPANS" | sort -u)

      TOTAL=$(echo "$ALL_SPANS" | wc -l | tr -d ' ')
      UNIQUE=$(echo "$UNIQUE_SPANS" | wc -l | tr -d ' ')

      echo "Total SpanIDs: $TOTAL"
      echo "Unique SpanIDs: $UNIQUE"

      if [ "$TOTAL" = "$UNIQUE" ]; then
        echo "ISOLATED=true"
      else
        echo "ISOLATED=false"
        echo "ERROR: Duplicate SpanIDs found across traces - cross-contamination detected (bug #581)"
        # Show duplicates
        echo "$ALL_SPANS" | uniq -d
      fi
    workdir: /workspace
    capture: isolation_check

  # Stop all agents
  - name: "Stop agents"
    handler: shell
    command: "meshctl stop"
    workdir: /workspace

assertions:
  # Agent should be registered
  - expr: "${captured.list_output} icontains 'java-math-agent'"
    message: "java-math-agent should be registered"

  # Tools should be available
  - expr: "${captured.tools_output} contains 'add'"
    message: "add tool should be listed"

  # All 3 calls should succeed (contain result content)
  - expr: "${captured.call1_output} contains 'Trace ID:'"
    message: "Call 1 should succeed and produce a trace ID"

  - expr: "${captured.call2_output} contains 'Trace ID:'"
    message: "Call 2 should succeed and produce a trace ID"

  - expr: "${captured.call3_output} contains 'Trace ID:'"
    message: "Call 3 should succeed and produce a trace ID"

  # All 3 trace IDs should be distinct
  - expr: "${captured.uniqueness_check} contains 'UNIQUE=true'"
    message: "All 3 trace IDs must be distinct (bug #581: trace context leak if not)"

  # Each trace should have exactly 1 span (single tool call = 1 span)
  - expr: ${jq:captured.trace1_json:.SpanCount} == 1
    message: "Trace 1 should have exactly 1 span (single add call)"

  - expr: ${jq:captured.trace2_json:.SpanCount} == 1
    message: "Trace 2 should have exactly 1 span (single add call)"

  - expr: ${jq:captured.trace3_json:.SpanCount} == 1
    message: "Trace 3 should have exactly 1 span (single add call)"

  # Each trace should be successful
  - expr: ${jq:captured.trace1_json:.Success} == true
    message: "Trace 1 should show successful execution"

  - expr: ${jq:captured.trace2_json:.Success} == true
    message: "Trace 2 should show successful execution"

  - expr: ${jq:captured.trace3_json:.Success} == true
    message: "Trace 3 should show successful execution"

  # No cross-contamination of span IDs
  - expr: "${captured.isolation_check} contains 'ISOLATED=true'"
    message: "No SpanID should appear in multiple traces (bug #581: cross-contamination if not)"

post_run:
  - handler: shell
    command: |
      meshctl stop 2>/dev/null || true
      # Also kill any remaining Java processes
      pkill -f "spring-boot:run" 2>/dev/null || true
      pkill -f "java.*math" 2>/dev/null || true
    workdir: /workspace
    ignore_errors: true
  - routine: global.stop_observability
  - routine: global.cleanup_workspace
