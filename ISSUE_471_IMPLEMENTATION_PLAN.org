#+TITLE: Issue #471: Dependency Resolution Storage Fix + Tag-Level OR
#+AUTHOR: Claude Code
#+DATE: 2026-01-23
#+STARTUP: overview indent
#+OPTIONS: toc:3 num:t

* Overview
** Problem Statement

The registry's =StoreDependencyResolutions= function incorrectly matches
dependencies by capability name alone, causing all dependencies sharing the
same capability to resolve to the first match instead of their correct,
distinct providers.

** Example

#+begin_example
Calculator tool declares 4 dependencies on "math_operations":
  [0] math_operations + tags:[addition]    → should resolve to "add"
  [1] math_operations + tags:[subtraction] → should resolve to "subtract"
  [2] math_operations + tags:[multiplication] → should resolve to "multiply"
  [3] math_operations + tags:[division]    → should resolve to "divide"

Current bug: ALL four resolve to "add" (first match)
#+end_example

** Root Cause

File: =src/core/registry/ent_service.go= (lines 572-576)

#+begin_src go
for _, res := range resolved {
    if res.Capability == capability {  // Only matches by capability!
        matchedResolution = res
        break  // Always gets first match
    }
}
#+end_src

* Key Concepts
** Tag Operators (Consumer-side only)

| Operator | Meaning | Behavior |
|----------|---------|----------|
| =tag= | Required | Must match, hard fail if missing |
| =+tag= | Preferred | Bonus weight if available, not required |
| =-tag= | Exclude | Hard fail if present on provider |

** Weight Calculation

When multiple =+= tags are specified, weights determine winner:

#+begin_example
Consumer: {cap: "llm", tags: ["+claude", "+gpt"]}
Provider A: tags=["llm", "claude", "anthropic"] → Higher weight
Provider B: tags=["llm", "gpt", "openai"] → Lower weight

Result: Provider A wins when both available
        Provider B wins when only B available
#+end_example

** OR Matching (Tag-Level)

OR alternatives are implemented at the *tag level*, consistent with LLM filter
semantics where "array = OR". Tags can contain nested arrays for alternatives:

#+begin_src python
# AND semantics (current - flat array)
tags: ["addition", "python"]  # Must have addition AND python

# OR semantics (new - nested array)
tags: ["addition", ["python", "typescript"]]  # Must have addition AND (python OR typescript)

# Full OR (all alternatives)
tags: [["python"], ["typescript"]]  # Must have python OR typescript
#+end_src

Resolution logic: For each tag position, if the tag is an array, try each
alternative in order until one matches.

** Design Rationale

*** Why Tag-Level OR (Not Dependency-Level)

Originally considered nested arrays at the dependency level:

#+begin_src python
# Rejected approach - OR at dependency level
dependencies=[
    [
        {"capability": "math", "tags": ["python"]},
        {"capability": "math", "tags": ["typescript"]},
    ],
]
#+end_src

This was rejected because:
1. Too much change to SDK validation
2. Inconsistent with existing OR semantics (LLM filter uses array = OR at tag level)
3. More complex parsing in registry

The tag-level OR approach:
1. Consistent with LLM filter pattern
2. Simpler SDK changes
3. Same capability/version, just tag alternatives
4. Works for both Python and TypeScript SDKs

* Requirements
** Positional Integrity

- =dep_index= must be stored in database
- If dep[1] is unresolved, dep[2] must remain at position 2 (no shifting)
- Unresolved dependencies stored with =status="unresolved"=, not skipped

** Full Matching

Match by capability + tags + version (not just capability)

** Tag-Level OR

Support nested arrays in tags field for OR alternatives

** Separation of Concerns

- Resolution logic in service layer
- Storage layer is pure persistence (no resolution logic)

** Backward Compatibility

Existing agents without =dep_index= or nested tags must continue to work

* Implementation Plan

** DONE Phase 1: Schema Changes [2026-01-23]
*** File: =src/core/registry/ent/schema/dependencyresolution.go=

Add new field:

#+begin_src go
// Add dep_index field
field.Int("dep_index").
    Comment("Position of this dependency in the tool's dependency array (0-indexed)").
    Default(0).
    NonNegative(),
#+end_src

Add new index:

#+begin_src go
index.Fields("consumer_agent_id", "consumer_function_name", "dep_index"),
#+end_src

** DONE Phase 2: Data Structures [2026-01-23]
*** File: =src/core/registry/ent_service.go=

#+begin_src go
// DependencySpec represents a single dependency requirement
type DependencySpec struct {
    Capability string   `json:"capability"`
    Tags       []string `json:"tags,omitempty"`
    Version    string   `json:"version,omitempty"`
    Namespace  string   `json:"namespace,omitempty"`
}

// IndexedResolution is the result of resolving a positional dependency
type IndexedResolution struct {
    DepIndex   int                 // Position in array
    Spec       DependencySpec      // The spec that matched (or first spec if unresolved)
    Resolution *ResolvedCapability // nil if unresolved
    Status     string              // "available", "unavailable", "unresolved"
}
#+end_src

** DONE Phase 3: Core Registry Changes [2026-01-23]
*** File: =src/core/registry/ent_service.go=

**** 3.1 Resolution Architecture

#+begin_example
resolveAtPosition(depIndex int, dep interface{}) → IndexedResolution
    │
    ├─ parseDependencySpec() → DependencySpec
    │
    └─ resolveSingle(spec) → *ResolvedCapability
           │
           └─ findHealthyProviderWithTTL() (existing function)
#+end_example

**** 3.2 Core Resolution Functions

- =parseDependencySpec()= - Parse raw JSON to DependencySpec
- =resolveSingle()= - Single source of truth for resolution logic
- =resolveAtPosition()= - Handle positional dependencies
- =StoreDependencyResolutions()= - Updated to use =resolveAtPosition()=

** DONE Phase 4: Tag-Level OR Support [2026-01-23]
*** 4.1 Python SDK Changes
**** File: =src/runtime/python/mesh/decorators.py=

Update validation to allow nested arrays in tags:

#+begin_src python
# Current validation (line 569-574)
dep_tags = dep.get("tags", [])
if not isinstance(dep_tags, list):
    raise ValueError("dependency tags must be a list")
for tag in dep_tags:
    if not isinstance(tag, str):
        raise ValueError("all dependency tags must be strings")

# Updated validation
dep_tags = dep.get("tags", [])
if not isinstance(dep_tags, list):
    raise ValueError("dependency tags must be a list")
for tag in dep_tags:
    if isinstance(tag, str):
        continue  # Simple tag - OK
    elif isinstance(tag, list):
        # OR alternative - validate inner tags
        for inner_tag in tag:
            if not isinstance(tag, str):
                raise ValueError("OR alternative tags must be strings")
    else:
        raise ValueError("tags must be strings or arrays of strings (OR)")
#+end_src

*** 4.2 TypeScript SDK Changes
**** File: =src/runtime/typescript/src/types.ts=

Update type definition:

#+begin_src typescript
// Current (line 43)
tags?: string[];

// Updated - allow nested arrays for OR
tags?: (string | string[])[];
#+end_src

**** File: =src/runtime/typescript/src/agent.ts=

Update validation if any exists.

*** 4.3 Go Registry Changes
**** File: =src/core/registry/ent_service.go=

Update =parseDependencySpec()= to handle nested tag arrays:

#+begin_src go
// Handle tags - can be []interface{}, []string, or mixed with nested arrays
if tags, exists := m["tags"]; exists {
    if tagsList, ok := tags.([]interface{}); ok {
        for _, tag := range tagsList {
            if tagStr, ok := tag.(string); ok {
                spec.Tags = append(spec.Tags, tagStr)
            } else if tagArr, ok := tag.([]interface{}); ok {
                // OR alternative - store as JSON or special format
                // e.g., "[python|typescript]" or use separate field
                orTags := []string{}
                for _, t := range tagArr {
                    if s, ok := t.(string); ok {
                        orTags = append(orTags, s)
                    }
                }
                spec.TagAlternatives = append(spec.TagAlternatives, orTags)
            }
        }
    }
}
#+end_src

Update =matchesEnhancedTags()= to handle OR alternatives:

#+begin_src go
func matchesEnhancedTags(providerTags, requiredTags []string, tagAlternatives [][]string) (bool, int) {
    // ... existing logic for required tags ...

    // Handle OR alternatives
    for _, alternatives := range tagAlternatives {
        matched := false
        for _, alt := range alternatives {
            if containsTag(providerTags, alt) {
                matched = true
                score += 10  // Bonus for matching OR
                break
            }
        }
        if !matched {
            return false, 0  // None of the alternatives matched
        }
    }

    return true, score
}
#+end_src

** DONE Phase 5: Test Cases [2026-01-23]
*** File: =src/core/registry/dependency_resolution_test.go=

**** Existing Tests (DONE)

1. Same capability, different tags -> different providers
2. Positional integrity when middle is unresolved
3. Weighted tag matching
4. Backward compatibility

**** New Tests for Tag-Level OR

#+begin_src go
func TestTagLevelOR_PrimaryAvailable(t *testing.T) {
    // Provider A: tags=["math", "addition", "python"]
    // Provider B: tags=["math", "addition", "typescript"]
    //
    // Consumer: {cap: "math", tags: ["addition", ["python", "typescript"]]}
    //
    // Assert: Resolves to Provider A (python is first alternative)
}

func TestTagLevelOR_FallbackUsed(t *testing.T) {
    // Provider B: tags=["math", "addition", "typescript"]  // Only TS available
    //
    // Consumer: {cap: "math", tags: ["addition", ["python", "typescript"]]}
    //
    // Assert: Resolves to Provider B (fallback to typescript)
}

func TestTagLevelOR_NoneAvailable(t *testing.T) {
    // Provider C: tags=["math", "addition", "rust"]  // Neither py nor ts
    //
    // Consumer: {cap: "math", tags: ["addition", ["python", "typescript"]]}
    //
    // Assert: status="unresolved"
}

func TestTagLevelOR_MultiplePositions(t *testing.T) {
    // Consumer declares:
    // deps[0] = {cap: "math", tags: ["addition", ["python", "typescript"]]}
    // deps[1] = {cap: "math", tags: ["subtraction", ["python", "typescript"]]}
    //
    // With only typescript providers available
    // Assert: Both resolve to typescript providers
}
#+end_src

** DONE Phase 6: Local Test Agents (or-tests/) [2026-01-23]
*** File: =mcp-mesh-test-suite/integration/suites/uc03_capabilities/tc11_or_alternatives_fallback/=

Test agents:
- =py-math-agent=: math_operations with "python" tag
- =ts-math-agent=: math_operations with "typescript" tag
- =py-calculator-agent=: uses tag-level OR syntax

#+begin_src python
# py-calculator-agent with tag-level OR
@mesh.tool(
    capability="calculator",
    description="Calculate using OR alternatives",
    tags=["math", "calculator"],
    dependencies=[
        {"capability": "math_operations", "tags": ["addition", ["python", "typescript"]]},
        {"capability": "math_operations", "tags": ["subtraction", ["python", "typescript"]]},
        {"capability": "math_operations", "tags": ["multiplication", ["python", "typescript"]]},
        {"capability": "math_operations", "tags": ["division", ["python", "typescript"]]},
    ],
)
async def calculate(a: int, b: int, operator: str, ...):
    ...
#+end_src

Test scenarios:
1. Both py + ts running -> uses primary (py-math-agent)
2. Only ts running -> uses fallback (ts-math-agent)

** DONE Phase 7: Documentation Updates [2026-01-23]
*** Man Pages to Update

**** =src/core/cli/man/content/capabilities.md=

Update "Selector Logic (AND/OR)" section:

#+begin_src markdown
### Selector Logic (AND/OR)

| Syntax                              | Semantics                                    |
| ----------------------------------- | -------------------------------------------- |
| `tags: ["a", "b", "c"]`             | a AND b AND c (all required)                 |
| `tags: ["+a", "+b"]`                | Prefer a, prefer b (neither required)        |
| `tags: ["a", "-x"]`                 | Must have a, must NOT have x                 |
| `tags: ["a", ["b", "c"]]`           | a AND (b OR c) - tag-level OR                |
| `tags: [["a"], ["b"]]`              | a OR b (full OR)                             |
| `[{tags:["a"]}, {tags:["b"]}]`      | a OR b (multiple selectors - LLM filter)     |

**Tag-Level OR** (new in v0.8.0):

```python
# Prefer python, fallback to typescript
dependencies=[
    {"capability": "math", "tags": ["addition", ["python", "typescript"]]},
]
```
#+end_src

**** =src/core/cli/man/content/dependency-injection.md=

Add section for OR alternatives:

#+begin_src markdown
### OR Alternatives (Tag-Level)

When multiple providers can satisfy a dependency, use nested arrays in tags
for fallback behavior:

```python
@app.tool()
@mesh.tool(
    capability="calculator",
    dependencies=[
        # Prefer python provider, fallback to typescript
        {"capability": "math", "tags": ["addition", ["python", "typescript"]]},
    ],
)
async def calculate(a: int, b: int, math: mesh.McpMeshTool = None):
    result = await math(a=a, b=b)
    return result
```

Resolution order:
1. Try to find provider with `addition` AND `python` tags
2. If not found, try provider with `addition` AND `typescript` tags
3. If neither found, dependency is unresolved
#+end_src

**** =src/core/cli/man/content/tags.md=

Add OR section if not exists:

#+begin_src markdown
### Tag OR Alternatives

Nested arrays in tags represent OR conditions:

```python
# Single OR
tags: ["api", ["v1", "v2"]]  # api AND (v1 OR v2)

# Multiple ORs
tags: [["fast", "cached"], ["sync", "async"]]  # (fast OR cached) AND (sync OR async)
```

The registry tries alternatives in order, using the first match.
#+end_src

* Summary of Changes

| Layer | Current | After Fix |
|-------|---------|-----------|
| Schema | No positional tracking | =dep_index= column added |
| Resolution | Mixed in storage function | Separate =resolveSingle()= (single source of truth) |
| Storage | Contains matching logic | Pure persistence, no resolution logic |
| Matching | Capability-only | Capability + Tags + Version |
| Tag OR | Not supported | Nested arrays in tags field |
| Unresolved | Skipped | Stored with =status="unresolved"= |
| Python SDK | Tags must be strings | Tags can be strings or arrays (OR) |
| TypeScript SDK | Tags must be strings | Tags can be strings or arrays (OR) |

* Files to Modify

** Registry (Go)
1. =src/core/registry/ent/schema/dependencyresolution.go= - Add fields (DONE)
2. =src/core/registry/ent_service.go= - Resolution logic (DONE) + tag OR (TODO)
3. =src/core/registry/dependency_resolution_test.go= - Add tests

** Python SDK
4. =src/runtime/python/mesh/decorators.py= - Allow nested tag arrays

** TypeScript SDK
5. =src/runtime/typescript/src/types.ts= - Update type definitions
6. =src/runtime/typescript/src/agent.ts= - Update validation (if any)

** Documentation
7. =src/core/cli/man/content/capabilities.md= - Update OR section
8. =src/core/cli/man/content/dependency-injection.md= - Add OR alternatives
9. =src/core/cli/man/content/tags.md= - Add tag OR section

* Acceptance Criteria

** Phase 1-3 (DONE)
- [X] =dep_index= column added and populated correctly (2026-01-23)
- [X] All 7 test cases pass (2026-01-23)
- [X] =resolveSingle()= is the single source of truth for matching logic (2026-01-23)
- [X] No resolution logic in =StoreDependencyResolutions= - now uses =resolveAtPosition()= (2026-01-23)
- [X] Unresolved dependencies stored (not skipped) with =status="unresolved"= (2026-01-23)
- [X] Backward compatible with existing agents (2026-01-23)
- [X] Calculator example resolves correctly (add, subtract, multiply, divide) (2026-01-23)

** Phase 4-7 (DONE)
- [X] Python SDK accepts nested arrays in tags (2026-01-23)
- [X] TypeScript SDK accepts nested arrays in tags (2026-01-23)
- [X] Go registry parses nested tag arrays (2026-01-23)
- [X] Go registry =matchesEnhancedTags()= handles OR alternatives (2026-01-23)
- [X] Tag-level OR unit tests pass (4 new tests) (2026-01-23)
- [X] Local test agents created in =or-tests/= directory (2026-01-23)
- [X] Man pages updated (capabilities, dependency-injection, tags - Python & TypeScript) (2026-01-23)

* Cleanup & Refactoring

** TODO Phase 8: Fix StoreDependencyResolutions (Critical)

*** Problem

=StoreDependencyResolutions= receives =dependenciesResolved= parameter but *ignores it completely*
and re-resolves everything:

#+begin_src go
func (s *EntService) StoreDependencyResolutions(
    ctx context.Context,
    agentID string,
    metadata map[string]interface{},
    dependenciesResolved map[string][]*DependencyResolution,  // ← IGNORED!
) error {
    // ...
    for depIndex, depData := range depsSlice {
        result := s.resolveAtPosition(depIndex, depData)  // ← RE-RESOLVES!
#+end_src

*** Impact

- Resolution happens twice on every registration
- Violates separation of concerns (DB layer should not resolve)
- Inefficient and error-prone

*** Solution

Change =StoreDependencyResolutions= to:
1. Accept =[]IndexedResolution= instead of re-resolving
2. Pure persistence - no resolution logic
3. Caller provides fully resolved data

#+begin_src go
// New signature
func (s *EntService) StoreDependencyResolutions(
    ctx context.Context,
    agentID string,
    resolutions []IndexedResolution,  // Already resolved!
) error {
    for _, res := range resolutions {
        // Just persist - no resolution logic
        create := s.entDB.DependencyResolution.Create().
            SetConsumerAgentID(agentID).
            SetConsumerFunctionName(res.FunctionName).
            SetDepIndex(res.DepIndex).
            SetCapabilityRequired(res.Spec.Capability)
        // ...
    }
}
#+end_src

** TODO Phase 9: Extract Matcher Component

*** Problem

Matching logic scattered across multiple functions:
- =findHealthyProviderWithTTL()= - querying + filtering
- =matchesVersion()= - version constraints
- =matchesEnhancedTags()= - tag matching with +/- operators
- =hasAllTags()= - simple tag check

*** Solution

Create =src/core/registry/matcher.go=:

#+begin_src go
package registry

// Matcher handles all dependency matching logic
type Matcher struct {
    logger *logger.Logger
}

// NewMatcher creates a new Matcher instance
func NewMatcher(logger *logger.Logger) *Matcher {
    return &Matcher{logger: logger}
}

// MatchCandidate checks if a candidate satisfies a DependencySpec
// Returns (matches bool, score int)
func (m *Matcher) MatchCandidate(candidate Candidate, spec DependencySpec) (bool, int) {
    // Capability must match (required)
    if candidate.Capability != spec.Capability {
        return false, 0
    }

    // Version matching
    if spec.Version != "" && !m.MatchVersion(candidate.Version, spec.Version) {
        return false, 0
    }

    // Tag matching with scoring
    return m.MatchTags(candidate.Tags, spec.Tags, spec.TagAlternatives)
}

// MatchVersion checks if version satisfies constraint (semver)
func (m *Matcher) MatchVersion(version, constraint string) bool

// MatchTags checks tags with +/- operators and OR alternatives
func (m *Matcher) MatchTags(providerTags, requiredTags []string, alternatives [][]string) (bool, int)
#+end_src

** TODO Phase 10: Improve Semver Support

*** Current Issues

#+begin_src go
func matchesVersion(version, constraint string) bool {
    if constraint == "" || version == "" {
        return version == constraint  // Wrong: empty constraint should match all
    }
    // Falls back to string comparison on parse errors (silent failure)
}
#+end_src

*** Solution

#+begin_src go
func (m *Matcher) MatchVersion(version, constraint string) bool {
    // Empty constraint matches any version
    if constraint == "" {
        return true
    }

    // Empty version never matches a constraint
    if version == "" {
        return false
    }

    // Parse version
    v, err := semver.NewVersion(version)
    if err != nil {
        m.logger.Warning("Invalid semver version '%s': %v", version, err)
        return false  // Don't silently fall back
    }

    // Parse constraint (supports: >=1.0.0, ^1.2.3, ~1.2.3, 1.0.0 - 2.0.0)
    c, err := semver.NewConstraint(constraint)
    if err != nil {
        m.logger.Warning("Invalid semver constraint '%s': %v", constraint, err)
        return false
    }

    return c.Check(v)
}
#+end_src

** TODO Phase 11: Refactor ent_service.go (2686 lines → Multiple Files)

*** Current Structure

| Lines | Category | Functions |
|-------|----------|-----------|
| ~400 | Registration | RegisterAgent, UpdateHeartbeat |
| ~300 | Resolution | resolveSingle, resolveAtPosition, ResolveAll*, findHealthyProvider* |
| ~400 | Storage | StoreDependencyResolutions, StoreLLMToolResolutions, StoreLLMProviderResolutions |
| ~200 | Matching | matchesVersion, matchesEnhancedTags, hasAllTags |
| ~300 | Query | ListAgents, GetAgent, GetAgentWithCapabilities |
| ~400 | Lifecycle | Cleanup*, markAgentStale*, UpdateAgentHeartbeatTimestamp |
| ~200 | Helpers | Various utility functions |

*** Proposed Split

**** =ent_service.go= (Core - ~500 lines)
- EntService struct definition
- NewEntService constructor
- RegisterAgent
- UpdateHeartbeat
- Health

**** =resolver.go= (Resolution - ~400 lines)
- DependencySpec, IndexedResolution types
- parseDependencySpec
- resolveSingle
- resolveAtPosition
- ResolveAllDependenciesFromMetadata
- findHealthyProviderWithTTL
- ResolveLLMToolsFromMetadata

**** =matcher.go= (Matching - ~250 lines)
- Matcher struct
- MatchVersion
- MatchTags / matchesEnhancedTags
- hasAllTags
- Candidate type

**** =persistence.go= (Storage - ~400 lines)
- StoreDependencyResolutions
- StoreLLMToolResolutions
- StoreLLMProviderResolutions
- UpdateDependencyStatusOnAgentOffline

**** =lifecycle.go= (Cleanup/Hooks - ~400 lines)
- UnregisterAgent
- unregisterAgentAttempt
- CleanupStaleAgentsOnStartup
- markAgentStaleWithRetry
- markAgentStaleAttempt
- UpdateAgentHeartbeatTimestamp
- HasTopologyChanges
- Enable/Disable/IsStatusChangeHooksEnabled

**** =query.go= (Query - ~300 lines)
- ListAgents
- GetAgent
- GetAgentWithCapabilities

**** =helpers.go= (Utilities - ~200 lines)
- isDatabaseLockError
- getStringFromMap, getString, getStringSlice
- parseVersionConstraint
- countTotalDependenciesInMetadata
- normalizeName
- convertToLLMToolFilter, convertToLLMProvider

** TODO Phase 12: Clean Up Repeated Anonymous Structs

*** Problem

In =findHealthyProviderWithTTL()=, the same anonymous struct is defined 4 times:

#+begin_src go
var candidates []struct {
    AgentID      string
    FunctionName string
    Capability   string
    Version      string
    Tags         []string
    HttpHost     string
    HttpPort     int
    UpdatedAt    time.Time
}
#+end_src

*** Solution

Define named types:

#+begin_src go
// Candidate represents a potential dependency provider
type Candidate struct {
    AgentID      string
    FunctionName string
    Capability   string
    Version      string
    Tags         []string
    HttpHost     string
    HttpPort     int
    UpdatedAt    time.Time
}

// ScoredCandidate adds priority scoring to Candidate
type ScoredCandidate struct {
    Candidate
    Score int
}
#+end_src

** TODO Phase 13: Consolidate Dependency Types

*** Problem

Two similar types exist:

#+begin_src go
// Dependency (used in findHealthyProviderWithTTL)
type Dependency struct {
    Capability      string
    Version         string
    Tags            []string
    TagAlternatives [][]string
}

// DependencySpec (used in resolution)
type DependencySpec struct {
    Capability      string
    Tags            []string
    Version         string
    Namespace       string
    TagAlternatives [][]string
}
#+end_src

*** Solution

Consolidate into single =DependencySpec= type with all fields.

* Cleanup Acceptance Criteria

- [ ] =StoreDependencyResolutions= accepts pre-resolved data (no resolution logic)
- [ ] Matcher extracted to =matcher.go= with clear interface
- [ ] Semver constraints work correctly (empty constraint = match all)
- [ ] =ent_service.go= split into 6-7 focused files
- [ ] No anonymous struct repetition
- [ ] =Dependency= and =DependencySpec= consolidated
- [ ] All existing tests pass after refactoring

* References

- GitHub Issue: https://github.com/dhyansraj/mcp-mesh/issues/471
- Current problematic code: =ent_service.go:572-576=
- Capability Selector Docs: =meshctl man capabilities=
