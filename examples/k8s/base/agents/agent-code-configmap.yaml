apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-agent-code
  namespace: mcp-mesh
data:
  # Updated hello world agent with FastMCP integration
  hello_world.py: |
    #!/usr/bin/env python3
    """
    MCP Mesh Hello World Example with FastMCP Integration

    This example demonstrates the hybrid FastMCP + MCP Mesh approach:
    1. FastMCP decorators (@app.tool) for familiar MCP development
    2. MCP Mesh decorators (@mesh.tool) for dependency injection and orchestration
    3. Hybrid typing support for development flexibility
    4. Pure simplicity - just dual decorators, no manual setup!

    Start this agent, then start system_agent.py to see dependency injection in action!
    """

    from typing import Any

    import mesh
    from fastmcp import FastMCP

    # Single FastMCP server instance
    app = FastMCP("Hello World Service")


    # ===== MESH FUNCTION WITH SIMPLE TYPING =====
    # Uses Any type for maximum simplicity and flexibility


    @app.tool()
    @mesh.tool(
        capability="greeting",
        dependencies=["date_service"],
        description="Simple greeting with date dependency",
    )
    def hello_mesh_simple(date_service: Any = None) -> str:
        """
        MCP Mesh greeting with simple typing.

        Uses Any type for maximum flexibility - works with any proxy implementation.
        Great for prototyping and simple use cases.
        """
        if date_service is None:
            return "ðŸ‘‹ Hello from MCP Mesh! (Date service not available yet)"

        try:
            # Call the injected function - proxy implements __call__()
            current_date = date_service()
            return f"ðŸ‘‹ Hello from MCP Mesh! Today is {current_date}"
        except Exception as e:
            return f"ðŸ‘‹ Hello from MCP Mesh! (Error getting date: {e})"


    # ===== MESH FUNCTION WITH TYPED INTERFACE =====
    # Uses mesh.McpMeshAgent type for better IDE support and type safety


    @app.tool()
    @mesh.tool(
        capability="advanced_greeting",
        dependencies=[
            {
                "capability": "info",
                "tags": ["system", "general"],
            }  # Tag-based dependency!
        ],
        description="Advanced greeting with smart tag-based dependency resolution",
    )
    def hello_mesh_typed(info: mesh.McpMeshAgent | None = None) -> str:
        """
        MCP Mesh greeting with smart tag-based dependency resolution.

        This requests "info" capability with "system" + "general" tags.
        Registry will match SystemAgent_getInfo (not get_disk_info) based on tags!
        """
        if info is None:
            return "ðŸ‘‹ Hello from smart MCP Mesh! (info service not available yet)"

        try:
            # This will call the general system info (not disk info) due to smart tag matching!
            system_info = info()
            uptime = system_info.get("uptime_formatted", "unknown")
            server_name = system_info.get("server_name", "unknown")
            return f"ðŸ‘‹ Hello from smart MCP Mesh! Server: {server_name}, Uptime: {uptime}"
        except Exception as e:
            return f"ðŸ‘‹ Hello from smart MCP Mesh! (Error getting info: {e})"


    # ===== DEPENDENCY TEST FUNCTION =====
    # Shows multiple dependencies with different typing approaches


    @app.tool()
    @mesh.tool(
        capability="dependency_test",
        dependencies=[
            "date_service",  # Simple string dependency
            {
                "capability": "info",
                "tags": ["system", "disk"],
            },  # Tag-based: will get DISK info!
        ],
        description="Test hybrid dependencies: simple + tag-based resolution",
    )
    def test_dependencies(
        date_service: Any = None,
        info: mesh.McpMeshAgent | None = None,  # This will get the DISK info service!
    ) -> dict[str, Any]:
        """
        Test function showing hybrid dependency resolution.

        Demonstrates both simple string and tag-based dependencies:
        - date_service: simple string dependency
        - info with [system,disk] tags: will get disk info (not general info)!
        """
        result = {
            "test_name": "smart_dependency_demo",
            "date_service": "not_available",
            "disk_info_service": "not_available",  # This should get DISK info, not general info!
        }

        # Test simple Any type dependency
        if date_service is not None:
            try:
                date = date_service()  # Direct call
                result["date_service"] = f"available: {date}"
            except Exception as e:
                result["date_service"] = f"error: {e}"

        # Test tag-based dependency - should get DISK info service
        if info is not None:
            try:
                disk_info = (
                    info()
                )  # This should return disk/OS info, not general system info
                info_type = disk_info.get("info_type", "unknown")
                result["disk_info_service"] = (
                    f"available: {info_type} (smart tag matching worked!)"
                )
            except Exception as e:
                result["disk_info_service"] = f"error: {e}"

        return result


    # AGENT configuration - this tells mesh how to run the FastMCP server
    @mesh.agent(
        name="hello-world",
        version="1.0.0",
        description="Hello World service with FastMCP and mesh integration",
        http_port=9090,
        enable_http=True,
        auto_run=True,
    )
    class HelloWorldAgent:
        """
        Agent class that configures how mesh should run the FastMCP server.

        The mesh processor will:
        1. Discover the 'app' FastMCP instance
        2. Apply dependency injection to decorated functions
        3. Start the FastMCP HTTP server on the configured port
        4. Register all capabilities with the mesh registry
        """

        pass


    # No main method needed!
    # Mesh processor automatically handles:
    # - FastMCP server discovery and startup
    # - Dependency injection between functions
    # - HTTP server configuration
    # - Service registration with mesh registry

  # Updated system agent with FastMCP integration
  system_agent.py: |
    #!/usr/bin/env python3
    """
    MCP Mesh System Agent Example with FastMCP Integration

    This agent provides system information capabilities that other agents can depend on.
    Demonstrates the hybrid FastMCP + MCP Mesh architecture:

    - FastMCP decorators (@app.tool) for familiar MCP development
    - MCP Mesh decorators (@mesh.tool) for dependency injection and orchestration
    - Tools: Function names (MCP function names)
    - Capabilities: What others can depend on
    - Pure simplicity: Just dual decorators, no manual setup!

    Function names can be different from capability names for maximum flexibility.
    """

    from datetime import datetime
    from typing import Any

    import mesh
    from fastmcp import FastMCP

    # Single FastMCP server instance
    app = FastMCP("System Agent Service")


    # Store start time for uptime calculations
    start_time = datetime.now()

    # ===== DATE SERVICE =====
    # Tool: "get_current_time" | Capability: "date_service"


    @app.tool()
    @mesh.tool(
        capability="date_service",  # Capability name (what others depend on)
        description="Get current system date and time",
        version="1.0.0",
        tags=["system", "time", "clock"],
    )
    def get_current_time() -> str:  # Function name can be anything!
        """
        Get the current system date and time.

        This function provides the "date_service" capability.
        Function name 'get_current_time' can be anything - capability name matters!

        Returns:
            Formatted date and time string
        """
        now = datetime.now()
        return now.strftime("%B %d, %Y at %I:%M %p")


    # ===== GENERAL SYSTEM INFO SERVICE =====
    # Tool: "fetch_system_overview" | Capability: "info"


    @app.tool()
    @mesh.tool(
        capability="info",  # Generic capability name for smart matching
        description="Get comprehensive system information",
        version="1.0.0",
        tags=["system", "general", "monitoring"],  # Tags for smart resolution
    )
    def fetch_system_overview() -> dict[str, Any]:  # Clear: function name â‰  capability
        """
        Get comprehensive system information.

        This function provides the "info" capability with "system" + "general" tags.
        Smart matching: hello_world dependency "info" with "system" tag will match this.

        Returns:
            Dictionary containing system information
        """
        uptime = datetime.now() - start_time

        return {
            "server_name": "system-agent",
            "current_time": datetime.now().strftime("%B %d, %Y at %I:%M %p"),
            "uptime_seconds": uptime.total_seconds(),
            "uptime_formatted": f"{uptime.total_seconds():.1f} seconds",
            "version": "1.0.0",
            "capabilities_provided": [
                "date_service",  # From get_current_time() function
                "info",  # From fetch_system_overview() function - generic capability with smart tag matching
            ],
            "agent_type": "system_service",
        }


    # ===== UPTIME SERVICE (Different function name vs capability) =====
    # Tool: "get_uptime" | Capability: "uptime_info"


    @app.tool()
    @mesh.tool(
        capability="uptime_info",  # Capability name (what others depend on)
        description="Get system uptime information",
        version="1.0.0",
        tags=["system", "uptime"],
    )
    def check_how_long_running() -> str:  # Function name can be descriptive and different!
        """
        Get system uptime information.

        This demonstrates function_name != capability:
        - MCP calls: "check_how_long_running"
        - Capability provided: "uptime_info"
        - Dependencies declare: "uptime_info"

        Returns:
            Human-readable uptime string
        """
        uptime = datetime.now() - start_time
        return f"System running for {uptime.total_seconds():.1f} seconds"


    # ===== SECOND INFO SERVICE (Different Tags) =====
    # Same capability "info" but different tags - shows tag-based filtering


    @app.tool()
    @mesh.tool(
        capability="info",  # Same capability name!
        description="Get disk and OS information",
        version="1.0.0",
        tags=[
            "system",
            "disk",
            "os",
        ],  # Different tags - won't match "general" requests
    )
    def analyze_storage_and_os() -> dict[str, Any]:  # Completely different function name!
        """
        Get disk and OS information.

        This also provides "info" capability but with "disk" + "os" tags.
        Smart matching: requests for "info" with "general" tags won't match this.
        Only requests specifically wanting "disk" or "os" info will get this.
        """
        return {
            "info_type": "disk_and_os",
            "disk_usage": "simulated_75_percent",
            "os_version": "simulated_linux_6.x",
            "filesystem": "ext4",
            "mount_points": ["/", "/home", "/var"],
            "tags": ["disk", "os", "system"],
            "note": "This provides 'info' capability but with different tags than general system info",
        }


    # ===== STATUS SERVICE WITH DEPENDENCY =====


    @app.tool()
    @mesh.tool(
        capability="health_check",
        dependencies=["date_service"],  # Depends on capability name, not function name!
        description="Get system status with current time",
        version="1.0.0",
    )
    def perform_health_diagnostic(
        date_service: mesh.McpMeshAgent | None = None,
    ) -> dict[str, Any]:
        """
        Get system status including current time.

        This tool both provides AND consumes capabilities:
        - Provides: "health_check" (via perform_health_diagnostic function)
        - Consumes: "date_service" (from get_current_time function)

        Demonstrates how agents can be both providers and consumers.
        """
        uptime = datetime.now() - start_time

        status = {
            "status": "healthy",
            "uptime_seconds": uptime.total_seconds(),
            "memory_usage": "simulated_normal",
            "cpu_usage": "simulated_low",
            "service_name": "system-agent",
        }

        # Use injected date service if available
        if date_service is not None:
            try:
                current_time = date_service()
                status["timestamp"] = current_time
                status["time_service"] = "available"
            except Exception as e:
                status["timestamp"] = "error"
                status["time_service"] = f"error: {e}"
        else:
            status["timestamp"] = "date_service_unavailable"
            status["time_service"] = "not_injected"

        return status


    # AGENT configuration - this tells mesh how to run the FastMCP server
    @mesh.agent(
        name="system-agent",
        version="1.0.0",
        description="System Agent service with FastMCP and mesh integration",
        http_port=8080,
        enable_http=True,
        auto_run=True,
    )
    class SystemAgent:
        """
        Agent class that configures how mesh should run the FastMCP server.

        The mesh processor will:
        1. Discover the 'app' FastMCP instance
        2. Apply dependency injection to decorated functions
        3. Start the FastMCP HTTP server on the configured port
        4. Register all capabilities with the mesh registry
        """

        pass


    # No main method needed!
    # Mesh processor automatically handles:
    # - FastMCP server discovery and startup
    # - Dependency injection between functions
    # - HTTP server configuration
    # - Service registration with mesh registry

  # FastMCP agent with proper mesh integration (working version from Docker Compose)
  fastmcp_agent.py: |
    #!/usr/bin/env python3
    """
    FastMCP Agent with Mesh Integration Example

    This demonstrates the ideal developer experience:
    - Keep familiar FastMCP decorators (@app.tool, @app.prompt, @app.resource)
    - Add minimal mesh decorators (@mesh.tool, @mesh.agent) for DI and orchestration
    - No main method or server management needed - mesh handles it automatically
    """

    import json
    from datetime import datetime

    import mesh
    from fastmcp import FastMCP

    # Single FastMCP server instance
    app = FastMCP("FastMCP Service")


    # PROMPTS with mesh integration
    @app.prompt()
    @mesh.tool(capability="prompt_service", dependencies=["time_service"])
    def analysis_prompt(
        topic: str, depth: str = "basic", time_service: mesh.McpMeshAgent = None
    ) -> str:
        """Generate analysis prompt with current time."""
        timestamp = time_service() if time_service else "unknown"

        return f"""Please analyze the following topic in detail:

    Topic: {topic}
    Analysis Depth: {depth}
    Generated At: {timestamp}

    Provide:
    1. Overview and context
    2. Key points and insights
    3. Conclusions and recommendations

    Focus on delivering {depth} level analysis.
    """


    # TOOLS with mesh integration
    @app.tool()
    @mesh.tool(capability="time_service", tags=["system", "time"])
    def get_current_time() -> str:
        """Get the current system time."""
        return datetime.now().isoformat()


    @app.tool()
    @mesh.tool(capability="math_service", dependencies=["time_service"])
    def calculate_with_timestamp(
        a: float, b: float, operation: str = "add", time_service: mesh.McpMeshAgent = None
    ) -> dict:
        """Perform math operation with timestamp from time service."""
        if operation == "add":
            result = a + b
        elif operation == "multiply":
            result = a * b
        elif operation == "subtract":
            result = a - b
        else:
            result = 0

        timestamp = time_service() if time_service else "unknown"

        return {
            "operation": operation,
            "operands": [a, b],
            "result": result,
            "timestamp": timestamp,
        }


    @app.tool()
    @mesh.tool(capability="data_service", tags=["data", "json"])
    def process_data(data: str, format_type: str = "json") -> dict:
        """Process and format data."""
        return {
            "input": data,
            "format": format_type,
            "processed_at": datetime.now().isoformat(),
            "length": len(data),
        }


    @app.tool()
    @mesh.tool(
        capability="session_counter",
        tags=["session", "stateful"],
        session_required=True,
        stateful=True,
    )
    def increment_session_counter(session_id: str, increment: int = 1) -> dict:
        """Increment a counter for a specific session - demonstrates session affinity."""
        import os

        # Use agent ID to identify which instance is handling this
        agent_id = os.getenv("AGENT_ID", "unknown")
        pod_ip = os.getenv("POD_IP", "localhost")

        # Simple in-memory storage (in real apps you'd use Redis/database)
        if not hasattr(increment_session_counter, "_counters"):
            increment_session_counter._counters = {}

        # Get or initialize counter for this session
        current_count = increment_session_counter._counters.get(session_id, 0)
        new_count = current_count + increment
        increment_session_counter._counters[session_id] = new_count

        return {
            "session_id": session_id,
            "previous_count": current_count,
            "increment": increment,
            "new_count": new_count,
            "handled_by_agent": agent_id,
            "handled_by_pod": pod_ip,
            "timestamp": datetime.now().isoformat(),
            "total_sessions": len(increment_session_counter._counters),
        }


    @app.prompt()
    @mesh.tool(capability="template_service")
    def report_template(title: str, sections: list | None = None) -> str:
        """Generate report template."""
        sections = sections or ["Introduction", "Analysis", "Conclusion"]

        template = f"""# {title}

    Generated: {datetime.now().isoformat()}

    """

        for i, section in enumerate(sections, 1):
            template += f"## {i}. {section}\n\n[Content for {section.lower()}]\n\n"

        return template


    # RESOURCES with mesh integration
    @app.resource("config://service")
    @mesh.tool(capability="config_service")
    async def service_config() -> str:
        """Service configuration data."""
        config = {
            "service_name": "FastMCP Service",
            "version": "1.0.0",
            "capabilities": [
                "time_service",
                "math_service",
                "data_service",
                "prompt_service",
                "template_service",
                "config_service",
            ],
            "transport": "http",
            "mesh_enabled": True,
            "created_at": datetime.now().isoformat(),
        }
        return json.dumps(config, indent=2)


    @app.resource("status://health/{status_type}")
    @mesh.tool(capability="status_service", dependencies=["time_service"])
    async def health_status(
        status_type: str, time_service: mesh.McpMeshAgent = None
    ) -> str:
        """Health status information."""
        timestamp = time_service() if time_service else "unknown"

        status = {
            "status": "healthy",
            "status_type": status_type,
            "uptime": "running",
            "last_check": timestamp,
            "services": {
                "fastmcp": "active",
                "mesh": "integrated",
                "dependencies": "resolved",
            },
        }
        return json.dumps(status, indent=2)


    # AGENT configuration - this tells mesh how to run the FastMCP server
    @mesh.agent(
        name="fastmcp-service",
        version="1.0.0",
        description="FastMCP service with mesh integration",
        http_port=9092,
        enable_http=True,
        auto_run=True,
    )
    class FastMCPService:
        """
        Agent class that configures how mesh should run the FastMCP server.

        The mesh processor will:
        1. Discover the 'app' FastMCP instance
        2. Apply dependency injection to decorated functions
        3. Start the FastMCP HTTP server on the configured port
        4. Register all capabilities with the mesh registry
        """

        pass


    # No main method needed!
    # Mesh processor automatically handles:
    # - FastMCP server discovery and startup
    # - Dependency injection between functions
    # - HTTP server configuration
    # - Service registration with mesh registry

  # Updated dependent agent with enhanced capabilities from v0.3_dev testing
  dependent_agent.py: |
    #!/usr/bin/env python3
    """
    Dependent Agent Example

    This demonstrates an agent that depends on capabilities from other agents:
    - Uses @mesh.tool with dependencies to require time_service capability
    - Shows how dependency injection automatically resolves and injects services
    - Minimal FastMCP setup with just two functions that depend on external services
    """

    from datetime import datetime

    import mesh
    from fastmcp import FastMCP

    # Single FastMCP server instance
    app = FastMCP("Dependent Service")


    # TESTING RACE CONDITION: Put McpAgent function LAST to see if order matters
    @app.tool()
    @mesh.tool(capability="race_test_mcpmesh", dependencies=["time_service"])
    def test_mcpmesh_first(
        test_data: str = "test", time_service: mesh.McpMeshAgent = None
    ) -> dict:
        """Test function with McpMeshAgent that's defined BEFORE McpAgent function."""
        timestamp = time_service() if time_service else "unknown"
        return {
            "test_data": test_data,
            "timestamp": timestamp,
            "proxy_type": "should_be_MCPClientProxy_if_order_matters",
            "function_order": "first",
        }


    @app.tool()
    @mesh.tool(capability="race_test_mcpagent", dependencies=["time_service"])
    def test_mcpagent_second(
        test_data: str = "test", time_service: mesh.McpMeshAgent = None
    ) -> dict:
        """Test function with McpMeshAgent that's defined AFTER McpMeshAgent function."""
        timestamp = time_service() if time_service else "unknown"
        return {
            "test_data": test_data,
            "timestamp": timestamp,
            "proxy_type": "should_be_FullMCPProxy",
            "function_order": "second",
        }


    @app.tool()
    @mesh.tool(capability="report_service", dependencies=["time_service"])
    def generate_report(
        title: str, content: str = "Sample content", time_service: mesh.McpMeshAgent = None
    ) -> dict:
        """Generate a timestamped report using the time service."""
        # Get timestamp from the injected time service
        timestamp = time_service() if time_service else "unknown"

        report = {
            "title": title,
            "content": content,
            "generated_at": timestamp,
            "agent": "dependent-service",
            "status": "completed",
        }

        return report


    @app.tool()
    @mesh.tool(capability="analysis_service", dependencies=["time_service"])
    def analyze_data(
        data: list, analysis_type: str = "basic", time_service: mesh.McpMeshAgent = None
    ) -> dict:
        """Analyze data with timestamp from time service."""
        # Get timestamp from the injected time service
        timestamp = time_service() if time_service else "unknown"

        # Simple analysis
        if not data:
            result = {"error": "No data provided", "count": 0, "average": None}
        else:
            # Try to analyze as numbers, fallback to general analysis
            try:
                numbers = [float(x) for x in data]
                result = {
                    "count": len(numbers),
                    "sum": sum(numbers),
                    "average": sum(numbers) / len(numbers),
                    "min": min(numbers),
                    "max": max(numbers),
                }
            except (ValueError, TypeError):
                # Fallback for non-numeric data
                result = {
                    "count": len(data),
                    "data_types": list(set(type(x).__name__ for x in data)),
                    "sample": data[:3] if len(data) > 3 else data,
                }

        analysis = {
            "analysis_type": analysis_type,
            "result": result,
            "analyzed_at": timestamp,
            "agent": "dependent-service",
        }

        return analysis


    @app.tool()
    @mesh.tool(capability="full_mcp_inspector", dependencies=["time_service"])
    async def inspect_remote_agent(
        agent_name: str = "fastmcp-service", time_service: mesh.McpMeshAgent = None
    ) -> dict:
        """Test Full MCP Proxy functionality - uses McpMeshAgent parameter type."""
        if not time_service:
            return {"error": "No time service available", "agent": "dependent-service"}

        # Get timestamp using basic call (McpMeshAgent compatibility)
        timestamp = time_service()

        inspection_result = {
            "agent_name": agent_name,
            "inspected_at": timestamp,
            "inspector": "dependent-service",
            "inspection_type": "full_mcp_test",
        }

        # Test basic proxy functionality
        try:
            # Simple test - just verify the proxy is working
            inspection_result["proxy_test"] = "success"
            inspection_result["note"] = "Basic proxy test completed successfully"
        except Exception as e:
            inspection_result["proxy_error"] = str(e)

        inspection_result["status"] = "completed"
        return inspection_result


    @app.tool()
    @mesh.tool(capability="session_test", dependencies=["session_counter"])
    async def test_session_affinity(
        test_rounds: int = 3,
        session_counter: mesh.McpMeshAgent = None,  # âœ… Using McpMeshAgent for session support
    ) -> dict:
        """Test session affinity using explicit session management (Phase 6)."""
        if not session_counter:
            return {
                "error": "No session_counter service available",
                "agent": "dependent-service",
            }

        try:
            # Simplified session test - just call the service multiple times
            results = []

            for round_num in range(1, test_rounds + 1):
                try:
                    # Basic call to session counter
                    result = session_counter(session_id=f"test-session-{round_num}", increment=round_num)
                    results.append({"round": round_num, "response": result})
                except Exception as e:
                    results.append({"round": round_num, "error": str(e)})

            return {
                "test_rounds": test_rounds,
                "results": results,
                "note": "Basic session test completed",
                "tested_at": datetime.now().isoformat(),
            }

        except Exception as e:
            return {
                "error": f"Session affinity test failed: {str(e)}",
                "agent": "dependent-service",
                "phase": "Phase 6 - Explicit session management",
                "tested_at": datetime.now().isoformat(),
            }


    # NEW ENHANCED FUNCTIONS - Less verbose thanks to enhanced proxy auto-configuration

    @app.tool()
    @mesh.tool(capability="enhanced_math_report", dependencies=["enhanced_math_service"])
    def create_math_report(operations: list, enhanced_math: mesh.McpMeshAgent = None) -> dict:
        """Create math report - enhanced proxy handles timeouts/retries automatically."""
        if not enhanced_math:
            return {"error": "Enhanced math service not available"}

        results = []
        for op in operations:
            # No timeout/retry logic needed - enhanced proxy handles it!
            result = enhanced_math(
                a=op.get("a", 0),
                b=op.get("b", 0),
                operation=op.get("operation", "add")
            )
            results.append(result)

        return {
            "report_type": "math_operations",
            "total_operations": len(operations),
            "results": results,
            "generated_at": datetime.now().isoformat(),
            "enhanced": True
        }


    @app.tool()
    @mesh.tool(capability="enhanced_time_report", dependencies=["enhanced_time_service"])
    def create_time_report(enhanced_time: mesh.McpMeshAgent = None) -> dict:
        """Create time report - enhanced proxy auto-configured with custom headers."""
        if not enhanced_time:
            return {"error": "Enhanced time service not available"}

        # Simple call - enhanced proxy adds headers and handles retries
        time_data = enhanced_time()

        return {
            "report_type": "time_status",
            "time_data": time_data,
            "report_generated_at": datetime.now().isoformat(),
            "enhanced": True,
            "note": "Enhanced proxy automatically added X-Service-Type and X-Enhanced headers"
        }


    @app.tool()
    @mesh.tool(capability="secure_config_report", dependencies=["secure_config_service"])
    def get_secure_config_report(config_type: str = "production", secure_config: mesh.McpMeshAgent = None) -> dict:
        """Get secure config report - enhanced proxy handles auth automatically."""
        if not secure_config:
            return {"error": "Secure config service not available"}

        # Simple call - enhanced proxy handles auth_required automatically
        config_data = secure_config(config_type=config_type)

        return {
            "report_type": "secure_configuration",
            "config_type": config_type,
            "config_data": config_data,
            "retrieved_at": datetime.now().isoformat(),
            "enhanced": True,
            "note": "Enhanced proxy automatically handled authentication requirements"
        }


    @app.tool()
    @mesh.tool(capability="enhanced_session_test", dependencies=["enhanced_session_counter"])
    async def test_enhanced_session_management(
        test_rounds: int = 3,
        enhanced_session: mesh.McpMeshAgent = None  # McpMeshAgent for full session support
    ) -> dict:
        """Test enhanced session management - auto-session handling."""
        if not enhanced_session:
            return {"error": "Enhanced session service not available"}

        try:
            # Basic enhanced session test
            results = []

            for round_num in range(1, test_rounds + 1):
                # Simple call to enhanced session counter
                result = enhanced_session(
                    session_id=f"enhanced-session-{round_num}",
                    increment=round_num,
                    metadata={"test_round": round_num, "enhanced": True}
                )
                results.append({"round": round_num, "result": result})

            return {
                "test_type": "enhanced_session_management",
                "test_rounds": test_rounds,
                "results": results,
                "tested_at": datetime.now().isoformat(),
                "enhanced": True,
                "note": "Enhanced session test completed"
            }

        except Exception as e:
            return {
                "error": f"Enhanced session test failed: {str(e)}",
                "enhanced": True
            }


    @app.tool()
    @mesh.tool(capability="streaming_data_consumer", dependencies=["streaming_data_service"])
    async def consume_streaming_data(
        data_size: int = 5,
        streaming_service: mesh.McpMeshAgent = None  # McpMeshAgent for streaming support
    ) -> dict:
        """Consume streaming data - enhanced proxy auto-selects streaming."""
        if not streaming_service:
            return {"error": "Streaming service not available"}

        try:
            # Basic streaming test - single call
            result = streaming_service(data_size=data_size)

            return {
                "consumption_type": "streaming_data_test",
                "result": result,
                "consumed_at": datetime.now().isoformat(),
                "enhanced": True,
                "note": "Basic streaming test completed"
            }

        except Exception as e:
            return {
                "error": f"Streaming consumption failed: {str(e)}",
                "enhanced": True
            }


    # AGENT configuration - depends on time_service from the FastMCP agent
    @mesh.agent(
        name="dependent-service",
        version="1.0.0",
        description="Dependent service that uses time_service capability",
        http_host="dependent-agent",
        http_port=9093,
        enable_http=True,
        auto_run=True,
    )
    class DependentService:
        """
        Agent that demonstrates dependency injection.

        This agent:
        1. Provides report_service and analysis_service capabilities
        2. Depends on time_service capability (from fastmcp-agent)
        3. Uses dependency injection to get timestamps from the time service
        4. Shows how mesh automatically resolves and injects dependencies
        """

        pass


    # No main method needed!
    # Mesh processor automatically handles:
    # - Dependency resolution and injection
    # - Service discovery and connection
    # - HTTP server configuration
    # - Service registration with mesh registry

  # Enhanced FastMCP agent with kwargs-configured capabilities
  enhanced_fastmcp_agent.py: |
    #!/usr/bin/env python3
    """
    Enhanced FastMCP Agent with kwargs-configured capabilities

    This demonstrates Phase 6 enhanced proxy auto-configuration:
    - @mesh.tool with timeout, retry_count, custom_headers kwargs
    - Streaming capabilities with streaming=True
    - Session management with session_required=True
    - Authentication requirements with auth_required=True
    """

    import json
    import asyncio
    from datetime import datetime
    from typing import AsyncGenerator

    import mesh
    from fastmcp import FastMCP

    # Single FastMCP server instance
    app = FastMCP("Enhanced FastMCP Service")


    # ENHANCED TOOLS with kwargs configuration
    @app.tool()
    @mesh.tool(
        capability="enhanced_time_service",
        tags=["system", "time", "enhanced"],
        timeout=10,
        retry_count=2,
        custom_headers={"X-Service-Type": "time", "X-Enhanced": "true"}
    )
    def get_enhanced_time() -> dict:
        """Get enhanced time with metadata - auto-configured with 10s timeout, 2 retries."""
        return {
            "timestamp": datetime.now().isoformat(),
            "timezone": "UTC",
            "service": "enhanced-time",
            "enhanced": True,
            "response_time_ms": 50
        }


    @app.tool()
    @mesh.tool(
        capability="enhanced_math_service",
        dependencies=["enhanced_time_service"],
        timeout=15,
        retry_count=3,
        custom_headers={"X-Service-Type": "math", "X-Compute-Heavy": "true"}
    )
    def calculate_enhanced(
        a: float, b: float, operation: str = "add", time_service: mesh.McpMeshAgent = None
    ) -> dict:
        """Enhanced math with timestamp - auto-configured with 15s timeout, 3 retries."""
        if operation == "add":
            result = a + b
        elif operation == "multiply":
            result = a * b
        elif operation == "subtract":
            result = a - b
        elif operation == "divide":
            result = a / b if b != 0 else None
        else:
            result = 0

        # Get enhanced timestamp
        time_data = time_service() if time_service else {"timestamp": "unknown"}

        return {
            "operation": operation,
            "operands": [a, b],
            "result": result,
            "computed_at": time_data.get("timestamp"),
            "service": "enhanced-math",
            "enhanced": True
        }


    @app.tool()
    @mesh.tool(
        capability="streaming_data_service",
        tags=["data", "streaming", "async"],
        streaming=True,
        timeout=300,  # Longer timeout for streaming
        custom_headers={"X-Stream-Type": "data", "X-Content-Type": "application/json"}
    )
    async def stream_data_processing(data_size: int = 10) -> AsyncGenerator[dict, None]:
        """Stream data processing results - auto-configured for streaming with 300s timeout."""
        yield {
            "event": "start",
            "data_size": data_size,
            "service": "streaming-data",
            "enhanced": True,
            "timestamp": datetime.now().isoformat()
        }

        for i in range(data_size):
            await asyncio.sleep(0.1)  # Simulate processing
            yield {
                "event": "data",
                "index": i,
                "processed_data": f"item_{i}",
                "progress": (i + 1) / data_size,
                "timestamp": datetime.now().isoformat()
            }

        yield {
            "event": "complete",
            "total_processed": data_size,
            "service": "streaming-data",
            "enhanced": True,
            "timestamp": datetime.now().isoformat()
        }


    @app.tool()
    @mesh.tool(
        capability="secure_config_service",
        tags=["config", "secure", "authenticated"],
        auth_required=True,
        timeout=20,
        custom_headers={"X-Security-Level": "high", "X-Auth-Required": "true"}
    )
    def get_secure_config(config_type: str = "default") -> dict:
        """Get secure configuration - requires authentication, 20s timeout."""
        configs = {
            "default": {"level": "basic", "features": ["logging", "metrics"]},
            "advanced": {"level": "advanced", "features": ["logging", "metrics", "tracing", "security"]},
            "production": {"level": "production", "features": ["all"], "security": "enhanced"}
        }

        return {
            "config_type": config_type,
            "config": configs.get(config_type, configs["default"]),
            "retrieved_at": datetime.now().isoformat(),
            "service": "secure-config",
            "enhanced": True,
            "auth_verified": True
        }


    @app.tool()
    @mesh.tool(
        capability="enhanced_session_counter",
        tags=["session", "stateful", "enhanced"],
        session_required=True,
        stateful=True,
        auto_session_management=True,
        timeout=30,
        custom_headers={"X-Session-Enabled": "true", "X-Stateful": "true"}
    )
    def enhanced_session_increment(session_id: str, increment: int = 1, metadata: dict = None) -> dict:
        """Enhanced session counter with metadata - auto session management, 30s timeout."""
        import os

        # Enhanced agent identification
        agent_id = os.getenv("AGENT_ID", "enhanced-fastmcp-service")
        pod_ip = os.getenv("POD_IP", "localhost")
        container_name = os.getenv("HOSTNAME", "unknown")

        # Enhanced in-memory storage
        if not hasattr(enhanced_session_increment, "_enhanced_counters"):
            enhanced_session_increment._enhanced_counters = {}
            enhanced_session_increment._session_metadata = {}

        # Get or initialize counter and metadata
        current_count = enhanced_session_increment._enhanced_counters.get(session_id, 0)
        new_count = current_count + increment
        enhanced_session_increment._enhanced_counters[session_id] = new_count

        # Store session metadata
        if metadata:
            enhanced_session_increment._session_metadata[session_id] = metadata

        return {
            "session_id": session_id,
            "previous_count": current_count,
            "increment": increment,
            "new_count": new_count,
            "handled_by_agent": agent_id,
            "handled_by_pod": pod_ip,
            "handled_by_container": container_name,
            "timestamp": datetime.now().isoformat(),
            "total_sessions": len(enhanced_session_increment._enhanced_counters),
            "session_metadata": enhanced_session_increment._session_metadata.get(session_id),
            "service": "enhanced-session",
            "enhanced": True,
            "auto_session_managed": True
        }


    # AGENT configuration - enhanced FastMCP service
    @mesh.agent(
        name="enhanced-fastmcp-service",
        version="2.0.0",
        description="Enhanced FastMCP service with kwargs-configured capabilities",
        http_port=9094,
        enable_http=True,
        auto_run=True,
    )
    class EnhancedFastMCPService:
        """
        Enhanced agent with kwargs-configured capabilities.

        Demonstrates:
        - Enhanced proxy auto-configuration via kwargs
        - Timeout management (10s, 15s, 20s, 30s, 300s)
        - Retry policies (2, 3 retries)
        - Custom headers for service identification
        - Streaming capabilities with proper timeouts
        - Authentication requirements
        - Session management with auto-session handling
        """
        pass


    # No main method needed!
    # Enhanced mesh processor automatically handles:
    # - Enhanced proxy creation with kwargs configuration
    # - Timeout management per capability
    # - Retry policies per capability
    # - Custom header injection
    # - Streaming auto-selection
    # - Session management automation
    # - Authentication flow handling
