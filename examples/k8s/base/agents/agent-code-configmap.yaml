apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-agent-code
  namespace: mcp-mesh
data:
  # Updated hello world agent with FastMCP integration
  hello_world.py: |
    #!/usr/bin/env python3
    """
    MCP Mesh Hello World Example with FastMCP Integration

    This example demonstrates the hybrid FastMCP + MCP Mesh approach:
    1. FastMCP decorators (@app.tool) for familiar MCP development
    2. MCP Mesh decorators (@mesh.tool) for dependency injection and orchestration
    3. Hybrid typing support for development flexibility
    4. Pure simplicity - just dual decorators, no manual setup!

    Start this agent, then start system_agent.py to see dependency injection in action!
    """

    from typing import Any

    import mesh
    from fastmcp import FastMCP

    # Single FastMCP server instance
    app = FastMCP("Hello World Service")


    # ===== MESH FUNCTION WITH SIMPLE TYPING =====
    # Uses Any type for maximum simplicity and flexibility


    @app.tool()
    @mesh.tool(
        capability="greeting",
        dependencies=["date_service"],
        description="Simple greeting with date dependency",
    )
    def hello_mesh_simple(date_service: Any = None) -> str:
        """
        MCP Mesh greeting with simple typing.

        Uses Any type for maximum flexibility - works with any proxy implementation.
        Great for prototyping and simple use cases.
        """
        if date_service is None:
            return "ðŸ‘‹ Hello from MCP Mesh! (Date service not available yet)"

        try:
            # Call the injected function - proxy implements __call__()
            current_date = date_service()
            return f"ðŸ‘‹ Hello from MCP Mesh! Today is {current_date}"
        except Exception as e:
            return f"ðŸ‘‹ Hello from MCP Mesh! (Error getting date: {e})"


    # ===== MESH FUNCTION WITH TYPED INTERFACE =====
    # Uses mesh.McpMeshAgent type for better IDE support and type safety


    @app.tool()
    @mesh.tool(
        capability="advanced_greeting",
        dependencies=[
            {
                "capability": "info",
                "tags": ["system", "general"],
            }  # Tag-based dependency!
        ],
        description="Advanced greeting with smart tag-based dependency resolution",
    )
    def hello_mesh_typed(info: mesh.McpMeshAgent | None = None) -> str:
        """
        MCP Mesh greeting with smart tag-based dependency resolution.

        This requests "info" capability with "system" + "general" tags.
        Registry will match SystemAgent_getInfo (not get_disk_info) based on tags!
        """
        if info is None:
            return "ðŸ‘‹ Hello from smart MCP Mesh! (info service not available yet)"

        try:
            # This will call the general system info (not disk info) due to smart tag matching!
            system_info = info()
            uptime = system_info.get("uptime_formatted", "unknown")
            server_name = system_info.get("server_name", "unknown")
            return f"ðŸ‘‹ Hello from smart MCP Mesh! Server: {server_name}, Uptime: {uptime}"
        except Exception as e:
            return f"ðŸ‘‹ Hello from smart MCP Mesh! (Error getting info: {e})"


    # ===== DEPENDENCY TEST FUNCTION =====
    # Shows multiple dependencies with different typing approaches


    @app.tool()
    @mesh.tool(
        capability="dependency_test",
        dependencies=[
            "date_service",  # Simple string dependency
            {
                "capability": "info",
                "tags": ["system", "disk"],
            },  # Tag-based: will get DISK info!
        ],
        description="Test hybrid dependencies: simple + tag-based resolution",
    )
    def test_dependencies(
        date_service: Any = None,
        info: mesh.McpMeshAgent | None = None,  # This will get the DISK info service!
    ) -> dict[str, Any]:
        """
        Test function showing hybrid dependency resolution.

        Demonstrates both simple string and tag-based dependencies:
        - date_service: simple string dependency
        - info with [system,disk] tags: will get disk info (not general info)!
        """
        result = {
            "test_name": "smart_dependency_demo",
            "date_service": "not_available",
            "disk_info_service": "not_available",  # This should get DISK info, not general info!
        }

        # Test simple Any type dependency
        if date_service is not None:
            try:
                date = date_service()  # Direct call
                result["date_service"] = f"available: {date}"
            except Exception as e:
                result["date_service"] = f"error: {e}"

        # Test tag-based dependency - should get DISK info service
        if info is not None:
            try:
                disk_info = (
                    info()
                )  # This should return disk/OS info, not general system info
                info_type = disk_info.get("info_type", "unknown")
                result["disk_info_service"] = (
                    f"available: {info_type} (smart tag matching worked!)"
                )
            except Exception as e:
                result["disk_info_service"] = f"error: {e}"

        return result


    # AGENT configuration - this tells mesh how to run the FastMCP server
    @mesh.agent(
        name="hello-world",
        version="1.0.0",
        description="Hello World service with FastMCP and mesh integration",
        http_port=9090,
        enable_http=True,
        auto_run=True,
    )
    class HelloWorldAgent:
        """
        Agent class that configures how mesh should run the FastMCP server.

        The mesh processor will:
        1. Discover the 'app' FastMCP instance
        2. Apply dependency injection to decorated functions
        3. Start the FastMCP HTTP server on the configured port
        4. Register all capabilities with the mesh registry
        """

        pass


    # No main method needed!
    # Mesh processor automatically handles:
    # - FastMCP server discovery and startup
    # - Dependency injection between functions
    # - HTTP server configuration
    # - Service registration with mesh registry

  # Updated system agent with FastMCP integration
  system_agent.py: |
    #!/usr/bin/env python3
    """
    MCP Mesh System Agent Example with FastMCP Integration

    This agent provides system information capabilities that other agents can depend on.
    Demonstrates the hybrid FastMCP + MCP Mesh architecture:

    - FastMCP decorators (@app.tool) for familiar MCP development
    - MCP Mesh decorators (@mesh.tool) for dependency injection and orchestration
    - Tools: Function names (MCP function names)
    - Capabilities: What others can depend on
    - Pure simplicity: Just dual decorators, no manual setup!

    Function names can be different from capability names for maximum flexibility.
    """

    from datetime import datetime
    from typing import Any

    import mesh
    from fastmcp import FastMCP

    # Single FastMCP server instance
    app = FastMCP("System Agent Service")


    # Store start time for uptime calculations
    start_time = datetime.now()

    # ===== DATE SERVICE =====
    # Tool: "get_current_time" | Capability: "date_service"


    @app.tool()
    @mesh.tool(
        capability="date_service",  # Capability name (what others depend on)
        description="Get current system date and time",
        version="1.0.0",
        tags=["system", "time", "clock"],
    )
    def get_current_time() -> str:  # Function name can be anything!
        """
        Get the current system date and time.

        This function provides the "date_service" capability.
        Function name 'get_current_time' can be anything - capability name matters!

        Returns:
            Formatted date and time string
        """
        now = datetime.now()
        return now.strftime("%B %d, %Y at %I:%M %p")


    # ===== GENERAL SYSTEM INFO SERVICE =====
    # Tool: "fetch_system_overview" | Capability: "info"


    @app.tool()
    @mesh.tool(
        capability="info",  # Generic capability name for smart matching
        description="Get comprehensive system information",
        version="1.0.0",
        tags=["system", "general", "monitoring"],  # Tags for smart resolution
    )
    def fetch_system_overview() -> dict[str, Any]:  # Clear: function name â‰  capability
        """
        Get comprehensive system information.

        This function provides the "info" capability with "system" + "general" tags.
        Smart matching: hello_world dependency "info" with "system" tag will match this.

        Returns:
            Dictionary containing system information
        """
        uptime = datetime.now() - start_time

        return {
            "server_name": "system-agent",
            "current_time": datetime.now().strftime("%B %d, %Y at %I:%M %p"),
            "uptime_seconds": uptime.total_seconds(),
            "uptime_formatted": f"{uptime.total_seconds():.1f} seconds",
            "version": "1.0.0",
            "capabilities_provided": [
                "date_service",  # From get_current_time() function
                "info",  # From fetch_system_overview() function - generic capability with smart tag matching
            ],
            "agent_type": "system_service",
        }


    # ===== UPTIME SERVICE (Different function name vs capability) =====
    # Tool: "get_uptime" | Capability: "uptime_info"


    @app.tool()
    @mesh.tool(
        capability="uptime_info",  # Capability name (what others depend on)
        description="Get system uptime information",
        version="1.0.0",
        tags=["system", "uptime"],
    )
    def check_how_long_running() -> str:  # Function name can be descriptive and different!
        """
        Get system uptime information.

        This demonstrates function_name != capability:
        - MCP calls: "check_how_long_running"
        - Capability provided: "uptime_info"
        - Dependencies declare: "uptime_info"

        Returns:
            Human-readable uptime string
        """
        uptime = datetime.now() - start_time
        return f"System running for {uptime.total_seconds():.1f} seconds"


    # ===== SECOND INFO SERVICE (Different Tags) =====
    # Same capability "info" but different tags - shows tag-based filtering


    @app.tool()
    @mesh.tool(
        capability="info",  # Same capability name!
        description="Get disk and OS information",
        version="1.0.0",
        tags=[
            "system",
            "disk",
            "os",
        ],  # Different tags - won't match "general" requests
    )
    def analyze_storage_and_os() -> dict[str, Any]:  # Completely different function name!
        """
        Get disk and OS information.

        This also provides "info" capability but with "disk" + "os" tags.
        Smart matching: requests for "info" with "general" tags won't match this.
        Only requests specifically wanting "disk" or "os" info will get this.
        """
        return {
            "info_type": "disk_and_os",
            "disk_usage": "simulated_75_percent",
            "os_version": "simulated_linux_6.x",
            "filesystem": "ext4",
            "mount_points": ["/", "/home", "/var"],
            "tags": ["disk", "os", "system"],
            "note": "This provides 'info' capability but with different tags than general system info",
        }


    # ===== STATUS SERVICE WITH DEPENDENCY =====


    @app.tool()
    @mesh.tool(
        capability="health_check",
        dependencies=["date_service"],  # Depends on capability name, not function name!
        description="Get system status with current time",
        version="1.0.0",
    )
    def perform_health_diagnostic(
        date_service: mesh.McpMeshAgent | None = None,
    ) -> dict[str, Any]:
        """
        Get system status including current time.

        This tool both provides AND consumes capabilities:
        - Provides: "health_check" (via perform_health_diagnostic function)
        - Consumes: "date_service" (from get_current_time function)

        Demonstrates how agents can be both providers and consumers.
        """
        uptime = datetime.now() - start_time

        status = {
            "status": "healthy",
            "uptime_seconds": uptime.total_seconds(),
            "memory_usage": "simulated_normal",
            "cpu_usage": "simulated_low",
            "service_name": "system-agent",
        }

        # Use injected date service if available
        if date_service is not None:
            try:
                current_time = date_service()
                status["timestamp"] = current_time
                status["time_service"] = "available"
            except Exception as e:
                status["timestamp"] = "error"
                status["time_service"] = f"error: {e}"
        else:
            status["timestamp"] = "date_service_unavailable"
            status["time_service"] = "not_injected"

        return status


    # AGENT configuration - this tells mesh how to run the FastMCP server
    @mesh.agent(
        name="system-agent",
        version="1.0.0",
        description="System Agent service with FastMCP and mesh integration",
        http_port=8080,
        enable_http=True,
        auto_run=True,
    )
    class SystemAgent:
        """
        Agent class that configures how mesh should run the FastMCP server.

        The mesh processor will:
        1. Discover the 'app' FastMCP instance
        2. Apply dependency injection to decorated functions
        3. Start the FastMCP HTTP server on the configured port
        4. Register all capabilities with the mesh registry
        """

        pass


    # No main method needed!
    # Mesh processor automatically handles:
    # - FastMCP server discovery and startup
    # - Dependency injection between functions
    # - HTTP server configuration
    # - Service registration with mesh registry

  # FastMCP agent with proper mesh integration (working version from Docker Compose)
  fastmcp_agent.py: |
    #!/usr/bin/env python3
    """
    FastMCP Agent with Mesh Integration Example

    This demonstrates the ideal developer experience:
    - Keep familiar FastMCP decorators (@app.tool, @app.prompt, @app.resource)
    - Add minimal mesh decorators (@mesh.tool, @mesh.agent) for DI and orchestration
    - No main method or server management needed - mesh handles it automatically
    """

    import json
    from datetime import datetime

    import mesh
    from fastmcp import FastMCP

    # Single FastMCP server instance
    app = FastMCP("FastMCP Service")


    # PROMPTS with mesh integration
    @app.prompt()
    @mesh.tool(capability="prompt_service", dependencies=["time_service"])
    def analysis_prompt(
        topic: str, depth: str = "basic", time_service: mesh.McpMeshAgent = None
    ) -> str:
        """Generate analysis prompt with current time."""
        timestamp = time_service() if time_service else "unknown"

        return f"""Please analyze the following topic in detail:

    Topic: {topic}
    Analysis Depth: {depth}
    Generated At: {timestamp}

    Provide:
    1. Overview and context
    2. Key points and insights
    3. Conclusions and recommendations

    Focus on delivering {depth} level analysis.
    """


    # TOOLS with mesh integration
    @app.tool()
    @mesh.tool(capability="time_service", tags=["system", "time"])
    def get_current_time() -> str:
        """Get the current system time."""
        return datetime.now().isoformat()


    @app.tool()
    @mesh.tool(capability="math_service", dependencies=["time_service"])
    def calculate_with_timestamp(
        a: float, b: float, operation: str = "add", time_service: mesh.McpMeshAgent = None
    ) -> dict:
        """Perform math operation with timestamp from time service."""
        if operation == "add":
            result = a + b
        elif operation == "multiply":
            result = a * b
        elif operation == "subtract":
            result = a - b
        else:
            result = 0

        timestamp = time_service() if time_service else "unknown"

        return {
            "operation": operation,
            "operands": [a, b],
            "result": result,
            "timestamp": timestamp,
        }


    @app.tool()
    @mesh.tool(capability="data_service", tags=["data", "json"])
    def process_data(data: str, format_type: str = "json") -> dict:
        """Process and format data."""
        return {
            "input": data,
            "format": format_type,
            "processed_at": datetime.now().isoformat(),
            "length": len(data),
        }


    @app.prompt()
    @mesh.tool(capability="template_service")
    def report_template(title: str, sections: list | None = None) -> str:
        """Generate report template."""
        sections = sections or ["Introduction", "Analysis", "Conclusion"]

        template = f"""# {title}

    Generated: {datetime.now().isoformat()}

    """

        for i, section in enumerate(sections, 1):
            template += f"## {i}. {section}\n\n[Content for {section.lower()}]\n\n"

        return template


    # RESOURCES with mesh integration
    @app.resource("config://service")
    @mesh.tool(capability="config_service")
    async def service_config() -> str:
        """Service configuration data."""
        config = {
            "service_name": "FastMCP Service",
            "version": "1.0.0",
            "capabilities": [
                "time_service",
                "math_service",
                "data_service",
                "prompt_service",
                "template_service",
                "config_service",
            ],
            "transport": "http",
            "mesh_enabled": True,
            "created_at": datetime.now().isoformat(),
        }
        return json.dumps(config, indent=2)


    @app.resource("status://health/{status_type}")
    @mesh.tool(capability="status_service", dependencies=["time_service"])
    async def health_status(
        status_type: str, time_service: mesh.McpMeshAgent = None
    ) -> str:
        """Health status information."""
        timestamp = time_service() if time_service else "unknown"

        status = {
            "status": "healthy",
            "status_type": status_type,
            "uptime": "running",
            "last_check": timestamp,
            "services": {
                "fastmcp": "active",
                "mesh": "integrated",
                "dependencies": "resolved",
            },
        }
        return json.dumps(status, indent=2)


    # AGENT configuration - this tells mesh how to run the FastMCP server
    @mesh.agent(
        name="fastmcp-service",
        version="1.0.0",
        description="FastMCP service with mesh integration",
        http_port=9092,
        enable_http=True,
        auto_run=True,
    )
    class FastMCPService:
        """
        Agent class that configures how mesh should run the FastMCP server.

        The mesh processor will:
        1. Discover the 'app' FastMCP instance
        2. Apply dependency injection to decorated functions
        3. Start the FastMCP HTTP server on the configured port
        4. Register all capabilities with the mesh registry
        """

        pass


    # No main method needed!
    # Mesh processor automatically handles:
    # - FastMCP server discovery and startup
    # - Dependency injection between functions
    # - HTTP server configuration
    # - Service registration with mesh registry

  # Dependent agent that consumes services from other agents
  dependent_agent.py: |
    #!/usr/bin/env python3
    """
    Dependent Agent Example

    This demonstrates an agent that depends on capabilities from other agents:
    - Uses @mesh.tool with dependencies to require time_service capability
    - Shows how dependency injection automatically resolves and injects services
    - Minimal FastMCP setup with just two functions that depend on external services
    """


    import mesh
    from fastmcp import FastMCP

    # Single FastMCP server instance
    app = FastMCP("Dependent Service")


    @app.tool()
    @mesh.tool(capability="report_service", dependencies=["time_service"])
    def generate_report(
        title: str, content: str = "Sample content", time_service: mesh.McpMeshAgent = None
    ) -> dict:
        """Generate a timestamped report using the time service."""
        # Get timestamp from the injected time service
        timestamp = time_service() if time_service else "unknown"

        report = {
            "title": title,
            "content": content,
            "generated_at": timestamp,
            "agent": "dependent-service",
            "status": "completed",
        }

        return report


    @app.tool()
    @mesh.tool(capability="analysis_service", dependencies=["time_service"])
    def analyze_data(
        data: list, analysis_type: str = "basic", time_service: mesh.McpMeshAgent = None
    ) -> dict:
        """Analyze data with timestamp from time service."""
        # Get timestamp from the injected time service
        timestamp = time_service() if time_service else "unknown"

        # Simple analysis
        if not data:
            result = {"error": "No data provided", "count": 0, "average": None}
        else:
            # Try to analyze as numbers, fallback to general analysis
            try:
                numbers = [float(x) for x in data]
                result = {
                    "count": len(numbers),
                    "sum": sum(numbers),
                    "average": sum(numbers) / len(numbers),
                    "min": min(numbers),
                    "max": max(numbers),
                }
            except (ValueError, TypeError):
                # Fallback for non-numeric data
                result = {
                    "count": len(data),
                    "data_types": list(set(type(x).__name__ for x in data)),
                    "sample": data[:3] if len(data) > 3 else data,
                }

        analysis = {
            "analysis_type": analysis_type,
            "result": result,
            "analyzed_at": timestamp,
            "agent": "dependent-service",
        }

        return analysis


    # AGENT configuration - depends on time_service from the FastMCP agent
    @mesh.agent(
        name="dependent-service",
        version="1.0.0",
        description="Dependent service that uses time_service capability",
        http_host="dependent-agent",
        http_port=9093,
        enable_http=True,
        auto_run=True,
    )
    class DependentService:
        """
        Agent that demonstrates dependency injection.

        This agent:
        1. Provides report_service and analysis_service capabilities
        2. Depends on time_service capability (from fastmcp-agent)
        3. Uses dependency injection to get timestamps from the time service
        4. Shows how mesh automatically resolves and injects dependencies
        """

        pass


    # No main method needed!
    # Mesh processor automatically handles:
    # - Dependency resolution and injection
    # - Service discovery and connection
    # - HTTP server configuration
    # - Service registration with mesh registry
