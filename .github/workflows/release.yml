name: Release

on:
  release:
    types: [published]
  push:
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      version:
        description: "Version (e.g., v0.9.0)"
        required: true
        default: "v0.9.0"
      environment:
        description: "Environment"
        type: choice
        options: [production, test]
        default: production

env:
  REGISTRY: mcpmesh
  PYTHON_VERSION: "3.11"
  GO_VERSION: "1.23"

jobs:
  # Build Go binaries for multiple platforms
  build-binaries:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false

      - name: Install cross-compilation toolchain
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu gcc-x86-64-linux-gnu

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Building version: ${VERSION}"

          # Check if prerelease
          VERSION_NO_V=${VERSION#v}
          if [[ "$VERSION_NO_V" == *"-beta"* ]] || \
             [[ "$VERSION_NO_V" == *"-rc"* ]] || \
             [[ "$VERSION_NO_V" == *"-alpha"* ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi

      - name: Build binaries
        env:
          VERSION: ${{ steps.version.outputs.version }}
          PLATFORMS: "linux/amd64,linux/arm64"
        run: ./packaging/scripts/build-binaries.sh

      - name: Upload release assets
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            dist/*.tar.gz
            dist/*.zip
            dist/checksums.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload artifacts
        if: github.event_name != 'release'
        uses: actions/upload-artifact@v4
        with:
          name: binaries-${{ steps.version.outputs.version }}
          path: |
            dist/*.tar.gz
            dist/*.zip
            dist/checksums.txt

  # Build macOS binaries natively
  build-macos-binaries:
    runs-on: macos-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Building macOS version: ${VERSION}"

      - name: Build macOS binaries
        env:
          VERSION: ${{ steps.version.outputs.version }}
          PLATFORMS: "darwin/amd64,darwin/arm64"
          OUTPUT_DIR: "dist-macos"
        run: ./packaging/scripts/build-binaries.sh

      - name: Upload release assets
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            dist-macos/*.tar.gz
            dist-macos/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload artifacts
        if: github.event_name != 'release'
        uses: actions/upload-artifact@v4
        with:
          name: macos-binaries-${{ steps.version.outputs.version }}
          path: |
            dist-macos/*.tar.gz
            dist-macos/*.zip

  # Build Rust core wheels for all platforms using maturin
  build-rust-wheels:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux x86_64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            artifact-name: wheels-linux-x86_64
          # Linux aarch64 (use zig for cross-compilation to avoid ring crate issues)
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            artifact-name: wheels-linux-aarch64
            use-zig: true
          # macOS x86_64 (cross-compile from ARM64 runner)
          - os: macos-14
            target: x86_64-apple-darwin
            artifact-name: wheels-macos-x86_64
          # macOS aarch64 (Apple Silicon)
          - os: macos-14
            target: aarch64-apple-darwin
            artifact-name: wheels-macos-aarch64
          # Windows x86_64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            artifact-name: wheels-windows-x86_64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          VERSION=${VERSION#v}  # Remove 'v' prefix

          # SemVer format (for Cargo.toml - crates.io supports SemVer prereleases)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          # PyPI PEP 440 format: 0.8.0-beta.1 → 0.8.0b1, 0.8.0-rc.1 → 0.8.0rc1
          VERSION_PYPI=$(echo "$VERSION" | sed 's/-beta\./b/' | sed 's/-rc\./rc/' | sed 's/-alpha\./a/')
          echo "version_pypi=${VERSION_PYPI}" >> $GITHUB_OUTPUT

          # Check if prerelease
          if [[ "$VERSION" == *"-beta"* ]] || [[ "$VERSION" == *"-rc"* ]] || [[ "$VERSION" == *"-alpha"* ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi

          echo "Building Rust wheels for version: ${VERSION} (PyPI: ${VERSION_PYPI})"

      - name: Update version in Cargo.toml and pyproject.toml
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          VERSION_PYPI="${{ steps.version.outputs.version_pypi }}"
          cd src/runtime/core
          # Update Cargo.toml (uses SemVer)
          sed -i.bak "s/^version = \".*\"/version = \"${VERSION}\"/" Cargo.toml
          rm -f Cargo.toml.bak
          echo "Updated Cargo.toml version to: ${VERSION}"
          grep "^version" Cargo.toml
          # Update pyproject.toml (uses PEP 440 for PyPI)
          sed -i.bak "s/^version = \".*\"/version = \"${VERSION_PYPI}\"/" pyproject.toml
          rm -f pyproject.toml.bak
          echo "Updated pyproject.toml version to: ${VERSION_PYPI}"
          grep "^version" pyproject.toml

      - name: Set up Python versions
        uses: actions/setup-python@v5
        with:
          python-version: |
            3.11
            3.12
            3.13
            3.14

      - name: Install Zig
        if: matrix.use-zig
        uses: mlugg/setup-zig@v2
        with:
          version: "0.14.0"

      - name: Install auditwheel and patchelf (for host builds)
        if: matrix.use-zig
        run: |
          pip install auditwheel
          sudo apt-get update && sudo apt-get install -y patchelf

      - name: Build wheels with maturin
        uses: PyO3/maturin-action@v1
        with:
          working-directory: src/runtime/core
          target: ${{ matrix.target }}
          manylinux: auto
          container: ${{ matrix.use-zig && 'off' || '' }}
          args: >-
            --release --out dist
            -i python3.11 python3.12 python3.13 python3.14
            ${{ matrix.use-zig && '--zig' || '' }}

      - name: Upload wheel artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: src/runtime/core/dist/*.whl
          if-no-files-found: error

  # Build Rust FFI libraries for Java SDK (all platforms in one fat JAR)
  build-rust-ffi-java:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            classifier: linux-x86_64
            lib-name: libmcp_mesh_core.so
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            classifier: linux-aarch_64
            lib-name: libmcp_mesh_core.so
            use-cross: true
          - os: macos-14
            target: x86_64-apple-darwin
            classifier: osx-x86_64
            lib-name: libmcp_mesh_core.dylib
          - os: macos-14
            target: aarch64-apple-darwin
            classifier: osx-aarch_64
            lib-name: libmcp_mesh_core.dylib
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross-compilation tools (Linux ARM64)
        if: matrix.use-cross
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu

      - name: Build Rust FFI library
        env:
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER: ${{ matrix.use-cross && 'aarch64-linux-gnu-gcc' || '' }}
        run: |
          cd src/runtime/core
          cargo build --release --target ${{ matrix.target }} --features ffi --no-default-features

      - name: Upload native library
        uses: actions/upload-artifact@v4
        with:
          name: java-native-${{ matrix.classifier }}
          path: src/runtime/core/target/${{ matrix.target }}/release/${{ matrix.lib-name }}
          if-no-files-found: error

  # Publish Java SDK to Maven Central via Sonatype Central Portal
  publish-java-sdk:
    runs-on: ubuntu-latest
    needs: [build-rust-ffi-java]
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          VERSION=${VERSION#v}  # Remove 'v' prefix
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Publishing Java SDK version: ${VERSION}"

      - name: Import GPG key
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          echo "Imported GPG key: F94266795DCA259D"
          echo "D3B274C5F3344FD4DCC969F9F94266795DCA259D:6:" | gpg --import-ownertrust

      - name: Download native libraries
        uses: actions/download-artifact@v4
        with:
          pattern: java-native-*
          path: native-libs/

      - name: Bundle native libraries into fat JAR
        run: |
          NATIVE_DIR=src/runtime/java/mcp-mesh-native/src/main/resources/META-INF/native
          echo "Bundling native libraries into ${NATIVE_DIR}..."
          for classifier in linux-x86_64 linux-aarch_64 osx-x86_64 osx-aarch_64; do
            mkdir -p "${NATIVE_DIR}/${classifier}"
            cp native-libs/java-native-${classifier}/* "${NATIVE_DIR}/${classifier}/"
            echo "  ${classifier}: $(ls ${NATIVE_DIR}/${classifier}/)"
          done
          echo "Native library bundle complete"

      - name: Set version in all POMs
        run: |
          cd src/runtime/java
          mvn versions:set -DnewVersion=${{ steps.version.outputs.version }} -DgenerateBackupPoms=false
          # BOM has no <parent> element, so reactor versions:set doesn't reach it
          mvn -f mcp-mesh-bom/pom.xml versions:set -DnewVersion=${{ steps.version.outputs.version }} -DgenerateBackupPoms=false
          echo "Updated all POM versions to: ${{ steps.version.outputs.version }}"

      - name: Build, sign, and package all modules
        run: |
          cd src/runtime/java
          mvn clean verify -DskipTests \
            -Dgpg.skip=false \
            -Dgpg.passphrase="" \
            -Dgpg.keyname="F94266795DCA259D!"

      - name: Publish to Maven Central
        env:
          SONATYPE_USERNAME: ${{ secrets.SONATYPE_USERNAME }}
          SONATYPE_TOKEN: ${{ secrets.SONATYPE_TOKEN }}
        run: |
          cd src/runtime/java
          bash ../../../packaging/scripts/publish-java.sh ${{ steps.version.outputs.version }}

  # Publish Rust core wheels to PyPI
  publish-rust-core:
    runs-on: ubuntu-latest
    needs: [build-rust-wheels]
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          VERSION=${VERSION#v}  # Remove 'v' prefix

          # PyPI PEP 440 format: 0.8.0-beta.1 → 0.8.0b1
          VERSION_PYPI=$(echo "$VERSION" | sed 's/-beta\./b/' | sed 's/-rc\./rc/' | sed 's/-alpha\./a/')
          echo "version_pypi=${VERSION_PYPI}" >> $GITHUB_OUTPUT
          echo "Publishing Rust core wheels version: ${VERSION} (PyPI: ${VERSION_PYPI})"

      - name: Download all wheel artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: wheels-*
          merge-multiple: true
          path: dist

      - name: List wheels
        run: |
          echo "Wheels to publish:"
          ls -la dist/

      - name: Publish mcp-mesh-core to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist/
          password: ${{ secrets.PYPI_API_TOKEN }}
          skip-existing: true

      - name: Wait for PyPI to index mcp-mesh-core
        run: |
          VERSION="${{ steps.version.outputs.version_pypi }}"
          echo "Waiting for PyPI to index mcp-mesh-core==${VERSION}..."
          MAX_ATTEMPTS=30
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking PyPI..."
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://pypi.org/pypi/mcp-mesh-core/${VERSION}/json")
            echo "  PyPI API: HTTP $HTTP_STATUS"
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "✅ mcp-mesh-core==${VERSION} is now available on PyPI"
              exit 0
            fi
            echo "Not indexed yet, waiting 10 seconds..."
            sleep 10
          done
          echo "❌ ERROR: mcp-mesh-core==${VERSION} not available on PyPI after ${MAX_ATTEMPTS} attempts (5 minutes)"
          exit 1

  # Build Node.js native bindings for @mcpmesh/core using napi-rs
  build-node-bindings:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux x86_64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            artifact-name: node-bindings-linux-x64
          # Linux aarch64
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            artifact-name: node-bindings-linux-arm64
          # macOS x86_64
          - os: macos-14
            target: x86_64-apple-darwin
            artifact-name: node-bindings-macos-x64
          # macOS aarch64 (Apple Silicon)
          - os: macos-14
            target: aarch64-apple-darwin
            artifact-name: node-bindings-macos-arm64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          registry-url: "https://registry.npmjs.org"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross-compilation tools (Linux ARM64)
        if: matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu

      - name: Determine version
        id: version
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          VERSION=${VERSION#v}  # Remove 'v' prefix
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          # Check if prerelease
          if [[ "$VERSION" == *"-beta"* ]] || [[ "$VERSION" == *"-rc"* ]] || [[ "$VERSION" == *"-alpha"* ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "npm_tag=beta" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "npm_tag=latest" >> $GITHUB_OUTPUT
          fi

          echo "Building Node.js bindings for version: ${VERSION}"

      - name: Update version in package.json
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          cd src/runtime/core/typescript
          npm version ${VERSION} --no-git-tag-version --allow-same-version --ignore-scripts
          echo "Updated package.json version to: ${VERSION}"
          cat package.json

      - name: Install dependencies
        working-directory: src/runtime/core/typescript
        run: npm install

      - name: Build native bindings
        working-directory: src/runtime/core/typescript
        env:
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER: aarch64-linux-gnu-gcc
        run: |
          npx napi build --platform --release \
            --target ${{ matrix.target }} \
            --manifest-path ../Cargo.toml \
            --features typescript --no-default-features -o .

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: |
            src/runtime/core/typescript/*.node
            src/runtime/core/typescript/package.json
            src/runtime/core/typescript/index.js
            src/runtime/core/typescript/index.d.ts
          if-no-files-found: error

  # Publish @mcpmesh/core to npm
  publish-node-core:
    runs-on: ubuntu-latest
    needs: [build-node-bindings]
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          registry-url: "https://registry.npmjs.org"

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          VERSION=${VERSION#v}  # Remove 'v' prefix
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          # Check if prerelease
          if [[ "$VERSION" == *"-beta"* ]] || [[ "$VERSION" == *"-rc"* ]] || [[ "$VERSION" == *"-alpha"* ]]; then
            echo "npm_tag=beta" >> $GITHUB_OUTPUT
          else
            echo "npm_tag=latest" >> $GITHUB_OUTPUT
          fi

      - name: Download all node binding artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: node-bindings-*
          path: artifacts

      - name: Prepare npm package
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          mkdir -p dist/node-core

          # List available artifacts for debugging
          echo "Available artifacts:"
          find artifacts -type f | head -50

          # Artifacts are downloaded directly without source path structure
          ARTIFACT_BASE="artifacts/node-bindings-linux-x64"

          # Copy base files from first artifact (they're all the same except .node files)
          cp "${ARTIFACT_BASE}/package.json" dist/node-core/

          # Copy index.js and index.d.ts (these are required)
          if [ -f "${ARTIFACT_BASE}/index.js" ]; then
            cp "${ARTIFACT_BASE}/index.js" dist/node-core/
          else
            echo "❌ ERROR: index.js not found in artifacts at ${ARTIFACT_BASE}"
            exit 1
          fi

          if [ -f "${ARTIFACT_BASE}/index.d.ts" ]; then
            cp "${ARTIFACT_BASE}/index.d.ts" dist/node-core/
          else
            echo "❌ ERROR: index.d.ts not found in artifacts at ${ARTIFACT_BASE}"
            exit 1
          fi

          # Copy all .node files from each platform
          NODE_FILES=$(find artifacts -name "*.node" | wc -l)
          echo "Found ${NODE_FILES} .node files"
          if [ "$NODE_FILES" -eq 0 ]; then
            echo "❌ ERROR: No .node binary files found in artifacts"
            exit 1
          fi
          find artifacts -name "*.node" -exec cp {} dist/node-core/ \;

          # List contents
          echo "Package contents:"
          ls -la dist/node-core/

          # Validate package.json
          echo "Package.json contents:"
          cat dist/node-core/package.json

      - name: Publish @mcpmesh/core to npm
        working-directory: dist/node-core
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TAG: ${{ steps.version.outputs.npm_tag }}
        run: |
          echo "Publishing @mcpmesh/core with tag ${NPM_TAG}..."
          # Use --ignore-scripts since prepublishOnly runs napi which isn't in the artifact
          npm publish --access public --tag "${NPM_TAG}" --ignore-scripts

      - name: Wait for npm to index @mcpmesh/core
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Waiting for npm to index @mcpmesh/core@${VERSION}..."
          MAX_ATTEMPTS=18
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking if @mcpmesh/core@${VERSION} is available..."
            if npm view @mcpmesh/core@${VERSION} version 2>/dev/null; then
              echo "✅ @mcpmesh/core@${VERSION} is now available on npm"
              exit 0
            fi
            echo "Package not yet indexed, waiting 10 seconds..."
            sleep 10
          done
          echo "❌ ERROR: @mcpmesh/core@${VERSION} not available after ${MAX_ATTEMPTS} attempts"
          exit 1

  # Publish @mcpmesh/sdk to npm
  publish-typescript-sdk:
    runs-on: ubuntu-latest
    needs: [publish-node-core]
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          registry-url: "https://registry.npmjs.org"

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          VERSION=${VERSION#v}  # Remove 'v' prefix
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          # Check if prerelease
          if [[ "$VERSION" == *"-beta"* ]] || [[ "$VERSION" == *"-rc"* ]] || [[ "$VERSION" == *"-alpha"* ]]; then
            echo "npm_tag=beta" >> $GITHUB_OUTPUT
          else
            echo "npm_tag=latest" >> $GITHUB_OUTPUT
          fi

      - name: Update SDK version and dependencies
        working-directory: src/runtime/typescript
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Update version
          npm version ${VERSION} --no-git-tag-version --allow-same-version --ignore-scripts

          # Update @mcpmesh/core dependency from file: to npm version
          sed -i 's|"@mcpmesh/core": "file:../core/typescript"|"@mcpmesh/core": "'"${VERSION}"'"|' package.json

          echo "Updated package.json:"
          cat package.json

      - name: Install dependencies (with retry)
        working-directory: src/runtime/typescript
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          MAX_ATTEMPTS=3
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Installing dependencies..."
            if npm install; then
              echo "✅ Dependencies installed successfully"
              exit 0
            fi
            echo "npm install failed, waiting 30 seconds before retry..."
            sleep 30
          done
          echo "❌ Failed to install dependencies after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Build SDK
        working-directory: src/runtime/typescript
        run: npm run build

      - name: Publish @mcpmesh/sdk to npm
        working-directory: src/runtime/typescript
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TAG: ${{ steps.version.outputs.npm_tag }}
        run: |
          echo "Publishing @mcpmesh/sdk with tag ${NPM_TAG}..."
          npm publish --access public --tag "${NPM_TAG}"

      - name: Wait for npm to index @mcpmesh/sdk
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Waiting for npm to index @mcpmesh/sdk@${VERSION}..."
          MAX_ATTEMPTS=12
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking if @mcpmesh/sdk@${VERSION} is available..."
            if npm view @mcpmesh/sdk@${VERSION} version 2>/dev/null; then
              echo "✅ @mcpmesh/sdk@${VERSION} is now available on npm"
              exit 0
            fi
            echo "Package not yet indexed, waiting 10 seconds..."
            sleep 10
          done
          echo "⚠️ Package may not be fully indexed yet, proceeding anyway..."

  # Combine checksums from all platforms (for real releases)
  combine-checksums:
    runs-on: ubuntu-latest
    needs: [build-binaries, build-macos-binaries]
    if: github.event_name == 'release'
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Download release assets
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          mkdir -p dist-linux dist-macos

          # Download Linux binaries from release
          gh release download "${VERSION}" --pattern "*linux*.tar.gz" --dir dist-linux

          # Download macOS binaries from release
          gh release download "${VERSION}" --pattern "*darwin*.tar.gz" --dir dist-macos
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate combined checksums
        run: |
          mkdir -p dist-combined

          # Copy all archives to combined directory
          find dist-linux -name "*.tar.gz" -o -name "*.zip" | xargs -I {} cp {} dist-combined/
          find dist-macos -name "*.tar.gz" -o -name "*.zip" | xargs -I {} cp {} dist-combined/

          # Generate combined checksums
          cd dist-combined
          if command -v sha256sum &> /dev/null; then
            sha256sum *.tar.gz > checksums.txt
            if ls *.zip &> /dev/null; then
              sha256sum *.zip >> checksums.txt
            fi
          elif command -v shasum &> /dev/null; then
            shasum -a 256 *.tar.gz > checksums.txt
            if ls *.zip &> /dev/null; then
              shasum -a 256 *.zip >> checksums.txt
            fi
          fi

          echo "Combined checksums:"
          cat checksums.txt

      - name: Upload combined checksums to release
        uses: softprops/action-gh-release@v1
        with:
          files: dist-combined/checksums.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Publish npm packages
  # Downloads pre-built binaries from GitHub releases instead of building
  publish-npm:
    runs-on: ubuntu-latest
    needs: [build-binaries, build-macos-binaries, combine-checksums]
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          registry-url: "https://registry.npmjs.org"

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          VERSION=${VERSION#v}  # Remove 'v' prefix
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          # Check if prerelease
          if [[ "$VERSION" == *"-beta"* ]] || [[ "$VERSION" == *"-rc"* ]] || [[ "$VERSION" == *"-alpha"* ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "npm_tag=beta" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "npm_tag=latest" >> $GITHUB_OUTPUT
          fi

          echo "Building npm packages for version: ${VERSION}"

      - name: Build npm packages
        env:
          VERSION: v${{ steps.version.outputs.version }}
        run: ./packaging/scripts/build-npm-packages.sh

      - name: Publish platform packages to npm
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TAG: ${{ steps.version.outputs.npm_tag }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          cd dist/npm

          echo "Publishing with npm tag: ${NPM_TAG}"

          # Publish platform-specific packages first (order matters!)
          for pkg in cli-linux-x64 cli-linux-arm64 cli-darwin-x64 cli-darwin-arm64; do
            if [ -d "$pkg" ]; then
              echo "Publishing @mcpmesh/$pkg with tag ${NPM_TAG}..."
              cd "$pkg"
              npm publish --access public --tag "${NPM_TAG}" || echo "Package may already exist, continuing..."
              cd ..
            fi
          done

      - name: Publish main CLI package to npm
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TAG: ${{ steps.version.outputs.npm_tag }}
        run: |
          cd dist/npm/cli
          echo "Publishing @mcpmesh/cli with tag ${NPM_TAG}..."
          npm publish --access public --tag "${NPM_TAG}"

      - name: Verify npm installation
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Waiting for npm to index packages..."
          sleep 30

          # Create temp directory and test installation
          mkdir -p /tmp/npm-test
          cd /tmp/npm-test
          npm init -y

          echo "Testing npm install @mcpmesh/cli@${VERSION}..."
          npm install @mcpmesh/cli@${VERSION} || echo "Package may not be indexed yet"

          # Try to run meshctl
          if [ -f node_modules/.bin/meshctl ]; then
            node_modules/.bin/meshctl --version || true
            echo "✓ npm package installation verified"
          else
            echo "⚠ Binary not found, package may need more time to propagate"
          fi

  # Publish Python package to PyPI
  # Depends on publish-rust-core so mcp-mesh-core is available as a dependency
  publish-python:
    runs-on: ubuntu-latest
    needs: [build-binaries, build-macos-binaries, publish-rust-core]
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    permissions:
      contents: read
      id-token: write # For trusted publishing
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          VERSION=${VERSION#v}
          VERSION_PYPI=$(echo "$VERSION" | sed 's/-beta\./b/' | sed 's/-rc\./rc/' | sed 's/-alpha\./a/')
          echo "version_pypi=${VERSION_PYPI}" >> $GITHUB_OUTPUT

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Prepare packaging files
        working-directory: packaging/pypi
        run: |
          cp ../../src/runtime/python/README.md .
          cp ../../LICENSE .
          cp -r ../../src/runtime/python/_mcp_mesh .
          cp -r ../../src/runtime/python/mesh .

      - name: Update version in packaging files
        working-directory: packaging/pypi
        run: |
          # Determine version
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          VERSION=${VERSION#v}  # Remove 'v' prefix

          # Convert to PyPI PEP 440 format: 0.8.0-beta.1 → 0.8.0b1, 0.8.0-rc.1 → 0.8.0rc1
          VERSION_PYPI=$(echo "$VERSION" | sed 's/-beta\./b/' | sed 's/-rc\./rc/' | sed 's/-alpha\./a/')

          # Check if prerelease
          if [[ "$VERSION" == *"-beta"* ]] || [[ "$VERSION" == *"-rc"* ]] || [[ "$VERSION" == *"-alpha"* ]]; then
            IS_PRERELEASE=true
          else
            IS_PRERELEASE=false
          fi

          # Debug output
          echo "Event name: ${{ github.event_name }}"
          echo "Ref name: ${{ github.ref_name }}"
          echo "Detected version: ${VERSION}"
          echo "PyPI version (PEP 440): ${VERSION_PYPI}"
          echo "Is prerelease: ${IS_PRERELEASE}"
          echo "Current version in file: $(grep '__version__' _mcp_mesh/__init__.py)"

          # Update version in both __init__.py and pyproject.toml (using PEP 440 format)
          sed -i "s/__version__ = \".*\"/__version__ = \"${VERSION_PYPI}\"/" _mcp_mesh/__init__.py
          sed -i "s/version = \".*\"/version = \"${VERSION_PYPI}\"/" pyproject.toml

          # Also update mcp-mesh-core dependency version for prereleases
          if [[ "$IS_PRERELEASE" == "true" ]]; then
            # Update dependency to allow prerelease versions: >=0.8.0b1
            sed -i "s/\"mcp-mesh-core>=.*\"/\"mcp-mesh-core>=${VERSION_PYPI}\"/" pyproject.toml
          fi

          # Verify the versions were updated
          echo "Updated __init__.py version to: $(grep '__version__' _mcp_mesh/__init__.py)"
          echo "Updated pyproject.toml version to: $(grep 'version = ' pyproject.toml)"
          echo "Updated mcp-mesh-core dependency: $(grep 'mcp-mesh-core' pyproject.toml)"

      - name: Build package
        working-directory: packaging/pypi
        run: python -m build

      - name: Check package
        working-directory: packaging/pypi
        run: twine check dist/*

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: packaging/pypi/dist/
          password: ${{ secrets.PYPI_API_TOKEN }}

      - name: Wait for PyPI to index mcp-mesh
        run: |
          VERSION="${{ steps.version.outputs.version_pypi }}"
          echo "Waiting for PyPI to index mcp-mesh==${VERSION}..."
          MAX_ATTEMPTS=30
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking PyPI..."
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://pypi.org/pypi/mcp-mesh/${VERSION}/json")
            echo "  PyPI API: HTTP $HTTP_STATUS"
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "✅ mcp-mesh==${VERSION} is now available on PyPI"
              exit 0
            fi
            echo "Not indexed yet, waiting 10 seconds..."
            sleep 10
          done
          echo "❌ ERROR: mcp-mesh==${VERSION} not available on PyPI after ${MAX_ATTEMPTS} attempts (5 minutes)"
          exit 1

  # Build and push Docker images
  build-docker:
    runs-on: ubuntu-latest
    needs: [publish-python, publish-typescript-sdk, publish-java-sdk]
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine version and tags
        id: meta
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="dev-${{ github.sha }}"
          fi

          # Remove 'v' prefix if present
          VERSION=${VERSION#v}
          # For install script in Dockerfiles, we need the v prefix
          VERSION_WITH_V="v${VERSION}"

          # PyPI PEP 440 format: 0.8.0-beta.1 → 0.8.0b1, 0.8.0-rc.1 → 0.8.0rc1
          VERSION_PYPI=$(echo "$VERSION" | sed 's/-beta\./b/' | sed 's/-rc\./rc/' | sed 's/-alpha\./a/')
          echo "version_pypi=${VERSION_PYPI}" >> $GITHUB_OUTPUT

          # Check if prerelease
          if [[ "$VERSION" == *"-beta"* ]] || [[ "$VERSION" == *"-rc"* ]] || [[ "$VERSION" == *"-alpha"* ]]; then
            IS_PRERELEASE=true
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            IS_PRERELEASE=false
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi

          # Create semantic version tags (e.g., 0.5.0 -> 0.5.0, 0.5, 0)
          # For prereleases, only use the full version tag, no major/minor/latest
          if [[ "$IS_PRERELEASE" == "true" ]]; then
            # For prereleases, use full version only (e.g., 0.8.0-beta.1)
            echo "major_version=${VERSION}" >> $GITHUB_OUTPUT
            echo "minor_version=${VERSION}" >> $GITHUB_OUTPUT
            echo "patch_version=${VERSION}" >> $GITHUB_OUTPUT
            echo "tag_latest=false" >> $GITHUB_OUTPUT
          elif [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            MAJOR=$(echo "$VERSION" | cut -d. -f1)
            MINOR=$(echo "$VERSION" | cut -d. -f1-2)
            PATCH="$VERSION"

            echo "major_version=${MAJOR}" >> $GITHUB_OUTPUT
            echo "minor_version=${MINOR}" >> $GITHUB_OUTPUT
            echo "patch_version=${PATCH}" >> $GITHUB_OUTPUT
            echo "tag_latest=true" >> $GITHUB_OUTPUT
          else
            # For non-semver versions (dev, etc.), use version as-is
            echo "major_version=${VERSION}" >> $GITHUB_OUTPUT
            echo "minor_version=${VERSION}" >> $GITHUB_OUTPUT
            echo "patch_version=${VERSION}" >> $GITHUB_OUTPUT
            echo "tag_latest=false" >> $GITHUB_OUTPUT
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_with_v=${VERSION_WITH_V}" >> $GITHUB_OUTPUT
          echo "Building Docker images for version: ${VERSION} (PyPI: ${VERSION_PYPI}, prerelease: ${IS_PRERELEASE})"

      - name: Compute Docker tags
        id: docker_tags
        run: |
          VERSION="${{ steps.meta.outputs.patch_version }}"
          IS_PRERELEASE="${{ steps.meta.outputs.is_prerelease }}"
          REGISTRY="${{ env.REGISTRY }}"
          GHCR_REPO="ghcr.io/${{ github.repository }}"

          # For prereleases, only use version tag (no latest, no major/minor)
          if [[ "$IS_PRERELEASE" == "true" ]]; then
            REGISTRY_TAGS="${REGISTRY}/registry:${VERSION}"
            REGISTRY_TAGS="${REGISTRY_TAGS},${GHCR_REPO}/registry:${VERSION}"

            PYTHON_TAGS="${REGISTRY}/python-runtime:${VERSION}"
            PYTHON_TAGS="${PYTHON_TAGS},${GHCR_REPO}/python-runtime:${VERSION}"

            TYPESCRIPT_TAGS="${REGISTRY}/typescript-runtime:${VERSION}"
            TYPESCRIPT_TAGS="${TYPESCRIPT_TAGS},${GHCR_REPO}/typescript-runtime:${VERSION}"

            JAVA_TAGS="${REGISTRY}/java-runtime:${VERSION}"
            JAVA_TAGS="${JAVA_TAGS},${GHCR_REPO}/java-runtime:${VERSION}"

            CLI_TAGS="${REGISTRY}/cli:${VERSION}"
            CLI_TAGS="${CLI_TAGS},${GHCR_REPO}/cli:${VERSION}"
          else
            # For stable releases, include all semantic version tags + latest
            MAJOR="${{ steps.meta.outputs.major_version }}"
            MINOR="${{ steps.meta.outputs.minor_version }}"
            PATCH="${{ steps.meta.outputs.patch_version }}"

            REGISTRY_TAGS="${REGISTRY}/registry:${PATCH}"
            REGISTRY_TAGS="${REGISTRY_TAGS},${REGISTRY}/registry:${MINOR}"
            REGISTRY_TAGS="${REGISTRY_TAGS},${REGISTRY}/registry:${MAJOR}"
            REGISTRY_TAGS="${REGISTRY_TAGS},${REGISTRY}/registry:latest"
            REGISTRY_TAGS="${REGISTRY_TAGS},${GHCR_REPO}/registry:${PATCH}"
            REGISTRY_TAGS="${REGISTRY_TAGS},${GHCR_REPO}/registry:${MINOR}"
            REGISTRY_TAGS="${REGISTRY_TAGS},${GHCR_REPO}/registry:${MAJOR}"
            REGISTRY_TAGS="${REGISTRY_TAGS},${GHCR_REPO}/registry:latest"

            PYTHON_TAGS="${REGISTRY}/python-runtime:${PATCH}"
            PYTHON_TAGS="${PYTHON_TAGS},${REGISTRY}/python-runtime:${MINOR}"
            PYTHON_TAGS="${PYTHON_TAGS},${REGISTRY}/python-runtime:${MAJOR}"
            PYTHON_TAGS="${PYTHON_TAGS},${REGISTRY}/python-runtime:latest"
            PYTHON_TAGS="${PYTHON_TAGS},${GHCR_REPO}/python-runtime:${PATCH}"
            PYTHON_TAGS="${PYTHON_TAGS},${GHCR_REPO}/python-runtime:${MINOR}"
            PYTHON_TAGS="${PYTHON_TAGS},${GHCR_REPO}/python-runtime:${MAJOR}"
            PYTHON_TAGS="${PYTHON_TAGS},${GHCR_REPO}/python-runtime:latest"

            TYPESCRIPT_TAGS="${REGISTRY}/typescript-runtime:${PATCH}"
            TYPESCRIPT_TAGS="${TYPESCRIPT_TAGS},${REGISTRY}/typescript-runtime:${MINOR}"
            TYPESCRIPT_TAGS="${TYPESCRIPT_TAGS},${REGISTRY}/typescript-runtime:${MAJOR}"
            TYPESCRIPT_TAGS="${TYPESCRIPT_TAGS},${REGISTRY}/typescript-runtime:latest"
            TYPESCRIPT_TAGS="${TYPESCRIPT_TAGS},${GHCR_REPO}/typescript-runtime:${PATCH}"
            TYPESCRIPT_TAGS="${TYPESCRIPT_TAGS},${GHCR_REPO}/typescript-runtime:${MINOR}"
            TYPESCRIPT_TAGS="${TYPESCRIPT_TAGS},${GHCR_REPO}/typescript-runtime:${MAJOR}"
            TYPESCRIPT_TAGS="${TYPESCRIPT_TAGS},${GHCR_REPO}/typescript-runtime:latest"

            JAVA_TAGS="${REGISTRY}/java-runtime:${PATCH}"
            JAVA_TAGS="${JAVA_TAGS},${REGISTRY}/java-runtime:${MINOR}"
            JAVA_TAGS="${JAVA_TAGS},${REGISTRY}/java-runtime:${MAJOR}"
            JAVA_TAGS="${JAVA_TAGS},${REGISTRY}/java-runtime:latest"
            JAVA_TAGS="${JAVA_TAGS},${GHCR_REPO}/java-runtime:${PATCH}"
            JAVA_TAGS="${JAVA_TAGS},${GHCR_REPO}/java-runtime:${MINOR}"
            JAVA_TAGS="${JAVA_TAGS},${GHCR_REPO}/java-runtime:${MAJOR}"
            JAVA_TAGS="${JAVA_TAGS},${GHCR_REPO}/java-runtime:latest"

            CLI_TAGS="${REGISTRY}/cli:${PATCH}"
            CLI_TAGS="${CLI_TAGS},${REGISTRY}/cli:${MINOR}"
            CLI_TAGS="${CLI_TAGS},${REGISTRY}/cli:${MAJOR}"
            CLI_TAGS="${CLI_TAGS},${REGISTRY}/cli:latest"
            CLI_TAGS="${CLI_TAGS},${GHCR_REPO}/cli:${PATCH}"
            CLI_TAGS="${CLI_TAGS},${GHCR_REPO}/cli:${MINOR}"
            CLI_TAGS="${CLI_TAGS},${GHCR_REPO}/cli:${MAJOR}"
            CLI_TAGS="${CLI_TAGS},${GHCR_REPO}/cli:latest"
          fi

          echo "registry_tags=${REGISTRY_TAGS}" >> $GITHUB_OUTPUT
          echo "python_tags=${PYTHON_TAGS}" >> $GITHUB_OUTPUT
          echo "typescript_tags=${TYPESCRIPT_TAGS}" >> $GITHUB_OUTPUT
          echo "java_tags=${JAVA_TAGS}" >> $GITHUB_OUTPUT
          echo "cli_tags=${CLI_TAGS}" >> $GITHUB_OUTPUT

          echo "Registry tags: ${REGISTRY_TAGS}"
          echo "Python runtime tags: ${PYTHON_TAGS}"
          echo "TypeScript runtime tags: ${TYPESCRIPT_TAGS}"
          echo "Java runtime tags: ${JAVA_TAGS}"
          echo "CLI tags: ${CLI_TAGS}"

      - name: Build and push Registry image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packaging/docker/registry.Dockerfile
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ steps.meta.outputs.version_with_v }}
          push: true
          tags: ${{ steps.docker_tags.outputs.registry_tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Test Registry image functionality
        run: |
          # Build test image locally to validate before pushing
          docker build -f ./packaging/docker/registry.Dockerfile \
            --build-arg VERSION=${{ steps.meta.outputs.version_with_v }} \
            -t test-registry:validation .

          # Test 1: Verify binary works and shows help
          echo "Testing registry binary help..."
          docker run --rm test-registry:validation --help

          # Test 2: Start registry and test SQLite functionality
          echo "Testing SQLite functionality..."
          CONTAINER_ID=$(docker run -d -p 28000:8000 test-registry:validation)
          sleep 5

          # Test health endpoint (verifies SQLite is working)
          HEALTH_RESPONSE=$(curl -s http://localhost:28000/health || echo "FAILED")
          echo "Health response: $HEALTH_RESPONSE"

          # Verify health response contains expected fields
          if echo "$HEALTH_RESPONSE" | grep -q '"status":"healthy"'; then
            echo "✅ Registry health check passed - SQLite is working"
          else
            echo "❌ Registry health check failed - SQLite may not be working"
            docker logs $CONTAINER_ID
            exit 1
          fi

          # Test 3: Verify SQLite database was created
          docker exec $CONTAINER_ID ls -la /data/

          # Clean up
          docker stop $CONTAINER_ID
          docker rm $CONTAINER_ID

          echo "✅ All registry functionality tests passed"

      - name: Build and push Python Runtime image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packaging/docker/python-runtime.Dockerfile
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ steps.meta.outputs.version_pypi }}
          push: true
          tags: ${{ steps.docker_tags.outputs.python_tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push CLI image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packaging/docker/cli.Dockerfile
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ steps.meta.outputs.version_with_v }}
          push: true
          tags: ${{ steps.docker_tags.outputs.cli_tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push TypeScript Runtime image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packaging/docker/typescript-runtime.Dockerfile
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ steps.meta.outputs.version }}
          push: true
          tags: ${{ steps.docker_tags.outputs.typescript_tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Wait for Maven Central to index Java SDK
        run: |
          VERSION="${{ steps.meta.outputs.version }}"
          BASE_URL="https://repo1.maven.org/maven2/io/mcp-mesh/mcp-mesh-spring-boot-starter/${VERSION}"
          POM_URL="${BASE_URL}/mcp-mesh-spring-boot-starter-${VERSION}.pom"
          JAR_URL="${BASE_URL}/mcp-mesh-spring-boot-starter-${VERSION}.jar"
          echo "Waiting for Maven Central to index io.mcp-mesh:mcp-mesh-spring-boot-starter:${VERSION}..."
          MAX_ATTEMPTS=30
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking Maven Central..."
            POM_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$POM_URL")
            JAR_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$JAR_URL")
            echo "  POM: HTTP $POM_STATUS | JAR: HTTP $JAR_STATUS"
            if [ "$POM_STATUS" = "200" ] && [ "$JAR_STATUS" = "200" ]; then
              echo "Maven Central has indexed mcp-mesh-spring-boot-starter-${VERSION}.jar"
              exit 0
            fi
            echo "Not fully indexed yet, waiting 20 seconds..."
            sleep 20
          done
          echo "WARNING: Maven Central may not have fully indexed yet, proceeding with Docker build anyway"

      - name: Build and push Java Runtime image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packaging/docker/java-runtime.Dockerfile
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ steps.meta.outputs.version }}
          push: true
          tags: ${{ steps.docker_tags.outputs.java_tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Update package manager manifests (skip for prereleases)
  update-packages:
    runs-on: ubuntu-latest
    needs: [build-binaries, build-macos-binaries, combine-checksums]
    if: >
      (github.event_name == 'release' ||
       (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')) &&
      !contains(github.ref, 'beta') &&
      !contains(github.ref, 'rc') &&
      !contains(github.ref, 'alpha')
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Update Homebrew formula
        env:
          GITHUB_TOKEN: ${{ secrets.HOMEBREW_PAT_TOKEN }}
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          VERSION_NO_V=${VERSION#v}  # Remove 'v' prefix
          TAG_NAME="$VERSION"

          echo "Updating Homebrew formula for version: $VERSION"

          # Download checksums from release
          curl -L \
            "https://github.com/${{ github.repository }}/releases/download/${TAG_NAME}/checksums.txt" \
            -o checksums.txt

          # Extract SHA256 for macOS binaries
          DARWIN_AMD64_SHA=$(grep "mcp-mesh_${TAG_NAME}_darwin_amd64.tar.gz" checksums.txt | cut -d' ' -f1)
          DARWIN_ARM64_SHA=$(grep "mcp-mesh_${TAG_NAME}_darwin_arm64.tar.gz" checksums.txt | cut -d' ' -f1)

          if [[ -z "$DARWIN_AMD64_SHA" || -z "$DARWIN_ARM64_SHA" ]]; then
            echo "Error: Could not find macOS checksums in checksums.txt"
            cat checksums.txt
            exit 1
          fi

          echo "Darwin AMD64 SHA: $DARWIN_AMD64_SHA"
          echo "Darwin ARM64 SHA: $DARWIN_ARM64_SHA"

          # Create updated formula
          REPO_URL="https://github.com/dhyansraj/mcp-mesh"
          ARM64_URL="${REPO_URL}/releases/download/${TAG_NAME}/mcp-mesh_${TAG_NAME}_darwin_arm64.tar.gz"
          AMD64_URL="${REPO_URL}/releases/download/${TAG_NAME}/mcp-mesh_${TAG_NAME}_darwin_amd64.tar.gz"

          cat > mcp-mesh.rb << EOF
          class McpMesh < Formula
            desc "Distributed service orchestration framework built on the Model Context Protocol"
            homepage "${REPO_URL}"
            url "${ARM64_URL}"
            sha256 "${DARWIN_ARM64_SHA}"
            license "MIT"
            version "${VERSION_NO_V}"

            # Dependencies
            depends_on "go" => :build

            on_macos do
              if Hardware::CPU.intel?
                url "${AMD64_URL}"
                sha256 "${DARWIN_AMD64_SHA}"
              end
            end

            def install
              # Install meshctl CLI
              bin.install "meshctl"

              # Install registry binary
              bin.install "mcp-mesh-registry"
            end

            def caveats
              <<~EOS
                MCP Mesh has been installed with two binaries:
                  • meshctl         - CLI tool for managing MCP Mesh
                  • mcp-mesh-registry - Registry service for service discovery

                To start the registry service:
                  mcp-mesh-registry

                To use the CLI:
                  meshctl --help

                For more information:
                  https://github.com/dhyansraj/mcp-mesh/blob/main/README.md
              EOS
            end

            test do
              # Test that the binaries are installed and can show version/help
              system "#{bin}/meshctl", "--help"
              system "#{bin}/mcp-mesh-registry", "--help"
            end
          end
          EOF

          # Update the formula in the tap repository
          gh api --method PUT \
            "/repos/dhyansraj/homebrew-mcp-mesh/contents/Formula/mcp-mesh.rb" \
            -f message="Update to ${VERSION}" \
            -f content="$(base64 -w 0 mcp-mesh.rb)" \
            -f sha="$(gh api /repos/dhyansraj/homebrew-mcp-mesh/contents/Formula/mcp-mesh.rb --jq '.sha')"

          echo "✅ Homebrew formula updated successfully to ${VERSION}"

      - name: Update Scoop manifest
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          VERSION=${VERSION#v}  # Remove 'v' prefix

          # Update Scoop manifest
          sed -i "s/\"version\": \".*\"/\"version\": \"${VERSION}\"/" packaging/scoop/mcp-mesh.json

          echo "Scoop manifest updated for version: ${VERSION}"

  # Discord notification for successful releases
  notify-discord:
    runs-on: ubuntu-latest
    needs:
      [
        build-binaries,
        build-macos-binaries,
        build-rust-wheels,
        build-node-bindings,
        combine-checksums,
        publish-rust-core,
        publish-node-core,
        publish-typescript-sdk,
        publish-java-sdk,
        publish-python,
        publish-npm,
        build-docker,
        update-packages,
      ]
    if: >
      always() &&
      needs.build-binaries.result == 'success' &&
      needs.build-macos-binaries.result == 'success' &&
      needs.build-rust-wheels.result == 'success' &&
      needs.build-node-bindings.result == 'success' &&
      needs.combine-checksums.result == 'success' &&
      needs.publish-rust-core.result == 'success' &&
      needs.publish-node-core.result == 'success' &&
      needs.publish-typescript-sdk.result == 'success' &&
      needs.publish-java-sdk.result == 'success' &&
      needs.publish-python.result == 'success' &&
      needs.publish-npm.result == 'success' &&
      needs.build-docker.result == 'success' &&
      (needs.update-packages.result == 'success' || needs.update-packages.result == 'skipped') &&
      (github.event_name == 'release' ||
       (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'))
    steps:
      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.sha }}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Discord Webhook Notification
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          RELEASE_URL="${{ github.event.release.html_url }}"
          if [[ -z "$RELEASE_URL" ]]; then
            RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.version }}"
          fi

          # Create JSON payload for Discord webhook with thread_name for forum channels
          CONTENT="🚀 **New MCP Mesh Release!**\\n\\n**Version:** ${VERSION}\\n**Release Notes:** ${RELEASE_URL}\\n\\n"
          CONTENT+="📦 **Install:**\\n"
          CONTENT+="• \\\`npm install -g @mcpmesh/cli\\\` (Node.js/LLMs)\\n"
          CONTENT+="• \\\`pip install mcp-mesh\\\` (Python)\\n"
          CONTENT+="• \\\`brew install dhyansraj/mcp-mesh/mcp-mesh\\\` (macOS)\\n\\n"
          CONTENT+="📦 **Download:**\\n• [GitHub Release](${RELEASE_URL})\\n"
          CONTENT+="• [npm Package](https://www.npmjs.com/package/@mcpmesh/cli)\\n"
          CONTENT+="• [PyPI Package](https://pypi.org/project/mcp-mesh/)\\n"
          CONTENT+="• [Docker Images](https://hub.docker.com/u/mcpmesh)\\n"
          CONTENT+="• [Homebrew](https://github.com/dhyansraj/homebrew-mcp-mesh)"

          PAYLOAD=$(cat <<EOF
          {
            "content": "${CONTENT}",
            "thread_name": "MCP Mesh Release ${VERSION}"
          }
          EOF
          )

          # Send to Discord webhook
          curl -H "Content-Type: application/json" \
               -d "$PAYLOAD" \
               "${{ secrets.DISCORD_WEBHOOK }}"
